<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Fluent</name>
    </assembly>
    <members>
        <member name="T:Fluent.KeyTipAdorner">
            <summary>
            Represents adorner for KeyTips.
            KeyTipAdorners is chained to produce one from another.
            Detaching root adorner couses detaching all adorners in the chain
            </summary>
        </member>
        <member name="E:Fluent.KeyTipAdorner.Terminated">
            <summary>
            This event is occured when adorner is
            detached and is not able to be attached again
            </summary>
        </member>
        <member name="P:Fluent.KeyTipAdorner.IsAdornerChainAlive">
            <summary>
            Determines whether at least one on the adorners in the chain is alive
            </summary>
        </member>
        <member name="P:Fluent.KeyTipAdorner.AreAnyKeyTipsVisible">
            <summary>
            Returns whether any key tips are visibile.
            </summary>
        </member>
        <member name="P:Fluent.KeyTipAdorner.ActiveKeyTipAdorner">
            <summary>
            Gets the currently active <see cref="T:Fluent.KeyTipAdorner"/> by following eventually present child adorners.
            </summary>
        </member>
        <member name="P:Fluent.KeyTipAdorner.KeyTipInformations">
            <summary>
            Gets a copied list of the currently available <see cref="T:Fluent.KeyTipInformation"/>.
            </summary>
        </member>
        <member name="M:Fluent.KeyTipAdorner.#ctor(System.Windows.FrameworkElement,System.Windows.FrameworkElement,Fluent.KeyTipAdorner)">
            <summary>
            Construcotor
            </summary>
            <param name="adornedElement">Element to adorn.</param>
            <param name="parentAdorner">Parent adorner or null.</param>
            <param name="keyTipElementContainer">The element which is container for elements.</param>
        </member>
        <member name="M:Fluent.KeyTipAdorner.Attach">
            <summary>
            Attaches this adorner to the adorned element
            </summary>
        </member>
        <member name="M:Fluent.KeyTipAdorner.Detach">
            <summary>
            Detaches this adorner from the adorned element
            </summary>
        </member>
        <member name="M:Fluent.KeyTipAdorner.Terminate(Fluent.KeyTipPressedResult)">
            <summary>
            Terminate whole key tip's adorner chain
            </summary>
        </member>
        <member name="M:Fluent.KeyTipAdorner.Back">
            <summary>
            Back to the previous adorner.
            </summary>
        </member>
        <member name="M:Fluent.KeyTipAdorner.Forward(System.String,System.Boolean)">
            <summary>
            Forwards to the elements with the given keys
            </summary>
            <param name="keys">Keys</param>
            <param name="click">If true the element will be clicked</param>
            <returns>If the element will be found the function will return true</returns>
        </member>
        <member name="M:Fluent.KeyTipAdorner.Forward(System.String,System.Windows.FrameworkElement,System.Boolean)">
            <summary>
            Forwards to the elements with the given keys to a given element.
            </summary>
            <param name="keys">Keys</param>
            <param name="element">The element to forward to.</param>
            <param name="click">If true the element will be clicked</param>
        </member>
        <member name="M:Fluent.KeyTipAdorner.TryGetKeyTipInformation(System.String)">
            <summary>
            Gets <see cref="T:Fluent.KeyTipInformation"/> by keys.
            </summary>
            <param name="keys">The keys to look for.</param>
            <returns>The <see cref="T:Fluent.KeyTipInformation"/> associated with <paramref name="keys"/>.</returns>
        </member>
        <member name="M:Fluent.KeyTipAdorner.ContainsKeyTipStartingWith(System.String)">
            <summary>
            Determines if an of the keytips contained in this adorner start with <paramref name="keys"/>
            </summary>
            <returns><c>true</c> if any keytip start with <paramref name="keys"/>. Otherwise <c>false</c>.</returns>
        </member>
        <member name="M:Fluent.KeyTipAdorner.ArrangeOverride(System.Windows.Size)">
            <inheritdoc />
        </member>
        <member name="M:Fluent.KeyTipAdorner.MeasureOverride(System.Windows.Size)">
            <inheritdoc />
        </member>
        <member name="P:Fluent.KeyTipAdorner.VisualChildrenCount">
            <inheritdoc />
        </member>
        <member name="M:Fluent.KeyTipAdorner.GetVisualChild(System.Int32)">
            <inheritdoc />
        </member>
        <member name="T:Fluent.InputControlProperties">
            <summary>
            Attached Properties for controls with an text input part
            </summary>
        </member>
        <member name="T:Fluent.RibbonProperties">
            <summary>
            Attached Properties for the Fluent Ribbon library
            </summary>
        </member>
        <member name="F:Fluent.RibbonProperties.SizeProperty">
            <summary>
            Using a DependencyProperty as the backing store for Size.
            This enables animation, styling, binding, etc...
            </summary>
        </member>
        <member name="M:Fluent.RibbonProperties.SetSize(System.Windows.DependencyObject,Fluent.RibbonControlSize)">
            <summary>
            Sets <see cref="F:Fluent.RibbonProperties.SizeProperty"/> for <paramref name="element"/>.
            </summary>
        </member>
        <member name="M:Fluent.RibbonProperties.GetSize(System.Windows.DependencyObject)">
            <summary>
            Gets <see cref="F:Fluent.RibbonProperties.SizeProperty"/> for <paramref name="element"/>.
            </summary>
        </member>
        <member name="F:Fluent.RibbonProperties.SizeDefinitionProperty">
            <summary>
            Using a DependencyProperty as the backing store for SizeDefinition.
            This enables animation, styling, binding, etc...
            </summary>
        </member>
        <member name="M:Fluent.RibbonProperties.SetSizeDefinition(System.Windows.DependencyObject,Fluent.RibbonControlSizeDefinition)">
            <summary>
            Sets <see cref="F:Fluent.RibbonProperties.SizeDefinitionProperty"/> for <paramref name="element"/>.
            </summary>
        </member>
        <member name="M:Fluent.RibbonProperties.GetSizeDefinition(System.Windows.DependencyObject)">
            <summary>
            Gets <see cref="F:Fluent.RibbonProperties.SizeDefinitionProperty"/> for <paramref name="element"/>.
            </summary>
        </member>
        <member name="M:Fluent.RibbonProperties.SetAppropriateSize(System.Windows.DependencyObject,Fluent.RibbonGroupBoxState,System.Boolean)">
            <summary>
            Sets appropriate size of the control according to the
            given group box state and control's size definition
            </summary>
            <param name="element">UI Element</param>
            <param name="state">Group box state</param>
            <param name="isSimplified">Group box isSimplified state</param>
        </member>
        <member name="F:Fluent.RibbonProperties.SimplifiedSizeDefinitionProperty">
            <summary>
            Using a DependencyProperty as the backing store for SimplifiedSizeDefinition.
            This enables animation, styling, binding, etc...
            </summary>
        </member>
        <member name="M:Fluent.RibbonProperties.SetSimplifiedSizeDefinition(System.Windows.DependencyObject,Fluent.RibbonControlSizeDefinition)">
            <summary>
            Sets <see cref="F:Fluent.RibbonProperties.SimplifiedSizeDefinitionProperty"/> for <paramref name="element"/>.
            </summary>
        </member>
        <member name="M:Fluent.RibbonProperties.GetSimplifiedSizeDefinition(System.Windows.DependencyObject)">
            <summary>
            Gets <see cref="F:Fluent.RibbonProperties.SimplifiedSizeDefinitionProperty"/> for <paramref name="element"/>.
            </summary>
        </member>
        <member name="M:Fluent.RibbonProperties.SetAppropriateSize(System.Windows.DependencyObject,Fluent.RibbonControlSize)">
            <summary>
            Sets appropriate size of the control according to the
            given ribbon control size and control's size definition
            </summary>
            <param name="element">UI Element</param>
            <param name="size">Ribbon control size before applying SizeDefinition</param>
        </member>
        <member name="F:Fluent.RibbonProperties.MouseOverBackgroundProperty">
            <summary>
            <see cref="T:System.Windows.DependencyProperty"/> for specifying MouseOverBackground.
            </summary>
        </member>
        <member name="M:Fluent.RibbonProperties.SetMouseOverBackground(System.Windows.DependencyObject,System.Windows.Media.Brush)">
            <summary>
            Sets <see cref="F:Fluent.RibbonProperties.MouseOverBackgroundProperty"/> for <paramref name="element"/>.
            </summary>
        </member>
        <member name="M:Fluent.RibbonProperties.GetMouseOverBackground(System.Windows.DependencyObject)">
            <summary>
            Gets <see cref="F:Fluent.RibbonProperties.MouseOverBackgroundProperty"/> for <paramref name="element"/>.
            </summary>
        </member>
        <member name="F:Fluent.RibbonProperties.PressedBackgroundProperty">
            <summary>
            <see cref="T:System.Windows.DependencyProperty"/> for specifying PressedBackground.
            </summary>
        </member>
        <member name="M:Fluent.RibbonProperties.SetPressedBackground(System.Windows.DependencyObject,System.Windows.Media.Brush)">
            <summary>
            Sets <see cref="F:Fluent.RibbonProperties.PressedBackgroundProperty"/> for <paramref name="element"/>.
            </summary>
        </member>
        <member name="M:Fluent.RibbonProperties.GetPressedBackground(System.Windows.DependencyObject)">
            <summary>
            Gets <see cref="F:Fluent.RibbonProperties.PressedBackgroundProperty"/> for <paramref name="element"/>.
            </summary>
        </member>
        <member name="F:Fluent.RibbonProperties.MouseOverForegroundProperty">
            <summary>
            <see cref="T:System.Windows.DependencyProperty"/> for specifying MouseOverForeground.
            </summary>
        </member>
        <member name="M:Fluent.RibbonProperties.SetMouseOverForeground(System.Windows.DependencyObject,System.Windows.Media.Brush)">
            <summary>
            Sets <see cref="F:Fluent.RibbonProperties.MouseOverForegroundProperty"/> for <paramref name="element"/>.
            </summary>
        </member>
        <member name="M:Fluent.RibbonProperties.GetMouseOverForeground(System.Windows.DependencyObject)">
            <summary>
            Gets <see cref="F:Fluent.RibbonProperties.MouseOverForegroundProperty"/> for <paramref name="element"/>.
            </summary>
        </member>
        <member name="F:Fluent.RibbonProperties.IsSelectedBackgroundProperty">
            <summary>
            <see cref="T:System.Windows.DependencyProperty"/> for specifying IsSelectedBackground.
            </summary>
        </member>
        <member name="M:Fluent.RibbonProperties.SetIsSelectedBackground(System.Windows.DependencyObject,System.Windows.Media.Brush)">
            <summary>
            Sets <see cref="F:Fluent.RibbonProperties.IsSelectedBackgroundProperty"/> for <paramref name="element"/>.
            </summary>
        </member>
        <member name="M:Fluent.RibbonProperties.GetIsSelectedBackground(System.Windows.DependencyObject)">
            <summary>
            Gets <see cref="F:Fluent.RibbonProperties.IsSelectedBackgroundProperty"/> for <paramref name="element"/>.
            </summary>
        </member>
        <member name="F:Fluent.RibbonProperties.LastVisibleWidthProperty">
            <summary>
            Stores the last visible width of an element.
            </summary>
        </member>
        <member name="M:Fluent.RibbonProperties.SetLastVisibleWidth(System.Windows.DependencyObject,System.Double)">
            <summary>Helper for setting <see cref="F:Fluent.RibbonProperties.LastVisibleWidthProperty"/> on <paramref name="element"/>.</summary>
        </member>
        <member name="M:Fluent.RibbonProperties.GetLastVisibleWidth(System.Windows.DependencyObject)">
            <summary>Helper for getting <see cref="F:Fluent.RibbonProperties.LastVisibleWidthProperty"/> on <paramref name="element"/>.</summary>
        </member>
        <member name="F:Fluent.RibbonProperties.IsElementInQuickAccessToolBarProperty">
            <summary>
            Defines if the element is part of the <see cref="T:Fluent.QuickAccessToolBar"/>.
            </summary>
        </member>
        <member name="M:Fluent.RibbonProperties.SetIsElementInQuickAccessToolBar(System.Windows.DependencyObject,System.Boolean)">
            <summary>Helper for setting <see cref="F:Fluent.RibbonProperties.IsElementInQuickAccessToolBarProperty"/> on <paramref name="element"/>.</summary>
        </member>
        <member name="M:Fluent.RibbonProperties.GetIsElementInQuickAccessToolBar(System.Windows.DependencyObject)">
            <summary>Helper for getting <see cref="F:Fluent.RibbonProperties.IsElementInQuickAccessToolBarProperty"/> on <paramref name="element"/>.</summary>
        </member>
        <member name="F:Fluent.RibbonProperties.IconSizeProperty">
            <summary>
            Defines the desired icon size for the element.
            </summary>
        </member>
        <member name="M:Fluent.RibbonProperties.SetIconSize(System.Windows.DependencyObject,Fluent.IconSize)">
            <summary>Helper for setting <see cref="F:Fluent.RibbonProperties.IconSizeProperty"/> on <paramref name="element"/>.</summary>
        </member>
        <member name="M:Fluent.RibbonProperties.GetIconSize(System.Windows.DependencyObject)">
            <summary>Helper for getting <see cref="F:Fluent.RibbonProperties.IconSizeProperty"/> from <paramref name="element"/>.</summary>
        </member>
        <member name="F:Fluent.RibbonProperties.CustomIconSizeProperty">
            <summary>
            Defines the custom icon size for the element.
            </summary>
        </member>
        <member name="M:Fluent.RibbonProperties.SetCustomIconSize(System.Windows.DependencyObject,System.Windows.Size)">
            <summary>Helper for setting <see cref="F:Fluent.RibbonProperties.CustomIconSizeProperty"/> on <paramref name="element"/>.</summary>
        </member>
        <member name="M:Fluent.RibbonProperties.GetCustomIconSize(System.Windows.DependencyObject)">
            <summary>Helper for getting <see cref="F:Fluent.RibbonProperties.CustomIconSizeProperty"/> from <paramref name="element"/>.</summary>
        </member>
        <member name="F:Fluent.RibbonProperties.CornerRadiusProperty">
            <summary>
            Defines the corner radius used in template parts.
            </summary>
        </member>
        <member name="M:Fluent.RibbonProperties.SetCornerRadius(System.Windows.DependencyObject,System.Windows.CornerRadius)">
            <summary>Helper for setting <see cref="F:Fluent.RibbonProperties.CornerRadiusProperty"/> on <paramref name="element"/>.</summary>
        </member>
        <member name="M:Fluent.RibbonProperties.GetCornerRadius(System.Windows.DependencyObject)">
            <summary>Helper for getting <see cref="F:Fluent.RibbonProperties.CornerRadiusProperty"/> on <paramref name="element"/>.</summary>
        </member>
        <member name="T:Fluent.ScrollViewerAttachedProperties">
            <summary>
            Attached properties for <see cref="T:System.Windows.Controls.ScrollViewer"/>.
            </summary>
        </member>
        <member name="F:Fluent.ScrollViewerAttachedProperties.ScrollBarStyleProperty">
            <summary>
            Defines the <see cref="T:System.Windows.Style"/> to be used for the <see cref="T:System.Windows.Controls.Primitives.ScrollBar"/> of an <see cref="T:System.Windows.Controls.ScrollViewer"/>.
            </summary>
        </member>
        <member name="M:Fluent.ScrollViewerAttachedProperties.SetScrollBarStyle(System.Windows.DependencyObject,System.Windows.Style)">
            <summary>Helper for setting <see cref="F:Fluent.ScrollViewerAttachedProperties.ScrollBarStyleProperty"/> on <paramref name="element"/>.</summary>
            <param name="element"><see cref="T:System.Windows.DependencyObject"/> to set <see cref="F:Fluent.ScrollViewerAttachedProperties.ScrollBarStyleProperty"/> on.</param>
            <param name="value">ScrollBarStyle property value.</param>
        </member>
        <member name="M:Fluent.ScrollViewerAttachedProperties.GetScrollBarStyle(System.Windows.DependencyObject)">
            <summary>Helper for getting <see cref="F:Fluent.ScrollViewerAttachedProperties.ScrollBarStyleProperty"/> from <paramref name="element"/>.</summary>
            <param name="element"><see cref="T:System.Windows.DependencyObject"/> to read <see cref="F:Fluent.ScrollViewerAttachedProperties.ScrollBarStyleProperty"/> from.</param>
            <returns>ScrollBarStyle property value.</returns>
        </member>
        <member name="T:Fluent.Automation.Peers.GalleryItemAutomationPeer">
            <summary>
            <see cref="T:System.Windows.Automation.Peers.AutomationPeer"/> for <see cref="T:Fluent.GalleryItem"/>.
            </summary>
        </member>
        <member name="M:Fluent.Automation.Peers.GalleryItemAutomationPeer.#ctor(System.Object,System.Windows.Automation.Peers.SelectorAutomationPeer)">
            <inheritdoc cref="T:System.Windows.Automation.Peers.SelectorItemAutomationPeer" />
        </member>
        <member name="M:Fluent.Automation.Peers.GalleryItemAutomationPeer.GetClassNameCore">
            <inheritdoc />
        </member>
        <member name="M:Fluent.Automation.Peers.GalleryItemAutomationPeer.GetAutomationControlTypeCore">
            <inheritdoc />
        </member>
        <member name="M:Fluent.Automation.Peers.GalleryItemAutomationPeer.GetPattern(System.Windows.Automation.Peers.PatternInterface)">
            <inheritdoc />
        </member>
        <member name="T:Fluent.Automation.Peers.GalleryItemWrapperAutomationPeer">
            <inheritdoc />
        </member>
        <member name="M:Fluent.Automation.Peers.GalleryItemWrapperAutomationPeer.#ctor(Fluent.GalleryItem)">
            <inheritdoc cref="T:System.Windows.Automation.Peers.FrameworkElementAutomationPeer" />
        </member>
        <member name="M:Fluent.Automation.Peers.GalleryItemWrapperAutomationPeer.GetClassNameCore">
            <inheritdoc />
        </member>
        <member name="M:Fluent.Automation.Peers.GalleryItemWrapperAutomationPeer.GetAutomationControlTypeCore">
            <inheritdoc />
        </member>
        <member name="T:Fluent.Automation.Peers.RibbonAutomationPeer">
            <summary>
            Automation peer for <see cref="T:Fluent.Ribbon"/>.
            </summary>
        </member>
        <member name="M:Fluent.Automation.Peers.RibbonAutomationPeer.#ctor(Fluent.Ribbon)">
            <summary>
            Creates a new instance.
            </summary>
        </member>
        <member name="M:Fluent.Automation.Peers.RibbonAutomationPeer.GetClassNameCore">
            <inheritdoc />
        </member>
        <member name="M:Fluent.Automation.Peers.RibbonAutomationPeer.GetNameCore">
            <inheritdoc />
        </member>
        <member name="M:Fluent.Automation.Peers.RibbonAutomationPeer.GetLocalizedControlTypeCore">
            <inheritdoc />
        </member>
        <member name="M:Fluent.Automation.Peers.RibbonAutomationPeer.GetPattern(System.Windows.Automation.Peers.PatternInterface)">
            <inheritdoc />
        </member>
        <member name="M:Fluent.Automation.Peers.RibbonAutomationPeer.GetChildrenCore">
            <inheritdoc />
        </member>
        <member name="M:Fluent.Automation.Peers.RibbonAutomationPeer.IsOffscreenCore">
            <inheritdoc/>
        </member>
        <member name="M:Fluent.Automation.Peers.RibbonAutomationPeer.System#Windows#Automation#Provider#IExpandCollapseProvider#Collapse">
            <inheritdoc />
        </member>
        <member name="M:Fluent.Automation.Peers.RibbonAutomationPeer.System#Windows#Automation#Provider#IExpandCollapseProvider#Expand">
            <inheritdoc />
        </member>
        <member name="P:Fluent.Automation.Peers.RibbonAutomationPeer.System#Windows#Automation#Provider#IExpandCollapseProvider#ExpandCollapseState">
            <inheritdoc />
        </member>
        <member name="M:Fluent.Automation.Peers.RibbonAutomationPeer.CreatePeerForMenu">
            <summary>
            Creates the <see cref="T:System.Windows.Automation.Peers.AutomationPeer"/> for <see cref="P:Fluent.Ribbon.Menu"/>.
            </summary>
        </member>
        <member name="T:Fluent.Automation.Peers.RibbonBackstageAutomationPeer">
            <summary>
            Automation peer for <see cref="T:Fluent.Backstage"/>.
            </summary>
        </member>
        <member name="M:Fluent.Automation.Peers.RibbonBackstageAutomationPeer.#ctor(Fluent.Backstage)">
            <summary>
            Creates a new instance.
            </summary>
        </member>
        <member name="M:Fluent.Automation.Peers.RibbonBackstageAutomationPeer.GetAutomationControlTypeCore">
            <inheritdoc />
        </member>
        <member name="M:Fluent.Automation.Peers.RibbonBackstageAutomationPeer.GetPattern(System.Windows.Automation.Peers.PatternInterface)">
            <inheritdoc />
        </member>
        <member name="M:Fluent.Automation.Peers.RibbonBackstageAutomationPeer.GetChildrenCore">
            <inheritdoc />
        </member>
        <member name="M:Fluent.Automation.Peers.RibbonBackstageAutomationPeer.System#Windows#Automation#Provider#IExpandCollapseProvider#Collapse">
            <inheritdoc />
        </member>
        <member name="M:Fluent.Automation.Peers.RibbonBackstageAutomationPeer.System#Windows#Automation#Provider#IExpandCollapseProvider#Expand">
            <inheritdoc />
        </member>
        <member name="P:Fluent.Automation.Peers.RibbonBackstageAutomationPeer.System#Windows#Automation#Provider#IExpandCollapseProvider#ExpandCollapseState">
            <inheritdoc />
        </member>
        <member name="T:Fluent.Automation.Peers.RibbonBackstageTabControlAutomationPeer">
            <summary>
                Automation peer for <see cref="T:Fluent.BackstageTabControl" />.
            </summary>
        </member>
        <member name="M:Fluent.Automation.Peers.RibbonBackstageTabControlAutomationPeer.#ctor(Fluent.BackstageTabControl)">
            <summary>
                Creates a new instance.
            </summary>
        </member>
        <member name="M:Fluent.Automation.Peers.RibbonBackstageTabControlAutomationPeer.GetAutomationControlTypeCore">
            <inheritdoc />
        </member>
        <member name="M:Fluent.Automation.Peers.RibbonBackstageTabControlAutomationPeer.CreateItemAutomationPeer(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:Fluent.Automation.Peers.RibbonBackstageTabControlAutomationPeer.GetChildrenCore">
            <inheritdoc />
        </member>
        <member name="T:Fluent.Automation.Peers.RibbonBackstageTabItemAutomationPeer">
            <summary>
            Automation peer for <see cref="T:Fluent.BackstageTabItem"/>.
            </summary>
        </member>
        <member name="M:Fluent.Automation.Peers.RibbonBackstageTabItemAutomationPeer.#ctor(Fluent.BackstageTabItem)">
            <summary>
            Creates a new instance.
            </summary>
        </member>
        <member name="M:Fluent.Automation.Peers.RibbonBackstageTabItemAutomationPeer.GetAutomationControlTypeCore">
            <inheritdoc />
        </member>
        <member name="M:Fluent.Automation.Peers.RibbonBackstageTabItemAutomationPeer.GetClassNameCore">
            <inheritdoc />
        </member>
        <member name="M:Fluent.Automation.Peers.RibbonBackstageTabItemAutomationPeer.GetNameCore">
            <inheritdoc />
        </member>
        <member name="M:Fluent.Automation.Peers.RibbonBackstageTabItemAutomationPeer.GetChildrenCore">
            <inheritdoc />
        </member>
        <member name="T:Fluent.Automation.Peers.RibbonButtonAutomationPeer">
            <inheritdoc />
        </member>
        <member name="M:Fluent.Automation.Peers.RibbonButtonAutomationPeer.#ctor(Fluent.Button)">
            <summary>Initializes a new instance of the <see cref="T:ButtonAutomationPeer" /> class.</summary>
            <param name="owner">The element associated with this automation peer.</param>
        </member>
        <member name="M:Fluent.Automation.Peers.RibbonButtonAutomationPeer.GetClassNameCore">
            <inheritdoc />
        </member>
        <member name="M:Fluent.Automation.Peers.RibbonButtonAutomationPeer.GetNameCore">
            <inheritdoc />
        </member>
        <member name="M:Fluent.Automation.Peers.RibbonButtonAutomationPeer.GetAccessKeyCore">
            <inheritdoc />
        </member>
        <member name="M:Fluent.Automation.Peers.RibbonButtonAutomationPeer.GetHelpTextCore">
            <inheritdoc />
        </member>
        <member name="T:Fluent.Automation.Peers.RibbonCheckBoxAutomationPeer">
            <inheritdoc />
        </member>
        <member name="M:Fluent.Automation.Peers.RibbonCheckBoxAutomationPeer.#ctor(Fluent.CheckBox)">
            <summary>Initializes a new instance of the <see cref="T:ToggleButtonAutomationPeer" /> class.</summary>
            <param name="owner">The element associated with this automation peer.</param>
        </member>
        <member name="M:Fluent.Automation.Peers.RibbonCheckBoxAutomationPeer.GetNameCore">
            <inheritdoc />
        </member>
        <member name="T:Fluent.Automation.Peers.RibbonComboBoxAutomationPeer">
            <inheritdoc />
        </member>
        <member name="M:Fluent.Automation.Peers.RibbonComboBoxAutomationPeer.#ctor(Fluent.ComboBox)">
            <summary>Initializes a new instance of the <see cref="T:ComboBoxAutomationPeer" /> class.</summary>
            <param name="owner">The element associated with this automation peer.</param>
        </member>
        <member name="M:Fluent.Automation.Peers.RibbonComboBoxAutomationPeer.GetClassNameCore">
            <inheritdoc />
        </member>
        <member name="M:Fluent.Automation.Peers.RibbonComboBoxAutomationPeer.GetNameCore">
            <inheritdoc />
        </member>
        <member name="T:Fluent.Automation.Peers.RibbonControlAutomationPeer">
            <summary>
            Automation peer for <see cref="T:Fluent.RibbonControl" />.
            </summary>
        </member>
        <member name="M:Fluent.Automation.Peers.RibbonControlAutomationPeer.#ctor(Fluent.RibbonControl)">
            <summary>
            Creates a new instance.
            </summary>
        </member>
        <member name="M:Fluent.Automation.Peers.RibbonControlAutomationPeer.GetClassNameCore">
            <inheritdoc />
        </member>
        <member name="T:Fluent.Automation.Peers.RibbonControlDataAutomationPeer">
            <summary>
            Automation peer for ribbon control items.
            </summary>
        </member>
        <member name="M:Fluent.Automation.Peers.RibbonControlDataAutomationPeer.#ctor(System.Object,System.Windows.Automation.Peers.ItemsControlAutomationPeer)">
            <summary>
            Creates a new instance.
            </summary>
        </member>
        <member name="M:Fluent.Automation.Peers.RibbonControlDataAutomationPeer.GetAutomationControlTypeCore">
            <inheritdoc />
        </member>
        <member name="M:Fluent.Automation.Peers.RibbonControlDataAutomationPeer.GetClassNameCore">
            <inheritdoc />
        </member>
        <member name="M:Fluent.Automation.Peers.RibbonControlDataAutomationPeer.GetPattern(System.Windows.Automation.Peers.PatternInterface)">
            <inheritdoc />
        </member>
        <member name="T:Fluent.Automation.Peers.RibbonDropDownButtonAutomationPeer">
            <summary>
            Automation peer for <see cref="T:Fluent.DropDownButton"/>.
            </summary>
        </member>
        <member name="M:Fluent.Automation.Peers.RibbonDropDownButtonAutomationPeer.#ctor(Fluent.DropDownButton)">
            <summary>
            Creates a new instance.
            </summary>
        </member>
        <member name="M:Fluent.Automation.Peers.RibbonDropDownButtonAutomationPeer.GetClassNameCore">
            <inheritdoc />
        </member>
        <member name="M:Fluent.Automation.Peers.RibbonDropDownButtonAutomationPeer.GetAutomationControlTypeCore">
            <inheritdoc />
        </member>
        <member name="M:Fluent.Automation.Peers.RibbonDropDownButtonAutomationPeer.GetLocalizedControlTypeCore">
            <inheritdoc />
        </member>
        <member name="M:Fluent.Automation.Peers.RibbonDropDownButtonAutomationPeer.GetPattern(System.Windows.Automation.Peers.PatternInterface)">
            <inheritdoc />
        </member>
        <member name="M:Fluent.Automation.Peers.RibbonDropDownButtonAutomationPeer.System#Windows#Automation#Provider#IExpandCollapseProvider#Collapse">
            <inheritdoc />
        </member>
        <member name="M:Fluent.Automation.Peers.RibbonDropDownButtonAutomationPeer.System#Windows#Automation#Provider#IExpandCollapseProvider#Expand">
            <inheritdoc />
        </member>
        <member name="P:Fluent.Automation.Peers.RibbonDropDownButtonAutomationPeer.System#Windows#Automation#Provider#IExpandCollapseProvider#ExpandCollapseState">
            <inheritdoc />
        </member>
        <member name="T:Fluent.Automation.Peers.RibbonGroupBoxAutomationPeer">
            <summary>
            Automation peer for <see cref="T:Fluent.RibbonGroupBox"/>.
            </summary>
        </member>
        <member name="M:Fluent.Automation.Peers.RibbonGroupBoxAutomationPeer.#ctor(Fluent.RibbonGroupBox)">
            <summary>
            Creates a new instance.
            </summary>
        </member>
        <member name="M:Fluent.Automation.Peers.RibbonGroupBoxAutomationPeer.GetChildrenCore">
            <inheritdoc />
        </member>
        <member name="M:Fluent.Automation.Peers.RibbonGroupBoxAutomationPeer.GetClassNameCore">
            <inheritdoc />
        </member>
        <member name="M:Fluent.Automation.Peers.RibbonGroupBoxAutomationPeer.GetNameCore">
            <inheritdoc />
        </member>
        <member name="M:Fluent.Automation.Peers.RibbonGroupBoxAutomationPeer.GetPattern(System.Windows.Automation.Peers.PatternInterface)">
            <inheritdoc />
        </member>
        <member name="M:Fluent.Automation.Peers.RibbonGroupBoxAutomationPeer.SetFocusCore">
            <inheritdoc />
        </member>
        <member name="M:Fluent.Automation.Peers.RibbonGroupBoxAutomationPeer.GetAutomationControlTypeCore">
            <inheritdoc />
        </member>
        <member name="M:Fluent.Automation.Peers.RibbonGroupBoxAutomationPeer.System#Windows#Automation#Provider#IExpandCollapseProvider#Expand">
            <inheritdoc />
        </member>
        <member name="M:Fluent.Automation.Peers.RibbonGroupBoxAutomationPeer.System#Windows#Automation#Provider#IExpandCollapseProvider#Collapse">
            <inheritdoc />
        </member>
        <member name="P:Fluent.Automation.Peers.RibbonGroupBoxAutomationPeer.System#Windows#Automation#Provider#IExpandCollapseProvider#ExpandCollapseState">
            <inheritdoc />
        </member>
        <member name="M:Fluent.Automation.Peers.RibbonGroupBoxAutomationPeer.System#Windows#Automation#Provider#IScrollItemProvider#ScrollIntoView">
            <inheritdoc />
        </member>
        <member name="T:Fluent.Automation.Peers.RibbonGroupHeaderAutomationPeer">
            <summary>
            Automation peer for the header of <see cref="T:Fluent.RibbonGroupBox"/>.
            </summary>
        </member>
        <member name="M:Fluent.Automation.Peers.RibbonGroupHeaderAutomationPeer.#ctor(System.Windows.FrameworkElement)">
            <summary>
            Creates a new instance.
            </summary>
        </member>
        <member name="M:Fluent.Automation.Peers.RibbonGroupHeaderAutomationPeer.GetAutomationControlTypeCore">
            <inheritdoc />
        </member>
        <member name="M:Fluent.Automation.Peers.RibbonGroupHeaderAutomationPeer.IsContentElementCore">
            <inheritdoc />
        </member>
        <member name="M:Fluent.Automation.Peers.RibbonGroupHeaderAutomationPeer.GetClassNameCore">
            <inheritdoc />
        </member>
        <member name="M:Fluent.Automation.Peers.RibbonGroupHeaderAutomationPeer.GetNameCore">
            <inheritdoc />
        </member>
        <member name="T:Fluent.Automation.Peers.RibbonHeaderedControlAutomationPeer">
            <summary>
            Base automation peer for <see cref="T:Fluent.IHeaderedControl"/>.
            </summary>
        </member>
        <member name="M:Fluent.Automation.Peers.RibbonHeaderedControlAutomationPeer.#ctor(System.Windows.FrameworkElement)">
            <summary>
            Creates a new instance.
            </summary>
        </member>
        <member name="M:Fluent.Automation.Peers.RibbonHeaderedControlAutomationPeer.GetClassNameCore">
            <inheritdoc />
        </member>
        <member name="M:Fluent.Automation.Peers.RibbonHeaderedControlAutomationPeer.GetNameCore">
            <inheritdoc />
        </member>
        <member name="T:Fluent.Automation.Peers.RibbonInRibbonGalleryAutomationPeer">
            <summary>
                Automation peer for <see cref="T:Fluent.InRibbonGallery" />
            </summary>
        </member>
        <member name="M:Fluent.Automation.Peers.RibbonInRibbonGalleryAutomationPeer.#ctor(Fluent.InRibbonGallery)">
            <summary>
                Creates a new instance.
            </summary>
        </member>
        <member name="M:Fluent.Automation.Peers.RibbonInRibbonGalleryAutomationPeer.GetClassNameCore">
            <inheritdoc />
        </member>
        <member name="M:Fluent.Automation.Peers.RibbonInRibbonGalleryAutomationPeer.GetNameCore">
            <inheritdoc />
        </member>
        <member name="M:Fluent.Automation.Peers.RibbonInRibbonGalleryAutomationPeer.GetAutomationControlTypeCore">
            <inheritdoc />
        </member>
        <member name="M:Fluent.Automation.Peers.RibbonInRibbonGalleryAutomationPeer.CreateItemAutomationPeer(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:Fluent.Automation.Peers.RibbonInRibbonGalleryAutomationPeer.GetPattern(System.Windows.Automation.Peers.PatternInterface)">
            <inheritdoc />
        </member>
        <member name="M:Fluent.Automation.Peers.RibbonInRibbonGalleryAutomationPeer.Collapse">
            <inheritdoc />
        </member>
        <member name="M:Fluent.Automation.Peers.RibbonInRibbonGalleryAutomationPeer.Expand">
            <inheritdoc />
        </member>
        <member name="P:Fluent.Automation.Peers.RibbonInRibbonGalleryAutomationPeer.ExpandCollapseState">
            <inheritdoc />
        </member>
        <member name="T:Fluent.Automation.Peers.RibbonQuickAccessToolBarAutomationPeer">
            <summary>
            Automation peer for <see cref="T:Fluent.QuickAccessToolBar"/>.
            </summary>
        </member>
        <member name="M:Fluent.Automation.Peers.RibbonQuickAccessToolBarAutomationPeer.#ctor(Fluent.QuickAccessToolBar)">
            <summary>
            Creates a new instance.
            </summary>
        </member>
        <member name="M:Fluent.Automation.Peers.RibbonQuickAccessToolBarAutomationPeer.GetAutomationControlTypeCore">
            <inheritdoc />
        </member>
        <member name="M:Fluent.Automation.Peers.RibbonQuickAccessToolBarAutomationPeer.GetClassNameCore">
            <inheritdoc />
        </member>
        <member name="M:Fluent.Automation.Peers.RibbonQuickAccessToolBarAutomationPeer.GetChildrenCore">
            <inheritdoc />
        </member>
        <member name="T:Fluent.Automation.Peers.RibbonRadioButtonAutomationPeer">
            <inheritdoc />
        </member>
        <member name="M:Fluent.Automation.Peers.RibbonRadioButtonAutomationPeer.#ctor(Fluent.RadioButton)">
            <summary>Initializes a new instance of the <see cref="T:RadioButtonAutomationPeer" /> class.</summary>
            <param name="owner">The element associated with this automation peer.</param>
        </member>
        <member name="M:Fluent.Automation.Peers.RibbonRadioButtonAutomationPeer.GetClassNameCore">
            <inheritdoc />
        </member>
        <member name="M:Fluent.Automation.Peers.RibbonRadioButtonAutomationPeer.GetNameCore">
            <inheritdoc />
        </member>
        <member name="T:Fluent.Automation.Peers.RibbonScreenTipAutomationPeer">
            <summary>
                Automation peer for <see cref="T:Fluent.ScreenTip" />.
            </summary>
        </member>
        <member name="M:Fluent.Automation.Peers.RibbonScreenTipAutomationPeer.#ctor(Fluent.ScreenTip)">
            <summary>
                Creates a new instance.
            </summary>
        </member>
        <member name="M:Fluent.Automation.Peers.RibbonScreenTipAutomationPeer.GetClassNameCore">
            <inheritdoc />
        </member>
        <member name="M:Fluent.Automation.Peers.RibbonScreenTipAutomationPeer.GetNameCore">
            <inheritdoc />
        </member>
        <member name="T:Fluent.Automation.Peers.RibbonSplitButtonAutomationPeer">
            <summary>
            Automation peer for <see cref="T:Fluent.SplitButton"/>.
            </summary>
        </member>
        <member name="M:Fluent.Automation.Peers.RibbonSplitButtonAutomationPeer.#ctor(Fluent.SplitButton)">
            <summary>
            Creates a new instance.
            </summary>
        </member>
        <member name="M:Fluent.Automation.Peers.RibbonSplitButtonAutomationPeer.GetClassNameCore">
            <inheritdoc />
        </member>
        <member name="M:Fluent.Automation.Peers.RibbonSplitButtonAutomationPeer.GetAutomationControlTypeCore">
            <inheritdoc />
        </member>
        <member name="M:Fluent.Automation.Peers.RibbonSplitButtonAutomationPeer.GetPattern(System.Windows.Automation.Peers.PatternInterface)">
            <inheritdoc />
        </member>
        <member name="M:Fluent.Automation.Peers.RibbonSplitButtonAutomationPeer.GetAutomationIdCore">
            <inheritdoc />
        </member>
        <member name="M:Fluent.Automation.Peers.RibbonSplitButtonAutomationPeer.GetNameCore">
            <inheritdoc />
        </member>
        <member name="M:Fluent.Automation.Peers.RibbonSplitButtonAutomationPeer.Invoke">
            <inheritdoc />
        </member>
        <member name="T:Fluent.Automation.Peers.RibbonTabControlAutomationPeer">
            <summary>
            Automation peer for <see cref="T:Fluent.RibbonTabControl"/>.
            </summary>
        </member>
        <member name="M:Fluent.Automation.Peers.RibbonTabControlAutomationPeer.#ctor(Fluent.RibbonTabControl)">
            <summary>
            Creates a new instance.
            </summary>
        </member>
        <member name="M:Fluent.Automation.Peers.RibbonTabControlAutomationPeer.CreateItemAutomationPeer(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:Fluent.Automation.Peers.RibbonTabControlAutomationPeer.GetClassNameCore">
            <inheritdoc />
        </member>
        <member name="M:Fluent.Automation.Peers.RibbonTabControlAutomationPeer.GetClickablePointCore">
            <inheritdoc />
        </member>
        <member name="M:Fluent.Automation.Peers.RibbonTabControlAutomationPeer.GetPattern(System.Windows.Automation.Peers.PatternInterface)">
            <inheritdoc />
        </member>
        <member name="M:Fluent.Automation.Peers.RibbonTabControlAutomationPeer.GetChildrenCore">
            <inheritdoc />
        </member>
        <member name="T:Fluent.Automation.Peers.RibbonTabItemAutomationPeer">
            <summary>
            Automation peer wrapper for <see cref="T:Fluent.RibbonTabItem"/>.
            </summary>
        </member>
        <member name="M:Fluent.Automation.Peers.RibbonTabItemAutomationPeer.#ctor(Fluent.RibbonTabItem)">
            <summary>
            Creates a new instance.
            </summary>
        </member>
        <member name="M:Fluent.Automation.Peers.RibbonTabItemAutomationPeer.GetPattern(System.Windows.Automation.Peers.PatternInterface)">
            <inheritdoc />
        </member>
        <member name="M:Fluent.Automation.Peers.RibbonTabItemAutomationPeer.GetChildrenCore">
            <inheritdoc />
        </member>
        <member name="M:Fluent.Automation.Peers.RibbonTabItemAutomationPeer.GetClassNameCore">
            <inheritdoc />
        </member>
        <member name="M:Fluent.Automation.Peers.RibbonTabItemAutomationPeer.GetAccessKeyCore">
            <inheritdoc />
        </member>
        <member name="T:Fluent.Automation.Peers.RibbonTabItemDataAutomationPeer">
            <summary>
            Automation peer for <see cref="T:Fluent.RibbonTabItem"/>.
            </summary>
        </member>
        <member name="M:Fluent.Automation.Peers.RibbonTabItemDataAutomationPeer.#ctor(System.Object,Fluent.Automation.Peers.RibbonTabControlAutomationPeer)">
            <summary>
            Creates a new instance.
            </summary>
        </member>
        <member name="M:Fluent.Automation.Peers.RibbonTabItemDataAutomationPeer.GetClassNameCore">
            <inheritdoc />
        </member>
        <member name="M:Fluent.Automation.Peers.RibbonTabItemDataAutomationPeer.GetNameCore">
            <inheritdoc />
        </member>
        <member name="M:Fluent.Automation.Peers.RibbonTabItemDataAutomationPeer.GetAccessKeyCore">
            <inheritdoc />
        </member>
        <member name="M:Fluent.Automation.Peers.RibbonTabItemDataAutomationPeer.GetAutomationControlTypeCore">
            <inheritdoc />
        </member>
        <member name="M:Fluent.Automation.Peers.RibbonTabItemDataAutomationPeer.System#Windows#Automation#Provider#IExpandCollapseProvider#Collapse">
            <summary>
            If Ribbon.IsMinimized then set Ribbon.IsDropDownOpen to false
            </summary>
        </member>
        <member name="M:Fluent.Automation.Peers.RibbonTabItemDataAutomationPeer.System#Windows#Automation#Provider#IExpandCollapseProvider#Expand">
            <summary>
            If Ribbon.IsMinimized then set Ribbon.IsDropDownOpen to true
            </summary>
        </member>
        <member name="P:Fluent.Automation.Peers.RibbonTabItemDataAutomationPeer.System#Windows#Automation#Provider#IExpandCollapseProvider#ExpandCollapseState">
            <summary>
            Return Ribbon.IsDropDownOpen
            </summary>
        </member>
        <member name="T:Fluent.Automation.Peers.RibbonTextBoxAutomationPeer">
            <inheritdoc />
        </member>
        <member name="M:Fluent.Automation.Peers.RibbonTextBoxAutomationPeer.#ctor(Fluent.TextBox)">
            <summary>Initializes a new instance of the <see cref="T:TextBoxAutomationPeer" /> class.</summary>
            <param name="owner">The element associated with this automation peer.</param>
        </member>
        <member name="M:Fluent.Automation.Peers.RibbonTextBoxAutomationPeer.GetClassNameCore">
            <inheritdoc />
        </member>
        <member name="M:Fluent.Automation.Peers.RibbonTextBoxAutomationPeer.GetNameCore">
            <inheritdoc />
        </member>
        <member name="T:Fluent.Automation.Peers.RibbonTitleBarAutomationPeer">
            <summary>
            Automation peer for <see cref="T:Fluent.RibbonTitleBar"/>.
            </summary>
        </member>
        <member name="M:Fluent.Automation.Peers.RibbonTitleBarAutomationPeer.#ctor(Fluent.RibbonTitleBar)">
            <summary>
            Creates a new instance.
            </summary>
        </member>
        <member name="M:Fluent.Automation.Peers.RibbonTitleBarAutomationPeer.GetAutomationControlTypeCore">
            <inheritdoc />
        </member>
        <member name="M:Fluent.Automation.Peers.RibbonTitleBarAutomationPeer.IsContentElementCore">
            <inheritdoc />
        </member>
        <member name="M:Fluent.Automation.Peers.RibbonTitleBarAutomationPeer.GetClassNameCore">
            <inheritdoc />
        </member>
        <member name="M:Fluent.Automation.Peers.RibbonTitleBarAutomationPeer.GetNameCore">
            <inheritdoc />
        </member>
        <member name="T:Fluent.Automation.Peers.RibbonToggleButtonAutomationPeer">
            <inheritdoc />
        </member>
        <member name="M:Fluent.Automation.Peers.RibbonToggleButtonAutomationPeer.#ctor(Fluent.ToggleButton)">
            <summary>Initializes a new instance of the <see cref="T:ToggleButtonAutomationPeer" /> class.</summary>
            <param name="owner">The element associated with this automation peer.</param>
        </member>
        <member name="M:Fluent.Automation.Peers.RibbonToggleButtonAutomationPeer.GetClassNameCore">
            <inheritdoc />
        </member>
        <member name="M:Fluent.Automation.Peers.RibbonToggleButtonAutomationPeer.GetNameCore">
            <inheritdoc />
        </member>
        <member name="T:Fluent.Automation.Peers.TwoLineLabelAutomationPeer">
            <summary>
            <see cref="T:System.Windows.Automation.Peers.AutomationPeer"/> for <see cref="T:Fluent.TwoLineLabel"/>.
            </summary>
        </member>
        <member name="M:Fluent.Automation.Peers.TwoLineLabelAutomationPeer.#ctor(Fluent.TwoLineLabel)">
            <summary>
            Constructor.
            </summary>
            <param name="owner">Owner of the AutomationPeer.</param>
        </member>
        <member name="M:Fluent.Automation.Peers.TwoLineLabelAutomationPeer.GetChildrenCore">
            <summary>
            <see cref="M:System.Windows.Automation.Peers.AutomationPeer.GetChildrenCore"/>
            </summary>
        </member>
        <member name="M:Fluent.Automation.Peers.TwoLineLabelAutomationPeer.GetAutomationControlTypeCore">
            <summary>
            <see cref="M:System.Windows.Automation.Peers.AutomationPeer.GetAutomationControlTypeCore"/>
            </summary>
        </member>
        <member name="M:Fluent.Automation.Peers.TwoLineLabelAutomationPeer.GetClassNameCore">
            <summary>
            <see cref="M:System.Windows.Automation.Peers.AutomationPeer.GetClassNameCore"/>
            </summary>
            <returns></returns>
        </member>
        <member name="M:Fluent.Automation.Peers.TwoLineLabelAutomationPeer.GetNameCore">
            <inheritdoc />
        </member>
        <member name="M:Fluent.Automation.Peers.TwoLineLabelAutomationPeer.IsControlElementCore">
            <summary>
            <see cref="M:System.Windows.Automation.Peers.AutomationPeer.IsControlElementCore"/>
            </summary>
        </member>
        <member name="T:Fluent.Collections.CollectionSyncHelper`1">
            <summary>
            Synchronizes a target collection with a source collection in a one way fashion.
            </summary>
        </member>
        <member name="M:Fluent.Collections.CollectionSyncHelper`1.#ctor(System.Collections.ObjectModel.ObservableCollection{`0},System.Collections.IList)">
            <summary>
            Creates a new instance with <paramref name="source"/> as <see cref="P:Fluent.Collections.CollectionSyncHelper`1.Source"/> and <paramref name="target"/> as <see cref="P:Fluent.Collections.CollectionSyncHelper`1.Target"/>.
            </summary>
        </member>
        <member name="P:Fluent.Collections.CollectionSyncHelper`1.Source">
            <summary>
            The source collection.
            </summary>
        </member>
        <member name="P:Fluent.Collections.CollectionSyncHelper`1.Target">
            <summary>
            The target collection.
            </summary>
        </member>
        <member name="M:Fluent.Collections.CollectionSyncHelper`1.SyncTarget">
            <summary>
            Clears <see cref="P:Fluent.Collections.CollectionSyncHelper`1.Target"/> and then copies all items from <see cref="P:Fluent.Collections.CollectionSyncHelper`1.Source"/> to <see cref="P:Fluent.Collections.CollectionSyncHelper`1.Target"/>.
            </summary>
        </member>
        <member name="T:Fluent.Collections.ItemCollectionWithLogicalTreeSupport`1">
            <summary>
            Special collection with support for logical children of a parent object.
            </summary>
            <typeparam name="TItem">The type for items.</typeparam>
        </member>
        <member name="M:Fluent.Collections.ItemCollectionWithLogicalTreeSupport`1.#ctor(Fluent.ILogicalChildSupport)">
            <summary>
            Creates a new instance.
            </summary>
            <param name="parent">The parent which supports logical children.</param>
        </member>
        <member name="P:Fluent.Collections.ItemCollectionWithLogicalTreeSupport`1.IsOwningItems">
            <summary>
            Gets whether this collections parent has logical ownership of the items.
            </summary>
        </member>
        <member name="P:Fluent.Collections.ItemCollectionWithLogicalTreeSupport`1.Parent">
            <summary>
            The parent object which support logical children.
            </summary>
        </member>
        <member name="M:Fluent.Collections.ItemCollectionWithLogicalTreeSupport`1.AquireLogicalOwnership">
            <summary>
            Adds all items to the logical tree of <see cref="P:Fluent.Collections.ItemCollectionWithLogicalTreeSupport`1.Parent"/>.
            </summary>
        </member>
        <member name="M:Fluent.Collections.ItemCollectionWithLogicalTreeSupport`1.ReleaseLogicalOwnership">
            <summary>
            Removes all items from the logical tree of <see cref="P:Fluent.Collections.ItemCollectionWithLogicalTreeSupport`1.Parent"/>.
            </summary>
        </member>
        <member name="M:Fluent.Collections.ItemCollectionWithLogicalTreeSupport`1.GetLogicalChildren">
            <summary>
            Gets all items where the logical parent is <see cref="P:Fluent.Collections.ItemCollectionWithLogicalTreeSupport`1.Parent"/>.
            </summary>
        </member>
        <member name="M:Fluent.Collections.ItemCollectionWithLogicalTreeSupport`1.InsertItem(System.Int32,`0)">
            <inheritdoc />
        </member>
        <member name="M:Fluent.Collections.ItemCollectionWithLogicalTreeSupport`1.RemoveItem(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Fluent.Collections.ItemCollectionWithLogicalTreeSupport`1.SetItem(System.Int32,`0)">
            <inheritdoc />
        </member>
        <member name="M:Fluent.Collections.ItemCollectionWithLogicalTreeSupport`1.ClearItems">
            <inheritdoc />
        </member>
        <member name="T:Fluent.ApplicationMenu">
            <summary>
            Represents backstage button
            </summary>
        </member>
        <member name="P:Fluent.ApplicationMenu.RightPaneWidth">
            <summary>
            Gets or sets width of right content
            </summary>
        </member>
        <member name="F:Fluent.ApplicationMenu.RightPaneWidthProperty">
            <summary>Identifies the <see cref="P:Fluent.ApplicationMenu.RightPaneWidth"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.ApplicationMenu.RightPaneContent">
            <summary>
            Gets or sets application menu right pane content
            </summary>
        </member>
        <member name="F:Fluent.ApplicationMenu.RightPaneContentProperty">
            <summary>Identifies the <see cref="P:Fluent.ApplicationMenu.RightPaneContent"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.ApplicationMenu.FooterPaneContent">
            <summary>
            Gets or sets application menu bottom pane content
            </summary>
        </member>
        <member name="F:Fluent.ApplicationMenu.FooterPaneContentProperty">
            <summary>Identifies the <see cref="P:Fluent.ApplicationMenu.FooterPaneContent"/> dependency property.</summary>
        </member>
        <member name="M:Fluent.ApplicationMenu.#cctor">
            <summary>
            Static constructor
            </summary>
        </member>
        <member name="M:Fluent.ApplicationMenu.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:Fluent.ApplicationMenu.OnContextMenuOpening(System.Windows.Controls.ContextMenuEventArgs)">
            <inheritdoc />
        </member>
        <member name="M:Fluent.ApplicationMenu.CreateQuickAccessItem">
            <inheritdoc />
        </member>
        <member name="P:Fluent.ApplicationMenu.LogicalChildren">
            <inheritdoc />
        </member>
        <member name="T:Fluent.Backstage">
            <summary>
            Represents backstage button
            </summary>
        </member>
        <member name="E:Fluent.Backstage.IsOpenChanged">
            <summary>
            Occurs when IsOpen has been changed
            </summary>
        </member>
        <member name="P:Fluent.Backstage.AdornerLayer">
            <summary>
            Gets the <see cref="P:Fluent.Backstage.AdornerLayer"/> for the <see cref="T:Fluent.Backstage"/>.
            </summary>
            <remarks>This is exposed to make it possible to show content on the same <see cref="P:Fluent.Backstage.AdornerLayer"/> as the backstage is shown on.</remarks>
        </member>
        <member name="P:Fluent.Backstage.IsOpen">
            <summary>
            Gets or sets whether backstage is shown
            </summary>
        </member>
        <member name="F:Fluent.Backstage.IsOpenProperty">
            <summary>Identifies the <see cref="P:Fluent.Backstage.IsOpen"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.Backstage.CanChangeIsOpen">
            <summary>
            Gets or sets whether backstage can be openend or closed.
            </summary>
        </member>
        <member name="F:Fluent.Backstage.CanChangeIsOpenProperty">
            <summary>Identifies the <see cref="P:Fluent.Backstage.CanChangeIsOpen"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.Backstage.HideContextTabsOnOpen">
            <summary>
            Gets or sets whether context tabs on the titlebar should be hidden when backstage is open
            </summary>
        </member>
        <member name="F:Fluent.Backstage.HideContextTabsOnOpenProperty">
            <summary>Identifies the <see cref="P:Fluent.Backstage.HideContextTabsOnOpen"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.Backstage.AreAnimationsEnabled">
            <summary>
            Gets or sets whether opening or closing should be animated.
            </summary>
        </member>
        <member name="F:Fluent.Backstage.AreAnimationsEnabledProperty">
            <summary>Identifies the <see cref="P:Fluent.Backstage.AreAnimationsEnabled"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.Backstage.CloseOnEsc">
            <summary>
            Gets or sets whether to close the backstage when Esc is pressed
            </summary>
        </member>
        <member name="F:Fluent.Backstage.CloseOnEscProperty">
            <summary>Identifies the <see cref="P:Fluent.Backstage.CloseOnEsc"/> dependency property.</summary>
        </member>
        <member name="F:Fluent.Backstage.UseHighestAvailableAdornerLayerProperty">
            <summary>Identifies the <see cref="P:Fluent.Backstage.UseHighestAvailableAdornerLayer"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.Backstage.UseHighestAvailableAdornerLayer">
            <summary>
            Gets or sets whether the highest available adorner layer should be used for the <see cref="T:Fluent.BackstageAdorner"/>.
            This means that we will try to look up the visual tree till we find the highest <see cref="T:System.Windows.Documents.AdornerDecorator"/>.
            </summary>
        </member>
        <member name="P:Fluent.Backstage.Content">
            <summary>
            Gets or sets content of the backstage
            </summary>
        </member>
        <member name="F:Fluent.Backstage.ContentProperty">
            <summary>Identifies the <see cref="P:Fluent.Backstage.Content"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.Backstage.LogicalChildren">
            <inheritdoc />
        </member>
        <member name="M:Fluent.Backstage.#cctor">
            <summary>
            Static constructor
            </summary>
        </member>
        <member name="M:Fluent.Backstage.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:Fluent.Backstage.OnDismissPopup(System.Object,Fluent.DismissPopupEventArgs)">
            <summary>
            Called when this control receives the <see cref="F:Fluent.PopupService.DismissPopupEvent"/>.
            </summary>
        </member>
        <member name="M:Fluent.Backstage.Show">
            <summary>
            Shows the <see cref="T:Fluent.Backstage"/>
            </summary>
            <returns>
            <c>true</c> if the <see cref="T:Fluent.Backstage"/> was made visible.
            <c>false</c> if the <see cref="T:Fluent.Backstage"/> was not made visible.
            </returns>
        </member>
        <member name="M:Fluent.Backstage.Hide">
            <summary>
            Hides the <see cref="T:Fluent.Backstage"/>
            </summary>
        </member>
        <member name="M:Fluent.Backstage.OnKeyDown(System.Windows.Input.KeyEventArgs)">
            <inheritdoc />
        </member>
        <member name="M:Fluent.Backstage.OnMouseLeftButtonDown(System.Windows.Input.MouseButtonEventArgs)">
            <inheritdoc />
        </member>
        <member name="M:Fluent.Backstage.OnKeyTipPressed">
            <inheritdoc />
        </member>
        <member name="M:Fluent.Backstage.OnKeyTipBack">
            <inheritdoc />
        </member>
        <member name="M:Fluent.Backstage.OnApplyTemplate">
            <inheritdoc />
        </member>
        <member name="M:Fluent.Backstage.CreateQuickAccessItem">
            <inheritdoc />
        </member>
        <member name="M:Fluent.Backstage.OnCreateAutomationPeer">
            <inheritdoc />
        </member>
        <member name="T:Fluent.BackstageAdorner">
            <summary>
            Represents adorner for Backstage
            </summary>
        </member>
        <member name="M:Fluent.BackstageAdorner.#ctor(System.Windows.FrameworkElement,Fluent.Backstage)">
            <summary>
            Initializes a new instance of the <see cref="T:Fluent.BackstageAdorner"/> class.
            </summary>
            <param name="adornedElement">Adorned element</param>
            <param name="backstage">Backstage</param>
        </member>
        <member name="P:Fluent.BackstageAdorner.Backstage">
            <summary>
            Gets the <see cref="T:Fluent.Backstage"/>.
            </summary>
        </member>
        <member name="M:Fluent.BackstageAdorner.ArrangeOverride(System.Windows.Size)">
            <inheritdoc />
        </member>
        <member name="M:Fluent.BackstageAdorner.MeasureOverride(System.Windows.Size)">
            <inheritdoc />
        </member>
        <member name="P:Fluent.BackstageAdorner.VisualChildrenCount">
            <inheritdoc />
        </member>
        <member name="M:Fluent.BackstageAdorner.GetVisualChild(System.Int32)">
            <inheritdoc />
        </member>
        <member name="T:Fluent.BackstageTabControl">
            <summary>
            Represents Backstage tab control.
            </summary>
        </member>
        <member name="F:Fluent.BackstageTabControl.BackButtonUidProperty">
            <summary>Identifies the <see cref="P:Fluent.BackstageTabControl.BackButtonUid"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.BackstageTabControl.BackButtonUid">
            <summary>
            Gets or sets the Uid of the back button.
            </summary>
        </member>
        <member name="F:Fluent.BackstageTabControl.SelectedContentProperty">
            <summary>Identifies the <see cref="P:Fluent.BackstageTabControl.SelectedContent"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.BackstageTabControl.SelectedContent">
            <summary>
            Gets content for selected tab
            </summary>
        </member>
        <member name="F:Fluent.BackstageTabControl.ContentStringFormatProperty">
            <summary>Identifies the <see cref="P:Fluent.BackstageTabControl.ContentStringFormat"/> dependency property.</summary>
        </member>
        <member name="F:Fluent.BackstageTabControl.ContentTemplateProperty">
            <summary>Identifies the <see cref="P:Fluent.BackstageTabControl.ContentTemplate"/> dependency property.</summary>
        </member>
        <member name="F:Fluent.BackstageTabControl.ContentTemplateSelectorProperty">
            <summary>Identifies the <see cref="P:Fluent.BackstageTabControl.ContentTemplateSelector"/> dependency property.</summary>
        </member>
        <member name="F:Fluent.BackstageTabControl.SelectedContentStringFormatProperty">
            <summary>Identifies the <see cref="P:Fluent.BackstageTabControl.SelectedContentStringFormat"/> dependency property.</summary>
        </member>
        <member name="F:Fluent.BackstageTabControl.SelectedContentTemplateProperty">
            <summary>Identifies the <see cref="P:Fluent.BackstageTabControl.SelectedContentTemplate"/> dependency property.</summary>
        </member>
        <member name="F:Fluent.BackstageTabControl.SelectedContentTemplateSelectorProperty">
            <summary>Identifies the <see cref="P:Fluent.BackstageTabControl.SelectedContentTemplateSelector"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.BackstageTabControl.ContentStringFormat">
            <summary>
            Get or sets the string format for the content.
            </summary>
        </member>
        <member name="P:Fluent.BackstageTabControl.ContentTemplate">
            <summary>
            Gets or sets the <see cref="T:System.Windows.DataTemplate"/> which should be used for the content
            </summary>
        </member>
        <member name="P:Fluent.BackstageTabControl.ContentTemplateSelector">
            <summary>
            Gets or sets the <see cref="P:Fluent.BackstageTabControl.ContentTemplateSelector"/> which should be used for the content
            </summary>
        </member>
        <member name="P:Fluent.BackstageTabControl.SelectedContentStringFormat">
            <summary>
            Get or sets the string format for the selected content.
            </summary>
        </member>
        <member name="P:Fluent.BackstageTabControl.SelectedContentTemplate">
            <summary>
            Gets or sets the <see cref="T:System.Windows.DataTemplate"/> which should be used for the selected content
            </summary>
        </member>
        <member name="P:Fluent.BackstageTabControl.SelectedContentTemplateSelector">
            <summary>
            Gets or sets the <see cref="P:Fluent.BackstageTabControl.ContentTemplateSelector"/> which should be used for the selected content
            </summary>
        </member>
        <member name="F:Fluent.BackstageTabControl.ItemsPanelMinWidthProperty">
            <summary>Identifies the <see cref="P:Fluent.BackstageTabControl.ItemsPanelMinWidth"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.BackstageTabControl.ItemsPanelMinWidth">
            <summary>
            Gets or sets the MinWidth for the ItemsPanel.
            </summary>
        </member>
        <member name="P:Fluent.BackstageTabControl.ItemsPanelBackground">
            <summary>
            Gets or sets current Backround of the ItemsPanel
            </summary>
        </member>
        <member name="F:Fluent.BackstageTabControl.ItemsPanelBackgroundProperty">
            <summary>Identifies the <see cref="P:Fluent.BackstageTabControl.ItemsPanelBackground"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.BackstageTabControl.ParentBackstage">
            <summary>
            Gets or sets the <see cref="P:Fluent.BackstageTabControl.ParentBackstage"/>
            </summary>
        </member>
        <member name="F:Fluent.BackstageTabControl.ParentBackstageProperty">
            <summary>Identifies the <see cref="P:Fluent.BackstageTabControl.ParentBackstage"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.BackstageTabControl.IsBackButtonVisible">
            <summary>
            Defines if the back button is visible or not.
            </summary>
        </member>
        <member name="F:Fluent.BackstageTabControl.IsBackButtonVisibleProperty">
            <summary>Identifies the <see cref="P:Fluent.BackstageTabControl.IsBackButtonVisible"/> dependency property.</summary>
        </member>
        <member name="M:Fluent.BackstageTabControl.#cctor">
            <summary>
            Static constructor
            </summary>
        </member>
        <member name="M:Fluent.BackstageTabControl.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:Fluent.BackstageTabControl.OnInitialized(System.EventArgs)">
            <inheritdoc />
        </member>
        <member name="M:Fluent.BackstageTabControl.OnApplyTemplate">
            <inheritdoc />
        </member>
        <member name="M:Fluent.BackstageTabControl.GetContainerForItemOverride">
            <inheritdoc />
        </member>
        <member name="M:Fluent.BackstageTabControl.IsItemItsOwnContainerOverride(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:Fluent.BackstageTabControl.PrepareContainerForItemOverride(System.Windows.DependencyObject,System.Object)">
            <inheritdoc />
        </member>
        <member name="M:Fluent.BackstageTabControl.OnItemsChanged(System.Collections.Specialized.NotifyCollectionChangedEventArgs)">
            <inheritdoc />
        </member>
        <member name="M:Fluent.BackstageTabControl.OnSelectionChanged(System.Windows.Controls.SelectionChangedEventArgs)">
            <inheritdoc />
        </member>
        <member name="M:Fluent.BackstageTabControl.OnKeyDown(System.Windows.Input.KeyEventArgs)">
            <inheritdoc />
        </member>
        <member name="M:Fluent.BackstageTabControl.GetSelectedTabItem">
            <summary>
            Gets selected <see cref="T:Fluent.BackstageTabItem"/>.
            If there is no item selected, the first found item is selected and it's container (<see cref="T:Fluent.BackstageTabItem"/>) is returned.
            </summary>
            <returns>The currently selected <see cref="T:Fluent.BackstageTabItem"/>. Or null of nothing was selected and nothing could be selected.</returns>
        </member>
        <member name="M:Fluent.BackstageTabControl.OnCreateAutomationPeer">
            <inheritdoc />
        </member>
        <member name="M:Fluent.BackstageTabControl.Fluent#ILogicalChildSupport#AddLogicalChild(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:Fluent.BackstageTabControl.Fluent#ILogicalChildSupport#RemoveLogicalChild(System.Object)">
            <inheritdoc />
        </member>
        <member name="P:Fluent.BackstageTabControl.LogicalChildren">
            <inheritdoc />
        </member>
        <member name="T:Fluent.BackstageTabItem">
            <summary>
            Represents backstage tab item
            </summary>
        </member>
        <member name="P:Fluent.BackstageTabItem.Icon">
            <summary>
            Gets or sets Icon for the element
            </summary>
        </member>
        <member name="F:Fluent.BackstageTabItem.IconProperty">
            <summary>Identifies the <see cref="P:Fluent.BackstageTabItem.Icon"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.BackstageTabItem.KeyTip">
            <inheritdoc />
        </member>
        <member name="F:Fluent.BackstageTabItem.KeyTipProperty">
            <summary>
            Dependency property for <see cref="P:Fluent.BackstageTabItem.KeyTip"/>
            </summary>
        </member>
        <member name="P:Fluent.BackstageTabItem.IsSelected">
            <summary>
            Gets or sets a value indicating whether the tab is selected
            </summary>
        </member>
        <member name="F:Fluent.BackstageTabItem.IsSelectedProperty">
            <summary>
            Dependency property for <see cref="P:Fluent.BackstageTabItem.IsSelected"/>
            </summary>
        </member>
        <member name="P:Fluent.BackstageTabItem.TabControlParent">
            <summary>
            Gets parent tab control
            </summary>
        </member>
        <member name="P:Fluent.BackstageTabItem.Header">
            <summary>
            Gets or sets tab items text
            </summary>
        </member>
        <member name="F:Fluent.BackstageTabItem.HeaderProperty">
            <summary>Identifies the <see cref="P:Fluent.BackstageTabItem.Header"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.BackstageTabItem.HeaderTemplate">
            <inheritdoc />
        </member>
        <member name="F:Fluent.BackstageTabItem.HeaderTemplateProperty">
            <summary>Identifies the <see cref="P:Fluent.BackstageTabItem.HeaderTemplate"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.BackstageTabItem.HeaderTemplateSelector">
            <inheritdoc />
        </member>
        <member name="F:Fluent.BackstageTabItem.HeaderTemplateSelectorProperty">
            <summary>Identifies the <see cref="P:Fluent.BackstageTabItem.HeaderTemplateSelector"/> dependency property.</summary>
        </member>
        <member name="M:Fluent.BackstageTabItem.#cctor">
            <summary>
            Static constructor
            </summary>
        </member>
        <member name="M:Fluent.BackstageTabItem.OnApplyTemplate">
            <inheritdoc />
        </member>
        <member name="M:Fluent.BackstageTabItem.OnContentChanged(System.Object,System.Object)">
            <inheritdoc />
        </member>
        <member name="M:Fluent.BackstageTabItem.OnMouseLeftButtonDown(System.Windows.Input.MouseButtonEventArgs)">
            <inheritdoc />
        </member>
        <member name="M:Fluent.BackstageTabItem.OnGotFocus(System.Windows.RoutedEventArgs)">
            <inheritdoc />
        </member>
        <member name="M:Fluent.BackstageTabItem.OnSelected(System.Windows.RoutedEventArgs)">
            <summary>
            Handles selected event
            </summary>
            <param name="e">The event data.</param>
        </member>
        <member name="M:Fluent.BackstageTabItem.OnUnselected(System.Windows.RoutedEventArgs)">
            <summary>
            Handles unselected event
            </summary>
            <param name="e">The event data.</param>
        </member>
        <member name="M:Fluent.BackstageTabItem.HandleIsSelectedChanged(System.Windows.RoutedEventArgs)">
            <summary>
            Handles IsSelected changed
            </summary>
            <param name="e">The event data.</param>
        </member>
        <member name="M:Fluent.BackstageTabItem.OnKeyTipPressed">
            <inheritdoc />
        </member>
        <member name="M:Fluent.BackstageTabItem.OnKeyTipBack">
            <inheritdoc />
        </member>
        <member name="M:Fluent.BackstageTabItem.Fluent#ILogicalChildSupport#AddLogicalChild(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:Fluent.BackstageTabItem.Fluent#ILogicalChildSupport#RemoveLogicalChild(System.Object)">
            <inheritdoc />
        </member>
        <member name="P:Fluent.BackstageTabItem.LogicalChildren">
            <inheritdoc />
        </member>
        <member name="M:Fluent.BackstageTabItem.OnCreateAutomationPeer">
            <inheritdoc />
        </member>
        <member name="T:Fluent.Button">
            <summary>
            Represents button
            </summary>
        </member>
        <member name="P:Fluent.Button.Size">
            <inheritdoc />
        </member>
        <member name="F:Fluent.Button.SizeProperty">
            <summary>Identifies the <see cref="P:Fluent.Button.Size"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.Button.SizeDefinition">
            <inheritdoc />
        </member>
        <member name="F:Fluent.Button.SizeDefinitionProperty">
            <summary>Identifies the <see cref="P:Fluent.Button.SizeDefinition"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.Button.SimplifiedSizeDefinition">
            <inheritdoc />
        </member>
        <member name="F:Fluent.Button.SimplifiedSizeDefinitionProperty">
            <summary>Identifies the <see cref="P:Fluent.Button.SimplifiedSizeDefinition"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.Button.KeyTip">
            <inheritdoc />
        </member>
        <member name="F:Fluent.Button.KeyTipProperty">
            <summary>
            <see cref="T:System.Windows.DependencyProperty"/> for <see cref="P:Fluent.Button.KeyTip"/>.
            </summary>
        </member>
        <member name="P:Fluent.Button.Header">
            <inheritdoc />
        </member>
        <member name="F:Fluent.Button.HeaderProperty">
            <summary>Identifies the <see cref="P:Fluent.Button.Header"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.Button.HeaderTemplate">
            <inheritdoc />
        </member>
        <member name="F:Fluent.Button.HeaderTemplateProperty">
            <summary>Identifies the <see cref="P:Fluent.Button.HeaderTemplate"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.Button.HeaderTemplateSelector">
            <inheritdoc />
        </member>
        <member name="F:Fluent.Button.HeaderTemplateSelectorProperty">
            <summary>Identifies the <see cref="P:Fluent.Button.HeaderTemplateSelector"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.Button.Icon">
            <inheritdoc />
        </member>
        <member name="F:Fluent.Button.IconProperty">
            <summary>Identifies the <see cref="P:Fluent.Button.Icon"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.Button.LargeIcon">
            <inheritdoc />
        </member>
        <member name="F:Fluent.Button.LargeIconProperty">
            <summary>Identifies the <see cref="P:Fluent.Button.LargeIcon"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.Button.MediumIcon">
            <inheritdoc />
        </member>
        <member name="F:Fluent.Button.MediumIconProperty">
            <summary>Identifies the <see cref="P:Fluent.Button.MediumIcon"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.Button.IsDefinitive">
            <summary>
            Gets or sets whether ribbon control click must close backstage
            </summary>
        </member>
        <member name="F:Fluent.Button.IsDefinitiveProperty">
            <summary>Identifies the <see cref="P:Fluent.Button.IsDefinitive"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.Button.IsSimplified">
            <summary>
            Gets or sets whether or not the ribbon is in Simplified mode
            </summary>
        </member>
        <member name="F:Fluent.Button.IsSimplifiedProperty">
            <summary>Identifies the <see cref="P:Fluent.Button.IsSimplified"/> dependency property.</summary>
        </member>
        <member name="M:Fluent.Button.#cctor">
            <summary>
            Static constructor
            </summary>
        </member>
        <member name="M:Fluent.Button.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:Fluent.Button.OnClick">
            <inheritdoc />
        </member>
        <member name="M:Fluent.Button.CreateQuickAccessItem">
            <inheritdoc />
        </member>
        <member name="P:Fluent.Button.CanAddToQuickAccessToolBar">
            <inheritdoc />
        </member>
        <member name="F:Fluent.Button.CanAddToQuickAccessToolBarProperty">
            <summary>Identifies the <see cref="P:Fluent.Button.CanAddToQuickAccessToolBar"/> dependency property.</summary>
        </member>
        <member name="M:Fluent.Button.OnKeyTipPressed">
            <inheritdoc />
        </member>
        <member name="M:Fluent.Button.OnKeyTipBack">
            <inheritdoc />
        </member>
        <member name="M:Fluent.Button.Fluent#ISimplifiedStateControl#UpdateSimplifiedState(System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:Fluent.Button.Fluent#ILogicalChildSupport#AddLogicalChild(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:Fluent.Button.Fluent#ILogicalChildSupport#RemoveLogicalChild(System.Object)">
            <inheritdoc />
        </member>
        <member name="P:Fluent.Button.LogicalChildren">
            <inheritdoc />
        </member>
        <member name="M:Fluent.Button.OnCreateAutomationPeer">
            <inheritdoc />
        </member>
        <member name="T:Fluent.CheckBox">
            <summary>
            Represents Fluent UI specific CheckBox
            </summary>
        </member>
        <member name="P:Fluent.CheckBox.Size">
            <inheritdoc />
        </member>
        <member name="F:Fluent.CheckBox.SizeProperty">
            <summary>Identifies the <see cref="P:Fluent.CheckBox.Size"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.CheckBox.SizeDefinition">
            <inheritdoc />
        </member>
        <member name="F:Fluent.CheckBox.SizeDefinitionProperty">
            <summary>Identifies the <see cref="P:Fluent.CheckBox.SizeDefinition"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.CheckBox.SimplifiedSizeDefinition">
            <inheritdoc />
        </member>
        <member name="F:Fluent.CheckBox.SimplifiedSizeDefinitionProperty">
            <summary>Identifies the <see cref="P:Fluent.CheckBox.SimplifiedSizeDefinition"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.CheckBox.KeyTip">
            <inheritdoc />
        </member>
        <member name="F:Fluent.CheckBox.KeyTipProperty">
            <summary>
            Using a DependencyProperty as the backing store for Keys.
            This enables animation, styling, binding, etc...
            </summary>
        </member>
        <member name="P:Fluent.CheckBox.Header">
            <inheritdoc />
        </member>
        <member name="F:Fluent.CheckBox.HeaderProperty">
            <summary>Identifies the <see cref="P:Fluent.CheckBox.Header"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.CheckBox.HeaderTemplate">
            <inheritdoc />
        </member>
        <member name="F:Fluent.CheckBox.HeaderTemplateProperty">
            <summary>Identifies the <see cref="P:Fluent.CheckBox.HeaderTemplate"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.CheckBox.HeaderTemplateSelector">
            <inheritdoc />
        </member>
        <member name="F:Fluent.CheckBox.HeaderTemplateSelectorProperty">
            <summary>Identifies the <see cref="P:Fluent.CheckBox.HeaderTemplateSelector"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.CheckBox.Icon">
            <inheritdoc />
        </member>
        <member name="F:Fluent.CheckBox.IconProperty">
            <summary>Identifies the <see cref="P:Fluent.CheckBox.Icon"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.CheckBox.LargeIcon">
            <inheritdoc />
        </member>
        <member name="F:Fluent.CheckBox.LargeIconProperty">
            <summary>Identifies the <see cref="P:Fluent.CheckBox.LargeIcon"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.CheckBox.MediumIcon">
            <inheritdoc />
        </member>
        <member name="F:Fluent.CheckBox.MediumIconProperty">
            <summary>Identifies the <see cref="P:Fluent.CheckBox.MediumIcon"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.CheckBox.IsSimplified">
            <summary>
            Gets or sets whether or not the ribbon is in Simplified mode
            </summary>
        </member>
        <member name="F:Fluent.CheckBox.IsSimplifiedProperty">
            <summary>Identifies the <see cref="P:Fluent.CheckBox.IsSimplified"/> dependency property.</summary>
        </member>
        <member name="M:Fluent.CheckBox.#cctor">
            <summary>
            Static constructor
            </summary>
        </member>
        <member name="M:Fluent.CheckBox.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:Fluent.CheckBox.CreateQuickAccessItem">
            <inheritdoc />
        </member>
        <member name="P:Fluent.CheckBox.CanAddToQuickAccessToolBar">
            <inheritdoc />
        </member>
        <member name="F:Fluent.CheckBox.CanAddToQuickAccessToolBarProperty">
            <summary>Identifies the <see cref="P:Fluent.CheckBox.CanAddToQuickAccessToolBar"/> dependency property.</summary>
        </member>
        <member name="M:Fluent.CheckBox.OnKeyTipPressed">
            <inheritdoc />
        </member>
        <member name="M:Fluent.CheckBox.OnKeyTipBack">
            <inheritdoc />
        </member>
        <member name="M:Fluent.CheckBox.Fluent#ISimplifiedStateControl#UpdateSimplifiedState(System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:Fluent.CheckBox.Fluent#ILogicalChildSupport#AddLogicalChild(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:Fluent.CheckBox.Fluent#ILogicalChildSupport#RemoveLogicalChild(System.Object)">
            <inheritdoc />
        </member>
        <member name="P:Fluent.CheckBox.LogicalChildren">
            <inheritdoc />
        </member>
        <member name="M:Fluent.CheckBox.OnCreateAutomationPeer">
            <inheritdoc />
        </member>
        <member name="T:Fluent.ColorGalleryMode">
            <summary>
            Represents color gallery modes
            </summary>
        </member>
        <member name="F:Fluent.ColorGalleryMode.HighlightColors">
            <summary>
            Color gallery displays only fixed highlight colors
            </summary>
        </member>
        <member name="F:Fluent.ColorGalleryMode.StandardColors">
            <summary>
            Color gallery displays only fixed standart colors
            </summary>
        </member>
        <member name="F:Fluent.ColorGalleryMode.ThemeColors">
            <summary>
            Color gallery displays theme colors
            </summary>
        </member>
        <member name="T:Fluent.ColorGradientItemTemplateSelector">
            <summary>
            Date template selector for gradients
            </summary>
        </member>
        <member name="M:Fluent.ColorGradientItemTemplateSelector.SelectTemplate(System.Object,System.Windows.DependencyObject)">
            <summary>
            When overridden in a derived class, returns a <see cref="T:System.Windows.DataTemplate"/> based on custom logic.
            </summary>
            <returns>
            Returns a <see cref="T:System.Windows.DataTemplate"/> or null. The default value is null.
            </returns>
            <param name="item">The data object for which to select the template.</param><param name="container">The data-bound object.</param>
        </member>
        <member name="T:Fluent.MoreColorsExecutingEventArgs">
            <summary>
            More colors event args
            </summary>
        </member>
        <member name="P:Fluent.MoreColorsExecutingEventArgs.Color">
            <summary>
            Gets or sets choosed color
            </summary>
        </member>
        <member name="P:Fluent.MoreColorsExecutingEventArgs.Canceled">
            <summary>
            Gets or sets a value indicating whether more colors is canceled
            </summary>
        </member>
        <member name="T:Fluent.ColorGallery">
            <summary>
            Represents color gallery
            </summary>
        </member>
        <member name="F:Fluent.ColorGallery.HighlightColors">
            <summary>
            Hightlight colors array
            </summary>
        </member>
        <member name="F:Fluent.ColorGallery.StandardColors">
            <summary>
            Standard colors array
            </summary>
        </member>
        <member name="F:Fluent.ColorGallery.StandardThemeColors">
            <summary>
            Standard colors array in ThemeColor mode
            </summary>
        </member>
        <member name="P:Fluent.ColorGallery.RecentColors">
            <summary>
            Gets recent colors collection
            </summary>
        </member>
        <member name="P:Fluent.ColorGallery.Mode">
            <summary>
            Gets or sets color gallery mode
            </summary>
        </member>
        <member name="F:Fluent.ColorGallery.ModeProperty">
            <summary>Identifies the <see cref="P:Fluent.ColorGallery.Mode"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.ColorGallery.ChipWidth">
            <summary>
            Gets or sets chip width
            </summary>
        </member>
        <member name="F:Fluent.ColorGallery.ChipWidthProperty">
            <summary>Identifies the <see cref="P:Fluent.ColorGallery.ChipWidth"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.ColorGallery.ChipHeight">
            <summary>
            Gets or sets chip height
            </summary>
        </member>
        <member name="F:Fluent.ColorGallery.ChipHeightProperty">
            <summary>Identifies the <see cref="P:Fluent.ColorGallery.ChipHeight"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.ColorGallery.IsAutomaticColorButtonVisible">
            <summary>
            Gets or sets a value indicating whether Automatic button is visible
            </summary>
        </member>
        <member name="F:Fluent.ColorGallery.IsAutomaticColorButtonVisibleProperty">
            <summary>Identifies the <see cref="P:Fluent.ColorGallery.IsAutomaticColorButtonVisible"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.ColorGallery.IsNoColorButtonVisible">
            <summary>
            Gets or sets a value indicating whether No color button is visible
            </summary>
        </member>
        <member name="F:Fluent.ColorGallery.IsNoColorButtonVisibleProperty">
            <summary>Identifies the <see cref="P:Fluent.ColorGallery.IsNoColorButtonVisible"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.ColorGallery.IsMoreColorsButtonVisible">
            <summary>
            Gets or sets a value indicating whether More Colors button is visible
            </summary>
        </member>
        <member name="F:Fluent.ColorGallery.IsMoreColorsButtonVisibleProperty">
            <summary>Identifies the <see cref="P:Fluent.ColorGallery.IsMoreColorsButtonVisible"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.ColorGallery.Columns">
            <summary>
            Gets or sets number of color gallery columns. It works only when Mode is ThemeColors
            </summary>
        </member>
        <member name="F:Fluent.ColorGallery.ColumnsProperty">
            <summary>Identifies the <see cref="P:Fluent.ColorGallery.Columns"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.ColorGallery.StandardColorGridRows">
            <summary>
            Gets or set number of standard color rows. Work only when Mode is ThemeColors
            </summary>
        </member>
        <member name="F:Fluent.ColorGallery.StandardColorGridRowsProperty">
            <summary>Identifies the <see cref="P:Fluent.ColorGallery.StandardColorGridRows"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.ColorGallery.ThemeColorGridRows">
            <summary>
            Gets or set number of theme color rows. Work only when Mode is ThemeColors
            </summary>
        </member>
        <member name="F:Fluent.ColorGallery.ThemeColorGridRowsProperty">
            <summary>Identifies the <see cref="P:Fluent.ColorGallery.ThemeColorGridRows"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.ColorGallery.SelectedColor">
            <summary>
            Gets or sets selected color
            </summary>
        </member>
        <member name="F:Fluent.ColorGallery.SelectedColorProperty">
            <summary>Identifies the <see cref="P:Fluent.ColorGallery.SelectedColor"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.ColorGallery.ThemeColors">
            <summary>
            Gets collection of theme colors
            </summary>
        </member>
        <member name="P:Fluent.ColorGallery.ThemeColorsSource">
            <summary>
            Gets or sets theme colors source
            </summary>
        </member>
        <member name="F:Fluent.ColorGallery.ThemeColorsSourceProperty">
            <summary>Identifies the <see cref="P:Fluent.ColorGallery.ThemeColorsSource"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.ColorGallery.ThemeGradients">
            <summary>
            Gets theme gradients collection
            </summary>
        </member>
        <member name="F:Fluent.ColorGallery.ThemeGradientsProperty">
            <summary>Identifies the <see cref="P:Fluent.ColorGallery.ThemeGradients"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.ColorGallery.StandardGradients">
            <summary>
            Gets standart gradients collection
            </summary>
        </member>
        <member name="F:Fluent.ColorGallery.StandardGradientsProperty">
            <summary>Identifies the <see cref="P:Fluent.ColorGallery.StandardGradients"/> dependency property.</summary>
        </member>
        <member name="E:Fluent.ColorGallery.SelectedColorChanged">
            <summary>
            Occurs when selection color is changed
            </summary>
        </member>
        <member name="F:Fluent.ColorGallery.SelectedColorChangedEvent">
            <summary>
            Identifies the SelectedColorChanged routed event.
            </summary>
        </member>
        <member name="E:Fluent.ColorGallery.MoreColorsExecuting">
            <summary>
            Occurs whether more colors menu item is clicked
            </summary>
        </member>
        <member name="M:Fluent.ColorGallery.#cctor">
            <summary>
            Static constructor
            </summary>
        </member>
        <member name="M:Fluent.ColorGallery.OnApplyTemplate">
            <inheritdoc />
        </member>
        <member name="M:Fluent.ColorGallery.GetBrightness(System.Windows.Media.Color)">
            <summary>
            Returns brightness of the given color from 0..1
            </summary>
            <param name="color">Color</param>
            <returns>Brightness of the given color from 0..1</returns>
        </member>
        <member name="M:Fluent.ColorGallery.GetGradient(System.Windows.Media.Color,System.Int32)">
            <summary>
            Makes gradient colors from lighter to darker
            </summary>
            <param name="color">Base color</param>
            <param name="count">Count of items in the gradient</param>
            <returns>Colors from lighter to darker</returns>
        </member>
        <member name="T:Fluent.ComboBox">
            <summary>
                Represents custom Fluent UI ComboBox
            </summary>
        </member>
        <member name="P:Fluent.ComboBox.Size">
            <inheritdoc />
        </member>
        <member name="F:Fluent.ComboBox.SizeProperty">
            <summary>Identifies the <see cref="P:Fluent.ComboBox.Size"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.ComboBox.SizeDefinition">
            <inheritdoc />
        </member>
        <member name="F:Fluent.ComboBox.SizeDefinitionProperty">
            <summary>Identifies the <see cref="P:Fluent.ComboBox.SizeDefinition"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.ComboBox.SimplifiedSizeDefinition">
            <inheritdoc />
        </member>
        <member name="F:Fluent.ComboBox.SimplifiedSizeDefinitionProperty">
            <summary>Identifies the <see cref="P:Fluent.ComboBox.SimplifiedSizeDefinition"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.ComboBox.KeyTip">
            <inheritdoc />
        </member>
        <member name="F:Fluent.ComboBox.KeyTipProperty">
            <summary>Identifies the <see cref="P:Fluent.ComboBox.KeyTip"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.ComboBox.DropDownPopup">
            <inheritdoc />
        </member>
        <member name="P:Fluent.ComboBox.IsContextMenuOpened">
            <inheritdoc />
        </member>
        <member name="P:Fluent.ComboBox.Header">
            <inheritdoc />
        </member>
        <member name="F:Fluent.ComboBox.HeaderProperty">
            <summary>Identifies the <see cref="P:Fluent.ComboBox.Header"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.ComboBox.HeaderTemplate">
            <inheritdoc />
        </member>
        <member name="F:Fluent.ComboBox.HeaderTemplateProperty">
            <summary>Identifies the <see cref="P:Fluent.ComboBox.HeaderTemplate"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.ComboBox.HeaderTemplateSelector">
            <inheritdoc />
        </member>
        <member name="F:Fluent.ComboBox.HeaderTemplateSelectorProperty">
            <summary>Identifies the <see cref="P:Fluent.ComboBox.HeaderTemplateSelector"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.ComboBox.Icon">
            <inheritdoc />
        </member>
        <member name="F:Fluent.ComboBox.IconProperty">
            <summary>Identifies the <see cref="P:Fluent.ComboBox.Icon"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.ComboBox.MediumIcon">
            <inheritdoc />
        </member>
        <member name="F:Fluent.ComboBox.MediumIconProperty">
            <summary>Identifies the <see cref="P:Fluent.ComboBox.MediumIcon"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.ComboBox.TopPopupContent">
            <summary>
            Gets or sets content to show on the top side of the Popup.
            </summary>
        </member>
        <member name="F:Fluent.ComboBox.TopPopupContentProperty">
            <summary>Identifies the <see cref="P:Fluent.ComboBox.TopPopupContent"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.ComboBox.TopPopupContentTemplate">
            <summary>
            Gets or sets top content template.
            </summary>
        </member>
        <member name="F:Fluent.ComboBox.TopPopupContentTemplateProperty">
            <summary>Identifies the <see cref="P:Fluent.ComboBox.TopPopupContentTemplate"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.ComboBox.TopPopupContentTemplateSelector">
            <summary>
            Gets or sets top content template selector.
            </summary>
        </member>
        <member name="F:Fluent.ComboBox.TopPopupContentTemplateSelectorProperty">
            <summary>Identifies the <see cref="P:Fluent.ComboBox.TopPopupContentTemplateSelector"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.ComboBox.TopPopupContentStringFormat">
            <summary>
            Gets or sets top content template string format.
            </summary>
        </member>
        <member name="F:Fluent.ComboBox.TopPopupContentStringFormatProperty">
            <summary>Identifies the <see cref="P:Fluent.ComboBox.TopPopupContentStringFormat"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.ComboBox.Menu">
            <summary>
                Gets or sets menu to show in combo box bottom
            </summary>
        </member>
        <member name="F:Fluent.ComboBox.MenuProperty">
            <summary>Identifies the <see cref="P:Fluent.ComboBox.Menu"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.ComboBox.ResizeMode">
            <summary>
                Gets or sets context menu resize mode
            </summary>
        </member>
        <member name="F:Fluent.ComboBox.ResizeModeProperty">
            <summary>Identifies the <see cref="P:Fluent.ComboBox.ResizeMode"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.ComboBox.IsSnapped">
            <summary>
                Snaps / Unsnaps the Visual
                (remove visuals and substitute with freezed image)
            </summary>
        </member>
        <member name="P:Fluent.ComboBox.DropDownHeight">
            <summary>
                Gets or sets initial dropdown height
            </summary>
        </member>
        <member name="F:Fluent.ComboBox.DropDownHeightProperty">
            <summary>Identifies the <see cref="P:Fluent.ComboBox.DropDownHeight"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.ComboBox.IsSimplified">
            <summary>
            Gets or sets whether or not the ribbon is in Simplified mode
            </summary>
        </member>
        <member name="F:Fluent.ComboBox.IsSimplifiedProperty">
            <summary>Identifies the <see cref="P:Fluent.ComboBox.IsSimplified"/> dependency property.</summary>
        </member>
        <member name="M:Fluent.ComboBox.#cctor">
            <summary>
                Static constructor
            </summary>
        </member>
        <member name="M:Fluent.ComboBox.#ctor">
            <summary>
                Default Constructor
            </summary>
        </member>
        <member name="M:Fluent.ComboBox.CreateQuickAccessItem">
            <inheritdoc />
        </member>
        <member name="P:Fluent.ComboBox.CanAddToQuickAccessToolBar">
            <inheritdoc />
        </member>
        <member name="F:Fluent.ComboBox.CanAddToQuickAccessToolBarProperty">
            <summary>Identifies the <see cref="P:Fluent.ComboBox.CanAddToQuickAccessToolBar"/> dependency property.</summary>
        </member>
        <member name="M:Fluent.ComboBox.OnApplyTemplate">
            <inheritdoc />
        </member>
        <member name="M:Fluent.ComboBox.OnDropDownOpened(System.EventArgs)">
            <inheritdoc />
        </member>
        <member name="M:Fluent.ComboBox.OnDropDownClosed(System.EventArgs)">
            <inheritdoc />
        </member>
        <member name="M:Fluent.ComboBox.OnPreviewKeyDown(System.Windows.Input.KeyEventArgs)">
            <inheritdoc />
        </member>
        <member name="M:Fluent.ComboBox.OnKeyDown(System.Windows.Input.KeyEventArgs)">
            <inheritdoc />
        </member>
        <member name="M:Fluent.ComboBox.OnKeyTipPressed">
            <inheritdoc />
        </member>
        <member name="M:Fluent.ComboBox.OnKeyTipBack">
            <inheritdoc />
        </member>
        <member name="M:Fluent.ComboBox.Fluent#ISimplifiedStateControl#UpdateSimplifiedState(System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:Fluent.ComboBox.Fluent#ILogicalChildSupport#AddLogicalChild(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:Fluent.ComboBox.Fluent#ILogicalChildSupport#RemoveLogicalChild(System.Object)">
            <inheritdoc />
        </member>
        <member name="P:Fluent.ComboBox.LogicalChildren">
            <inheritdoc />
        </member>
        <member name="M:Fluent.ComboBox.OnCreateAutomationPeer">
            <inheritdoc />
        </member>
        <member name="T:Fluent.ContextMenuResizeMode">
            <summary>
            Represents context menu resize mode
            </summary>
        </member>
        <member name="F:Fluent.ContextMenuResizeMode.None">
            <summary>
            Context menu can not be resized
            </summary>
        </member>
        <member name="F:Fluent.ContextMenuResizeMode.Vertical">
            <summary>
            Context menu can be only resized vertically
            </summary>
        </member>
        <member name="F:Fluent.ContextMenuResizeMode.Both">
            <summary>
            Context menu can be resized vertically and horizontally
            </summary>
        </member>
        <member name="T:Fluent.ContextMenu">
            <summary>
            Represents a pop-up menu that enables a control
            to expose functionality that is specific to the context of the control
            </summary>
        </member>
        <member name="P:Fluent.ContextMenu.ResizeMode">
            <summary>
            Gets or sets context menu resize mode
            </summary>
        </member>
        <member name="F:Fluent.ContextMenu.ResizeModeProperty">
            <summary>Identifies the <see cref="P:Fluent.ContextMenu.ResizeMode"/> dependency property.</summary>
        </member>
        <member name="M:Fluent.ContextMenu.#cctor">
            <summary>
            Static constructor
            </summary>]
        </member>
        <member name="M:Fluent.ContextMenu.OnApplyTemplate">
            <inheritdoc />
        </member>
        <member name="M:Fluent.ContextMenu.GetContainerForItemOverride">
            <inheritdoc />
        </member>
        <member name="M:Fluent.ContextMenu.IsItemItsOwnContainerOverride(System.Object)">
            <inheritdoc />
        </member>
        <member name="T:Fluent.DropDownButton">
            <summary>
            Represents drop down button
            </summary>
        </member>
        <member name="P:Fluent.DropDownButton.Size">
            <summary>
            Gets or sets Size for the element.
            </summary>
        </member>
        <member name="F:Fluent.DropDownButton.SizeProperty">
            <summary>Identifies the <see cref="P:Fluent.DropDownButton.Size"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.DropDownButton.SizeDefinition">
            <inheritdoc />
        </member>
        <member name="F:Fluent.DropDownButton.SizeDefinitionProperty">
            <summary>Identifies the <see cref="P:Fluent.DropDownButton.SizeDefinition"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.DropDownButton.SimplifiedSizeDefinition">
            <inheritdoc />
        </member>
        <member name="F:Fluent.DropDownButton.SimplifiedSizeDefinitionProperty">
            <summary>Identifies the <see cref="P:Fluent.DropDownButton.SimplifiedSizeDefinition"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.DropDownButton.KeyTip">
            <inheritdoc />
        </member>
        <member name="F:Fluent.DropDownButton.KeyTipProperty">
            <summary>
            Using a DependencyProperty as the backing store for Keys.
            This enables animation, styling, binding, etc...
            </summary>
        </member>
        <member name="P:Fluent.DropDownButton.DropDownPopup">
            <inheritdoc />
        </member>
        <member name="P:Fluent.DropDownButton.IsContextMenuOpened">
            <inheritdoc />
        </member>
        <member name="P:Fluent.DropDownButton.DismissOnClickOutside">
            <summary>
            If false: popup will not be dismissed if a mouse click occurred outside the DropDownButon's borders. <para></para>
            <see cref="P:Fluent.DropDownButton.IsDropDownOpen"/> and <see cref="P:Fluent.DropDownButton.ClosePopupOnMouseDown"/> will not be affected by this value.<para/>
            Default value is True.
            </summary>
        </member>
        <member name="F:Fluent.DropDownButton.DismissOnClickOutsideProperty">
            <summary>Identifies the <see cref="P:Fluent.DropDownButton.DismissOnClickOutside"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.DropDownButton.Header">
            <inheritdoc />
        </member>
        <member name="F:Fluent.DropDownButton.HeaderProperty">
            <summary>Identifies the <see cref="P:Fluent.DropDownButton.Header"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.DropDownButton.HeaderTemplate">
            <inheritdoc />
        </member>
        <member name="F:Fluent.DropDownButton.HeaderTemplateProperty">
            <summary>Identifies the <see cref="P:Fluent.DropDownButton.HeaderTemplate"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.DropDownButton.HeaderTemplateSelector">
            <inheritdoc />
        </member>
        <member name="F:Fluent.DropDownButton.HeaderTemplateSelectorProperty">
            <summary>Identifies the <see cref="P:Fluent.DropDownButton.HeaderTemplateSelector"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.DropDownButton.Icon">
            <inheritdoc />
        </member>
        <member name="F:Fluent.DropDownButton.IconProperty">
            <summary>Identifies the <see cref="P:Fluent.DropDownButton.Icon"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.DropDownButton.LargeIcon">
            <inheritdoc />
        </member>
        <member name="F:Fluent.DropDownButton.LargeIconProperty">
            <summary>Identifies the <see cref="P:Fluent.DropDownButton.LargeIcon"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.DropDownButton.MediumIcon">
            <inheritdoc />
        </member>
        <member name="F:Fluent.DropDownButton.MediumIconProperty">
            <summary>Identifies the <see cref="P:Fluent.DropDownButton.MediumIcon"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.DropDownButton.HasTriangle">
            <summary>
            Gets or sets whether button has triangle
            </summary>
        </member>
        <member name="F:Fluent.DropDownButton.HasTriangleProperty">
            <summary>Identifies the <see cref="P:Fluent.DropDownButton.HasTriangle"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.DropDownButton.IsDropDownOpen">
            <inheritdoc />
        </member>
        <member name="F:Fluent.DropDownButton.IsDropDownOpenProperty">
            <summary>Identifies the <see cref="P:Fluent.DropDownButton.IsDropDownOpen"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.DropDownButton.ResizeMode">
            <summary>
            Gets or sets context menu resize mode
            </summary>
        </member>
        <member name="F:Fluent.DropDownButton.ResizeModeProperty">
            <summary>Identifies the <see cref="P:Fluent.DropDownButton.ResizeMode"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.DropDownButton.MaxDropDownHeight">
            <summary>
            Get or sets max height of drop down popup
            </summary>
        </member>
        <member name="F:Fluent.DropDownButton.MaxDropDownHeightProperty">
            <summary>Identifies the <see cref="P:Fluent.DropDownButton.MaxDropDownHeight"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.DropDownButton.DropDownHeight">
            <summary>
            Gets or sets initial dropdown height
            </summary>
        </member>
        <member name="F:Fluent.DropDownButton.DropDownHeightProperty">
            <summary>Identifies the <see cref="P:Fluent.DropDownButton.DropDownHeight"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.DropDownButton.ClosePopupOnMouseDown">
            <summary>
            Gets or sets whether the popup of this drop down button should automatically be closed on mouse down.
            </summary>
        </member>
        <member name="F:Fluent.DropDownButton.ClosePopupOnMouseDownProperty">
            <summary>Identifies the <see cref="P:Fluent.DropDownButton.ClosePopupOnMouseDown"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.DropDownButton.ClosePopupOnMouseDownDelay">
            <summary>
            Gets or sets the delay in milliseconds to close the popup on mouse down.
            </summary>
            <remarks>
            The minimum used delay is 100 ms, no matter which value is set.
            </remarks>
        </member>
        <member name="F:Fluent.DropDownButton.ClosePopupOnMouseDownDelayProperty">
            <summary>Identifies the <see cref="P:Fluent.DropDownButton.ClosePopupOnMouseDownDelay"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.DropDownButton.IsSimplified">
            <summary>
            Gets or sets whether or not the ribbon is in Simplified mode
            </summary>
        </member>
        <member name="F:Fluent.DropDownButton.IsSimplifiedProperty">
            <summary>Identifies the <see cref="P:Fluent.DropDownButton.IsSimplified"/> dependency property.</summary>
        </member>
        <member name="M:Fluent.DropDownButton.OnIsSimplifiedChanged(System.Boolean,System.Boolean)">
            <summary>
            Handles IsSimplified changed event for overide
            </summary>
            <param name="oldValue">old value</param>
            <param name="newValue">new value</param>
        </member>
        <member name="E:Fluent.DropDownButton.DropDownOpened">
            <inheritdoc />
        </member>
        <member name="E:Fluent.DropDownButton.DropDownClosed">
            <inheritdoc />
        </member>
        <member name="M:Fluent.DropDownButton.#cctor">
            <summary>
            Static constructor
            </summary>
        </member>
        <member name="M:Fluent.DropDownButton.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:Fluent.DropDownButton.OnApplyTemplate">
            <inheritdoc />
        </member>
        <member name="P:Fluent.DropDownButton.ItemContainerTemplateSelector">
            <summary>Gets or sets the custom logic for choosing a template used to display each item.</summary>
            <returns>A custom object that provides logic and returns an item container.</returns>
        </member>
        <member name="P:Fluent.DropDownButton.UsesItemContainerTemplate">
            <summary>Gets or sets a value that indicates whether the menu selects different item containers, depending on the type of the item in the underlying collection or some other heuristic.</summary>
            <returns>
                   <see langword="true" /> the menu selects different item containers; otherwise, <see langword="false" />.
            
            The registered default is <see langword="false" />. For more information about what can influence the value, see Dependency Property Value Precedence.</returns>
        </member>
        <member name="M:Fluent.DropDownButton.IsItemItsOwnContainerOverride(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:Fluent.DropDownButton.GetContainerForItemOverride">
            <inheritdoc />
        </member>
        <member name="M:Fluent.DropDownButton.OnKeyDown(System.Windows.Input.KeyEventArgs)">
            <inheritdoc />
        </member>
        <member name="M:Fluent.DropDownButton.OnKeyTipPressed">
            <inheritdoc />
        </member>
        <member name="M:Fluent.DropDownButton.OnKeyTipBack">
            <inheritdoc />
        </member>
        <member name="M:Fluent.DropDownButton.OnDropDownOpened">
            <summary>
            Called when drop down opened.
            </summary>
        </member>
        <member name="M:Fluent.DropDownButton.OnDropDownClosed">
            <summary>
            Called when drop down closed.
            </summary>
        </member>
        <member name="M:Fluent.DropDownButton.CreateQuickAccessItem">
            <inheritdoc />
        </member>
        <member name="M:Fluent.DropDownButton.OnQuickAccessOpened(System.Object,System.EventArgs)">
            <summary>
            Handles quick access button drop down menu opened
            </summary>
        </member>
        <member name="M:Fluent.DropDownButton.OnQuickAccessMenuClosedOrUnloaded(System.Object,System.EventArgs)">
            <summary>
            Handles quick access button drop down menu closed
            </summary>
        </member>
        <member name="M:Fluent.DropDownButton.BindQuickAccessItem(System.Windows.FrameworkElement)">
            <summary>
            This method must be overridden to bind properties to use in quick access creating
            </summary>
            <param name="element">Toolbar item</param>
        </member>
        <member name="M:Fluent.DropDownButton.BindQuickAccessItemDropDownEvents(Fluent.DropDownButton)">
            <summary>
            Binds the DropDownClosed and DropDownOpened events to the created quick access item
            </summary>
            <param name="button">Toolbar item</param>
        </member>
        <member name="P:Fluent.DropDownButton.CanAddToQuickAccessToolBar">
            <inheritdoc />
        </member>
        <member name="F:Fluent.DropDownButton.CanAddToQuickAccessToolBarProperty">
            <summary>Identifies the <see cref="P:Fluent.DropDownButton.CanAddToQuickAccessToolBar"/> dependency property.</summary>
        </member>
        <member name="M:Fluent.DropDownButton.OnCreateAutomationPeer">
            <inheritdoc />
        </member>
        <member name="M:Fluent.DropDownButton.Fluent#ISimplifiedStateControl#UpdateSimplifiedState(System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:Fluent.DropDownButton.Fluent#ILogicalChildSupport#AddLogicalChild(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:Fluent.DropDownButton.Fluent#ILogicalChildSupport#RemoveLogicalChild(System.Object)">
            <inheritdoc />
        </member>
        <member name="P:Fluent.DropDownButton.LogicalChildren">
            <inheritdoc />
        </member>
        <member name="T:Fluent.Gallery">
            <summary>
            Represents gallery control.
            Usually a gallery is hosted in context menu
            </summary>
        </member>
        <member name="P:Fluent.Gallery.MinItemsInRow">
            <summary>
            Min width of the Gallery
            </summary>
        </member>
        <member name="F:Fluent.Gallery.MinItemsInRowProperty">
            <summary>Identifies the <see cref="P:Fluent.Gallery.MinItemsInRow"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.Gallery.MaxItemsInRow">
            <summary>
            Max width of the Gallery
            </summary>
        </member>
        <member name="F:Fluent.Gallery.MaxItemsInRowProperty">
            <summary>Identifies the <see cref="P:Fluent.Gallery.MaxItemsInRow"/> dependency property.</summary>
        </member>
        <member name="F:Fluent.Gallery.IsGroupedProperty">
            <summary>Identifies the <see cref="P:Fluent.Gallery.IsGrouped"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.Gallery.IsGrouped">
            <summary>
            Gets or sets whether the inner gallery panel shows groups
            (Filter property still works as usual)
            </summary>
        </member>
        <member name="P:Fluent.Gallery.GroupBy">
            <summary>
            Gets or sets name of property which
            will use to group items in the Gallery.
            </summary>
        </member>
        <member name="F:Fluent.Gallery.GroupByProperty">
            <summary>Identifies the <see cref="P:Fluent.Gallery.GroupBy"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.Gallery.GroupByAdvanced">
            <summary>
            Gets or sets name of property which
            will use to group items in the Gallery.
            </summary>
        </member>
        <member name="F:Fluent.Gallery.GroupByAdvancedProperty">
            <summary>Identifies the <see cref="P:Fluent.Gallery.GroupByAdvanced"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.Gallery.Orientation">
            <summary>
            Gets or sets orientation of gallery
            </summary>
        </member>
        <member name="F:Fluent.Gallery.OrientationProperty">
            <summary>Identifies the <see cref="P:Fluent.Gallery.Orientation"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.Gallery.ItemWidth">
            <summary>
            Gets or sets item width
            </summary>
        </member>
        <member name="F:Fluent.Gallery.ItemWidthProperty">
            <summary>Identifies the <see cref="P:Fluent.Gallery.ItemWidth"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.Gallery.ItemHeight">
            <summary>
            Gets or sets item height
            </summary>
        </member>
        <member name="F:Fluent.Gallery.ItemHeightProperty">
            <summary>Identifies the <see cref="P:Fluent.Gallery.ItemHeight"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.Gallery.Filters">
            <summary>
            Gets collection of filters
            </summary>
        </member>
        <member name="P:Fluent.Gallery.SelectedFilter">
            <summary>
            Gets or sets selected filter
            </summary>
        </member>
        <member name="F:Fluent.Gallery.SelectedFilterProperty">
            <summary>Identifies the <see cref="P:Fluent.Gallery.SelectedFilter"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.Gallery.SelectedFilterTitle">
            <summary>
            Gets selected filter title
            </summary>
        </member>
        <member name="F:Fluent.Gallery.SelectedFilterTitleProperty">
            <summary>Identifies the <see cref="P:Fluent.Gallery.SelectedFilterTitle"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.Gallery.SelectedFilterGroups">
            <summary>
            Gets selected filter groups
            </summary>
        </member>
        <member name="F:Fluent.Gallery.SelectedFilterGroupsProperty">
            <summary>Identifies the <see cref="P:Fluent.Gallery.SelectedFilterGroups"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.Gallery.HasFilter">
            <summary>
            Gets whether gallery has selected filter
            </summary>
        </member>
        <member name="F:Fluent.Gallery.HasFilterProperty">
            <summary>Identifies the <see cref="P:Fluent.Gallery.HasFilter"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.Gallery.Selectable">
            <summary>
            Gets or sets whether gallery items can be selected
            </summary>
        </member>
        <member name="F:Fluent.Gallery.SelectableProperty">
            <summary>Identifies the <see cref="P:Fluent.Gallery.Selectable"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.Gallery.IsLastItem">
            <summary>
            Gets whether gallery is last item in ItemsControl
            </summary>
        </member>
        <member name="F:Fluent.Gallery.IsLastItemPropertyKey">
            <summary>Identifies the <see cref="P:Fluent.Gallery.IsLastItem"/> dependency property.</summary>
        </member>
        <member name="F:Fluent.Gallery.IsLastItemProperty">
            <summary>Identifies the <see cref="P:Fluent.Gallery.IsLastItem"/> dependency property.</summary>
        </member>
        <member name="M:Fluent.Gallery.#cctor">
            <summary>
            Static constructor
            </summary>
        </member>
        <member name="M:Fluent.Gallery.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:Fluent.Gallery.GetContainerForItemOverride">
            <inheritdoc />
        </member>
        <member name="M:Fluent.Gallery.IsItemItsOwnContainerOverride(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:Fluent.Gallery.OnApplyTemplate">
            <inheritdoc />
        </member>
        <member name="T:Fluent.GalleryGroupContainer">
            <summary>
            Represents container of grouped gallery items in GalleryPanel or Gallery
            </summary>
        </member>
        <member name="P:Fluent.GalleryGroupContainer.IsHeadered">
            <summary>
            Gets or sets whether the header must be shown.
            When the property is false this control uses to show all items without grouping
            </summary>
        </member>
        <member name="F:Fluent.GalleryGroupContainer.IsHeaderedProperty">
            <summary>Identifies the <see cref="P:Fluent.GalleryGroupContainer.IsHeadered"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.GalleryGroupContainer.Orientation">
            <summary>
            Gets or sets panel orientation
            </summary>
        </member>
        <member name="F:Fluent.GalleryGroupContainer.OrientationProperty">
            <summary>Identifies the <see cref="P:Fluent.GalleryGroupContainer.Orientation"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.GalleryGroupContainer.ItemWidth">
            <summary>
            Gets or sets a value that specifies the width of
            all items that are contained within
            </summary>
        </member>
        <member name="F:Fluent.GalleryGroupContainer.ItemWidthProperty">
            <summary>Identifies the <see cref="P:Fluent.GalleryGroupContainer.ItemWidth"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.GalleryGroupContainer.ItemHeight">
            <summary>
            Gets or sets a value that specifies the height of
            all items that are contained within
            </summary>
        </member>
        <member name="F:Fluent.GalleryGroupContainer.ItemHeightProperty">
            <summary>Identifies the <see cref="P:Fluent.GalleryGroupContainer.ItemHeight"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.GalleryGroupContainer.MinItemsInRow">
            <summary>
            Gets or sets minimum items in which should be placed in one row.
            </summary>
        </member>
        <member name="F:Fluent.GalleryGroupContainer.MinItemsInRowProperty">
            <summary>Identifies the <see cref="P:Fluent.GalleryGroupContainer.MinItemsInRow"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.GalleryGroupContainer.MaxItemsInRow">
            <summary>
            Gets or sets maximum items in which should be placed in one row.
            </summary>
        </member>
        <member name="F:Fluent.GalleryGroupContainer.MaxItemsInRowProperty">
            <summary>Identifies the <see cref="P:Fluent.GalleryGroupContainer.MaxItemsInRow"/> dependency property.</summary>
        </member>
        <member name="M:Fluent.GalleryGroupContainer.#cctor">
            <summary>
            Static constructor
            </summary>
        </member>
        <member name="M:Fluent.GalleryGroupContainer.OnItemsPanelChanged(System.Windows.Controls.ItemsPanelTemplate,System.Windows.Controls.ItemsPanelTemplate)">
            <inheritdoc />
        </member>
        <member name="T:Fluent.GalleryGroupFilter">
            <summary>
            Represents gallery group filter definition.
            </summary>
        </member>
        <member name="P:Fluent.GalleryGroupFilter.Title">
            <summary>
            Gets or sets title of filter.
            </summary>
        </member>
        <member name="F:Fluent.GalleryGroupFilter.TitleProperty">
            <summary>Identifies the <see cref="P:Fluent.GalleryGroupFilter.Title"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.GalleryGroupFilter.Groups">
            <summary>
            Gets or sets list of groups separated by comma.
            </summary>
        </member>
        <member name="F:Fluent.GalleryGroupFilter.GroupsProperty">
            <summary>Identifies the <see cref="P:Fluent.GalleryGroupFilter.Groups"/> dependency property.</summary>
        </member>
        <member name="T:Fluent.GalleryItem">
            <summary>
            Represents gallery item
            </summary>
        </member>
        <member name="P:Fluent.GalleryItem.KeyTip">
            <inheritdoc />
        </member>
        <member name="F:Fluent.GalleryItem.KeyTipProperty">
            <summary>
            Using a DependencyProperty as the backing store for Keys.
            This enables animation, styling, binding, etc...
            </summary>
        </member>
        <member name="P:Fluent.GalleryItem.IsPressed">
            <summary>
            Gets a value that indicates whether a Button is currently activated.
            This is a dependency property.
            </summary>
        </member>
        <member name="F:Fluent.GalleryItem.IsPressedProperty">
            <summary>Identifies the <see cref="P:Fluent.GalleryItem.IsPressed"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.GalleryItem.Group">
            <summary>
            Gets or sets GalleryItem group
            </summary>
        </member>
        <member name="F:Fluent.GalleryItem.GroupProperty">
            <summary>Identifies the <see cref="P:Fluent.GalleryItem.Group"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.GalleryItem.IsDefinitive">
            <summary>
            Gets or sets whether ribbon control click must close backstage or popup.
            </summary>
        </member>
        <member name="F:Fluent.GalleryItem.IsDefinitiveProperty">
            <summary>Identifies the <see cref="P:Fluent.GalleryItem.IsDefinitive"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.GalleryItem.Command">
            <inheritdoc />
        </member>
        <member name="P:Fluent.GalleryItem.CommandParameter">
            <inheritdoc />
        </member>
        <member name="P:Fluent.GalleryItem.CommandTarget">
            <inheritdoc />
        </member>
        <member name="F:Fluent.GalleryItem.CommandParameterProperty">
            <summary>Identifies the <see cref="P:Fluent.GalleryItem.CommandParameter"/> dependency property.</summary>
        </member>
        <member name="F:Fluent.GalleryItem.CommandProperty">
            <summary>Identifies the <see cref="P:Fluent.GalleryItem.Command"/> dependency property.</summary>
        </member>
        <member name="F:Fluent.GalleryItem.CommandTargetProperty">
            <summary>Identifies the <see cref="P:Fluent.GalleryItem.CommandTarget"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.GalleryItem.PreviewCommand">
            <summary>
            Gets or sets the command to invoke when mouse enters or leaves this button. The commandparameter will be the <see cref="T:Fluent.GalleryItem"/> instance.
            This is a dependency property.
            </summary>
        </member>
        <member name="F:Fluent.GalleryItem.PreviewCommandProperty">
            <summary>Identifies the <see cref="P:Fluent.GalleryItem.PreviewCommand"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.GalleryItem.CancelPreviewCommand">
            <summary>
            Gets or sets the command to invoke when mouse enters or leaves this button. The commandparameter will be the <see cref="T:Fluent.GalleryItem"/> instance.
            This is a dependency property.
            </summary>
        </member>
        <member name="F:Fluent.GalleryItem.CancelPreviewCommandProperty">
            <summary>Identifies the <see cref="P:Fluent.GalleryItem.CancelPreviewCommand"/> dependency property.</summary>
        </member>
        <member name="M:Fluent.GalleryItem.OnCommandChanged(System.Windows.DependencyObject,System.Windows.DependencyPropertyChangedEventArgs)">
            <summary>
            Handles Command changed
            </summary>
        </member>
        <member name="M:Fluent.GalleryItem.OnCommandCanExecuteChanged(System.Object,System.EventArgs)">
            <summary>
            Handles Command CanExecute changed
            </summary>
        </member>
        <member name="P:Fluent.GalleryItem.IsEnabledCore">
            <inheritdoc />
        </member>
        <member name="E:Fluent.GalleryItem.Click">
            <summary>
            Occurs when a RibbonControl is clicked.
            </summary>
        </member>
        <member name="F:Fluent.GalleryItem.ClickEvent">
            <summary>
            Identifies the RibbonControl.Click routed event.
            </summary>
        </member>
        <member name="M:Fluent.GalleryItem.RaiseClick">
            <summary>
            Raises click event
            </summary>
        </member>
        <member name="M:Fluent.GalleryItem.#cctor">
            <summary>
            Static constructor
            </summary>
        </member>
        <member name="M:Fluent.GalleryItem.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:Fluent.GalleryItem.OnMouseLeftButtonDown(System.Windows.Input.MouseButtonEventArgs)">
            <inheritdoc />
        </member>
        <member name="M:Fluent.GalleryItem.OnLostMouseCapture(System.Windows.Input.MouseEventArgs)">
            <inheritdoc />
        </member>
        <member name="M:Fluent.GalleryItem.OnMouseLeftButtonUp(System.Windows.Input.MouseButtonEventArgs)">
            <inheritdoc />
        </member>
        <member name="M:Fluent.GalleryItem.OnMouseEnter(System.Windows.Input.MouseEventArgs)">
            <inheritdoc />
        </member>
        <member name="M:Fluent.GalleryItem.OnMouseLeave(System.Windows.Input.MouseEventArgs)">
            <inheritdoc />
        </member>
        <member name="M:Fluent.GalleryItem.OnKeyUp(System.Windows.Input.KeyEventArgs)">
            <inheritdoc />
        </member>
        <member name="M:Fluent.GalleryItem.OnClick(System.Object,System.Windows.RoutedEventArgs)">
            <summary>
            Handles click event
            </summary>
            <param name="sender">Sender</param>
            <param name="e">The event data</param>
        </member>
        <member name="M:Fluent.GalleryItem.OnKeyTipPressed">
            <inheritdoc />
        </member>
        <member name="M:Fluent.GalleryItem.OnKeyTipBack">
            <inheritdoc />
        </member>
        <member name="M:Fluent.GalleryItem.OnCreateAutomationPeer">
            <inheritdoc />
        </member>
        <member name="T:Fluent.GalleryItemPlaceholder">
            <summary>
            Represents internal class to use it in
            GalleryPanel as placeholder for GalleryItems
            </summary>
        </member>
        <member name="P:Fluent.GalleryItemPlaceholder.Target">
            <summary>
            Gets the target of the placeholder
            </summary>
        </member>
        <member name="M:Fluent.GalleryItemPlaceholder.#ctor(System.Windows.UIElement)">
            <summary>
            Constructor
            </summary>
            <param name="target">Target</param>
        </member>
        <member name="M:Fluent.GalleryItemPlaceholder.MeasureCore(System.Windows.Size)">
            <inheritdoc />
        </member>
        <member name="M:Fluent.GalleryItemPlaceholder.ArrangeCore(System.Windows.Rect)">
            <inheritdoc />
        </member>
        <member name="T:Fluent.GalleryPanel">
            <summary>
            Represents panel for Gallery and InRibbonGallery with grouping and filtering capabilities
            </summary>
        </member>
        <member name="P:Fluent.GalleryPanel.IsGrouped">
            <summary>
            Gets or sets whether gallery panel shows groups
            (Filter property still works as usual)
            </summary>
        </member>
        <member name="F:Fluent.GalleryPanel.IsGroupedProperty">
            <summary>Identifies the <see cref="P:Fluent.GalleryPanel.IsGrouped"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.GalleryPanel.GroupBy">
            <summary>
            Gets or sets property name to group items
            </summary>
        </member>
        <member name="F:Fluent.GalleryPanel.GroupByProperty">
            <summary>Identifies the <see cref="P:Fluent.GalleryPanel.GroupBy"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.GalleryPanel.GroupByAdvanced">
            <summary>
            Gets or sets name of property which
            will use to group items in the Gallery.
            </summary>
        </member>
        <member name="F:Fluent.GalleryPanel.GroupByAdvancedProperty">
            <summary>Identifies the <see cref="P:Fluent.GalleryPanel.GroupByAdvanced"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.GalleryPanel.ItemContainerGenerator">
            <summary>
            Gets or sets ItemContainerGenerator which generates the
            user interface (UI) on behalf of its host, such as an  ItemsControl.
            </summary>
        </member>
        <member name="F:Fluent.GalleryPanel.ItemContainerGeneratorProperty">
            <summary>Identifies the <see cref="P:Fluent.GalleryPanel.ItemContainerGenerator"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.GalleryPanel.ItemWidth">
            <summary>
            Gets or sets a value that specifies the width of
            all items that are contained within
            </summary>
        </member>
        <member name="F:Fluent.GalleryPanel.ItemWidthProperty">
            <summary>Identifies the <see cref="P:Fluent.GalleryPanel.ItemWidth"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.GalleryPanel.ItemHeight">
            <summary>
            Gets or sets a value that specifies the height of
            all items that are contained within
            </summary>
        </member>
        <member name="F:Fluent.GalleryPanel.ItemHeightProperty">
            <summary>Identifies the <see cref="P:Fluent.GalleryPanel.ItemHeight"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.GalleryPanel.Filter">
            <summary>
            Gets or sets groups names separated by comma which must be shown
            </summary>
        </member>
        <member name="F:Fluent.GalleryPanel.FilterProperty">
            <summary>Identifies the <see cref="P:Fluent.GalleryPanel.Filter"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.GalleryPanel.MinItemsInRow">
            <summary>
            Gets or sets maximum items quantity in row
            </summary>
        </member>
        <member name="F:Fluent.GalleryPanel.MinItemsInRowProperty">
            <summary>Identifies the <see cref="P:Fluent.GalleryPanel.MinItemsInRow"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.GalleryPanel.MaxItemsInRow">
            <summary>
            Gets or sets maximum items quantity in row
            </summary>
        </member>
        <member name="F:Fluent.GalleryPanel.MaxItemsInRowProperty">
            <summary>Identifies the <see cref="P:Fluent.GalleryPanel.MaxItemsInRow"/> dependency property.</summary>
        </member>
        <member name="M:Fluent.GalleryPanel.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="P:Fluent.GalleryPanel.VisualChildrenCount">
            <inheritdoc />
        </member>
        <member name="M:Fluent.GalleryPanel.GetVisualChild(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Fluent.GalleryPanel.SuspendUpdates">
            <summary>
            Suspends updates.
            </summary>
        </member>
        <member name="M:Fluent.GalleryPanel.ResumeUpdates">
            <summary>
            Resumes updates.
            </summary>
        </member>
        <member name="M:Fluent.GalleryPanel.ResumeUpdatesRefresh">
            <summary>
            Resumes updates and calls <see cref="M:Fluent.GalleryPanel.Refresh"/>.
            </summary>
        </member>
        <member name="M:Fluent.GalleryPanel.OnVisualChildrenChanged(System.Windows.DependencyObject,System.Windows.DependencyObject)">
            <inheritdoc />
        </member>
        <member name="M:Fluent.GalleryPanel.MeasureOverride(System.Windows.Size)">
            <inheritdoc />
        </member>
        <member name="M:Fluent.GalleryPanel.ArrangeOverride(System.Windows.Size)">
            <inheritdoc />
        </member>
        <member name="P:Fluent.GalleryPanel.LogicalChildren">
            <inheritdoc />
        </member>
        <member name="T:Fluent.GroupSeparatorMenuItem">
            <summary>
            Represents group separator menu item
            </summary>
        </member>
        <member name="F:Fluent.IconPresenter.IconSizeProperty">
            <summary>Identifies the <see cref="P:Fluent.IconPresenter.IconSize"/> dependency property.</summary>
        </member>
        <member name="F:Fluent.IconPresenter.SmallSizeProperty">
            <summary>Identifies the <see cref="P:Fluent.IconPresenter.SmallSize"/> dependency property.</summary>
        </member>
        <member name="F:Fluent.IconPresenter.MediumSizeProperty">
            <summary>Identifies the <see cref="P:Fluent.IconPresenter.MediumSize"/> dependency property.</summary>
        </member>
        <member name="F:Fluent.IconPresenter.LargeSizeProperty">
            <summary>Identifies the <see cref="P:Fluent.IconPresenter.LargeSize"/> dependency property.</summary>
        </member>
        <member name="F:Fluent.IconPresenter.CustomSizeProperty">
            <summary>Identifies the <see cref="P:Fluent.IconPresenter.CustomSize"/> dependency property.</summary>
        </member>
        <member name="F:Fluent.IconPresenter.SmallIconProperty">
            <summary>Identifies the <see cref="P:Fluent.IconPresenter.SmallIcon"/> dependency property.</summary>
        </member>
        <member name="F:Fluent.IconPresenter.MediumIconProperty">
            <summary>Identifies the <see cref="P:Fluent.IconPresenter.MediumIcon"/> dependency property.</summary>
        </member>
        <member name="F:Fluent.IconPresenter.LargeIconProperty">
            <summary>Identifies the <see cref="P:Fluent.IconPresenter.LargeIcon"/> dependency property.</summary>
        </member>
        <member name="F:Fluent.IconPresenter.OptimalIconProperty">
            <summary>Identifies the <see cref="P:Fluent.IconPresenter.OptimalIcon"/> dependency property.</summary>
        </member>
        <member name="F:Fluent.IconPresenter.CurrentIconSizeSizeProperty">
            <summary>Identifies the <see cref="P:Fluent.IconPresenter.CurrentIconSizeSize"/> dependency property.</summary>
        </member>
        <member name="T:Fluent.InRibbonGallery">
            <summary>
            Represents the In-Ribbon Gallery, a gallery-based control that exposes
            a default subset of items directly in the Ribbon. Any remaining items
            are displayed when a drop-down menu button is clicked
            </summary>
        </member>
        <member name="P:Fluent.InRibbonGallery.Size">
            <inheritdoc />
        </member>
        <member name="F:Fluent.InRibbonGallery.SizeProperty">
            <summary>Identifies the <see cref="P:Fluent.InRibbonGallery.Size"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.InRibbonGallery.SizeDefinition">
            <inheritdoc />
        </member>
        <member name="F:Fluent.InRibbonGallery.SizeDefinitionProperty">
            <summary>Identifies the <see cref="P:Fluent.InRibbonGallery.SizeDefinition"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.InRibbonGallery.SimplifiedSizeDefinition">
            <inheritdoc />
        </member>
        <member name="F:Fluent.InRibbonGallery.SimplifiedSizeDefinitionProperty">
            <summary>Identifies the <see cref="P:Fluent.InRibbonGallery.SimplifiedSizeDefinition"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.InRibbonGallery.KeyTip">
            <inheritdoc />
        </member>
        <member name="F:Fluent.InRibbonGallery.KeyTipProperty">
            <summary>
            Using a DependencyProperty as the backing store for Keys.
            This enables animation, styling, binding, etc...
            </summary>
        </member>
        <member name="P:Fluent.InRibbonGallery.Header">
            <inheritdoc />
        </member>
        <member name="F:Fluent.InRibbonGallery.HeaderProperty">
            <summary>Identifies the <see cref="P:Fluent.InRibbonGallery.Header"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.InRibbonGallery.HeaderTemplate">
            <inheritdoc />
        </member>
        <member name="F:Fluent.InRibbonGallery.HeaderTemplateProperty">
            <summary>Identifies the <see cref="P:Fluent.InRibbonGallery.HeaderTemplate"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.InRibbonGallery.HeaderTemplateSelector">
            <inheritdoc />
        </member>
        <member name="F:Fluent.InRibbonGallery.HeaderTemplateSelectorProperty">
            <summary>Identifies the <see cref="P:Fluent.InRibbonGallery.HeaderTemplateSelector"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.InRibbonGallery.Icon">
            <inheritdoc />
        </member>
        <member name="F:Fluent.InRibbonGallery.IconProperty">
            <summary>Identifies the <see cref="P:Fluent.InRibbonGallery.Icon"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.InRibbonGallery.MinItemsInDropDownRow">
            <summary>
            Min width of the Gallery
            </summary>
        </member>
        <member name="F:Fluent.InRibbonGallery.MinItemsInDropDownRowProperty">
            <summary>Identifies the <see cref="P:Fluent.InRibbonGallery.MinItemsInDropDownRow"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.InRibbonGallery.MaxItemsInDropDownRow">
            <summary>
            Max width of the Gallery
            </summary>
        </member>
        <member name="F:Fluent.InRibbonGallery.MaxItemsInDropDownRowProperty">
            <summary>Identifies the <see cref="P:Fluent.InRibbonGallery.MaxItemsInDropDownRow"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.InRibbonGallery.ItemWidth">
            <summary>
            Gets or sets item width
            </summary>
        </member>
        <member name="F:Fluent.InRibbonGallery.ItemWidthProperty">
            <summary>Identifies the <see cref="P:Fluent.InRibbonGallery.ItemWidth"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.InRibbonGallery.ItemHeight">
            <summary>
            Gets or sets item height
            </summary>
        </member>
        <member name="F:Fluent.InRibbonGallery.ItemHeightProperty">
            <summary>Identifies the <see cref="P:Fluent.InRibbonGallery.ItemHeight"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.InRibbonGallery.GroupBy">
            <summary>
            Gets or sets name of property which
            will use to group items in the Gallery.
            </summary>
        </member>
        <member name="F:Fluent.InRibbonGallery.GroupByProperty">
            <summary>Identifies the <see cref="P:Fluent.InRibbonGallery.GroupBy"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.InRibbonGallery.GroupByAdvanced">
            <summary>
            Gets or sets name of property which
            will use to group items in the Gallery.
            </summary>
        </member>
        <member name="F:Fluent.InRibbonGallery.GroupByAdvancedProperty">
            <summary>Identifies the <see cref="P:Fluent.InRibbonGallery.GroupByAdvanced"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.InRibbonGallery.Orientation">
            <summary>
            Gets or sets orientation of gallery
            </summary>
        </member>
        <member name="F:Fluent.InRibbonGallery.OrientationProperty">
            <summary>Identifies the <see cref="P:Fluent.InRibbonGallery.Orientation"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.InRibbonGallery.Filters">
            <summary>
            Gets collection of filters
            </summary>
        </member>
        <member name="P:Fluent.InRibbonGallery.SelectedFilter">
            <summary>
            Gets or sets selected filter
            </summary>
        </member>
        <member name="F:Fluent.InRibbonGallery.SelectedFilterProperty">
            <summary>Identifies the <see cref="P:Fluent.InRibbonGallery.SelectedFilter"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.InRibbonGallery.SelectedFilterTitle">
            <summary>
            Gets selected filter title
            </summary>
        </member>
        <member name="F:Fluent.InRibbonGallery.SelectedFilterTitleProperty">
            <summary>Identifies the <see cref="P:Fluent.InRibbonGallery.SelectedFilterTitle"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.InRibbonGallery.SelectedFilterGroups">
            <summary>
            Gets selected filter groups
            </summary>
        </member>
        <member name="F:Fluent.InRibbonGallery.SelectedFilterGroupsProperty">
            <summary>Identifies the <see cref="P:Fluent.InRibbonGallery.SelectedFilterGroups"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.InRibbonGallery.HasFilter">
            <summary>
            Gets whether gallery has selected filter
            </summary>
        </member>
        <member name="F:Fluent.InRibbonGallery.HasFilterProperty">
            <summary>Identifies the <see cref="P:Fluent.InRibbonGallery.HasFilter"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.InRibbonGallery.Selectable">
            <summary>
            Gets or sets whether gallery items can be selected
            </summary>
        </member>
        <member name="F:Fluent.InRibbonGallery.SelectableProperty">
            <summary>Identifies the <see cref="P:Fluent.InRibbonGallery.Selectable"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.InRibbonGallery.DropDownPopup">
            <inheritdoc />
        </member>
        <member name="P:Fluent.InRibbonGallery.IsContextMenuOpened">
            <inheritdoc />
        </member>
        <member name="P:Fluent.InRibbonGallery.IsDropDownOpen">
            <inheritdoc />
        </member>
        <member name="F:Fluent.InRibbonGallery.IsDropDownOpenProperty">
            <summary>Identifies the <see cref="P:Fluent.InRibbonGallery.IsDropDownOpen"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.InRibbonGallery.ResizeMode">
            <summary>
            Gets or sets context menu resize mode
            </summary>
        </member>
        <member name="F:Fluent.InRibbonGallery.ResizeModeProperty">
            <summary>Identifies the <see cref="P:Fluent.InRibbonGallery.ResizeMode"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.InRibbonGallery.CanCollapseToButton">
            <summary>
            Gets or sets whether InRibbonGallery
            </summary>
        </member>
        <member name="F:Fluent.InRibbonGallery.CanCollapseToButtonProperty">
            <summary>Identifies the <see cref="P:Fluent.InRibbonGallery.CanCollapseToButton"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.InRibbonGallery.IsCollapsed">
            <summary>
            Gets whether InRibbonGallery is collapsed to button
            </summary>
        </member>
        <member name="F:Fluent.InRibbonGallery.IsCollapsedProperty">
            <summary>Identifies the <see cref="P:Fluent.InRibbonGallery.IsCollapsed"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.InRibbonGallery.LargeIcon">
            <inheritdoc />
        </member>
        <member name="F:Fluent.InRibbonGallery.LargeIconProperty">
            <summary>Identifies the <see cref="P:Fluent.InRibbonGallery.LargeIcon"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.InRibbonGallery.MediumIcon">
            <inheritdoc />
        </member>
        <member name="F:Fluent.InRibbonGallery.MediumIconProperty">
            <summary>Identifies the <see cref="P:Fluent.InRibbonGallery.MediumIcon"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.InRibbonGallery.IsSnapped">
            <summary>
            Snaps / Unsnaps the Visual
            (remove visuals and substitute with freezed image)
            </summary>
        </member>
        <member name="P:Fluent.InRibbonGallery.IsFrozen">
            <summary>
            Defines whether this item is frozen or not because the copy of this item shown in the <see cref="T:Fluent.QuickAccessToolBar"/> has it's dropdown open.
            </summary>
        </member>
        <member name="P:Fluent.InRibbonGallery.Menu">
            <summary>
            Gets or sets menu to show in combo box bottom
            </summary>
        </member>
        <member name="F:Fluent.InRibbonGallery.MenuProperty">
            <summary>Identifies the <see cref="P:Fluent.InRibbonGallery.Menu"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.InRibbonGallery.MaxItemsInRow">
            <summary>
            Gets or sets max count of items in row
            </summary>
        </member>
        <member name="F:Fluent.InRibbonGallery.MaxItemsInRowProperty">
            <summary>Identifies the <see cref="P:Fluent.InRibbonGallery.MaxItemsInRow"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.InRibbonGallery.MinItemsInRow">
            <summary>
            Gets or sets min count of items in row
            </summary>
        </member>
        <member name="F:Fluent.InRibbonGallery.MinItemsInRowProperty">
            <summary>Identifies the <see cref="P:Fluent.InRibbonGallery.MinItemsInRow"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.InRibbonGallery.MaxDropDownHeight">
            <summary>
            Get or sets max height of drop down popup
            </summary>
        </member>
        <member name="F:Fluent.InRibbonGallery.MaxDropDownHeightProperty">
            <summary>Identifies the <see cref="P:Fluent.InRibbonGallery.MaxDropDownHeight"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.InRibbonGallery.MaxDropDownWidth">
            <summary>
            Get or sets max width of drop down popup
            </summary>
        </member>
        <member name="F:Fluent.InRibbonGallery.MaxDropDownWidthProperty">
            <summary>Identifies the <see cref="P:Fluent.InRibbonGallery.MaxDropDownWidth"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.InRibbonGallery.DropDownHeight">
            <summary>
            Gets or sets initial dropdown height
            </summary>
        </member>
        <member name="F:Fluent.InRibbonGallery.DropDownHeightProperty">
            <summary>Identifies the <see cref="P:Fluent.InRibbonGallery.DropDownHeight"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.InRibbonGallery.DropDownWidth">
            <summary>
            Gets or sets initial dropdown width
            </summary>
        </member>
        <member name="F:Fluent.InRibbonGallery.DropDownWidthProperty">
            <summary>Identifies the <see cref="P:Fluent.InRibbonGallery.DropDownWidth"/> dependency property.</summary>
        </member>
        <member name="F:Fluent.InRibbonGallery.GalleryPanelContainerHeightProperty">
            <summary>Identifies the <see cref="P:Fluent.InRibbonGallery.GalleryPanelContainerHeight"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.InRibbonGallery.GalleryPanelContainerHeight">
            <summary>
            Gets or sets the height of the container which hosts the <see cref="T:Fluent.GalleryPanel"/>.
            </summary>
        </member>
        <member name="P:Fluent.InRibbonGallery.IsSimplified">
            <summary>
            Gets or sets whether or not the ribbon is in Simplified mode
            </summary>
        </member>
        <member name="F:Fluent.InRibbonGallery.IsSimplifiedProperty">
            <summary>Identifies the <see cref="P:Fluent.InRibbonGallery.IsSimplified"/> dependency property.</summary>
        </member>
        <member name="F:Fluent.InRibbonGallery.ExpandButtonContentProperty">
            <summary>Identifies the <see cref="P:Fluent.InRibbonGallery.ExpandButtonContent"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.InRibbonGallery.ExpandButtonContent">
            <summary>
            Gets or sets the content for the expand button.
            </summary>
        </member>
        <member name="F:Fluent.InRibbonGallery.ExpandButtonContentTemplateProperty">
            <summary>Identifies the <see cref="P:Fluent.InRibbonGallery.ExpandButtonContentTemplate"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.InRibbonGallery.ExpandButtonContentTemplate">
            <summary>
            Gets or sets the content template for the expand button.
            </summary>
        </member>
        <member name="E:Fluent.InRibbonGallery.Scaled">
            <inheritdoc />
        </member>
        <member name="E:Fluent.InRibbonGallery.DropDownOpened">
            <inheritdoc />
        </member>
        <member name="E:Fluent.InRibbonGallery.DropDownClosed">
            <inheritdoc />
        </member>
        <member name="M:Fluent.InRibbonGallery.#cctor">
            <summary>
            Initializes static members of the <see cref="T:Fluent.InRibbonGallery"/> class.
            </summary>
        </member>
        <member name="M:Fluent.InRibbonGallery.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:Fluent.InRibbonGallery.OnKeyUp(System.Windows.Input.KeyEventArgs)">
            <inheritdoc />
        </member>
        <member name="M:Fluent.InRibbonGallery.OnKeyTipPressed">
            <inheritdoc />
        </member>
        <member name="M:Fluent.InRibbonGallery.OnKeyTipBack">
            <inheritdoc />
        </member>
        <member name="M:Fluent.InRibbonGallery.OnSelectionChanged(System.Windows.Controls.SelectionChangedEventArgs)">
            <inheritdoc />
        </member>
        <member name="M:Fluent.InRibbonGallery.OnApplyTemplate">
            <inheritdoc />
        </member>
        <member name="M:Fluent.InRibbonGallery.OnSizePropertyChanged(Fluent.RibbonControlSize,Fluent.RibbonControlSize)">
            <inheritdoc />
        </member>
        <member name="M:Fluent.InRibbonGallery.GetContainerForItemOverride">
            <inheritdoc />
        </member>
        <member name="M:Fluent.InRibbonGallery.IsItemItsOwnContainerOverride(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:Fluent.InRibbonGallery.OnItemsChanged(System.Collections.Specialized.NotifyCollectionChangedEventArgs)">
            <inheritdoc />
        </member>
        <member name="M:Fluent.InRibbonGallery.OnKeyDown(System.Windows.Input.KeyEventArgs)">
            <inheritdoc />
        </member>
        <member name="M:Fluent.InRibbonGallery.CreateQuickAccessItem">
            <inheritdoc />
        </member>
        <member name="P:Fluent.InRibbonGallery.CanAddToQuickAccessToolBar">
            <inheritdoc />
        </member>
        <member name="F:Fluent.InRibbonGallery.CanAddToQuickAccessToolBarProperty">
            <summary>Identifies the <see cref="P:Fluent.InRibbonGallery.CanAddToQuickAccessToolBar"/> dependency property.</summary>
        </member>
        <member name="M:Fluent.InRibbonGallery.ResetScale">
            <inheritdoc />
        </member>
        <member name="M:Fluent.InRibbonGallery.Enlarge">
            <inheritdoc />
        </member>
        <member name="M:Fluent.InRibbonGallery.Reduce">
            <inheritdoc />
        </member>
        <member name="M:Fluent.InRibbonGallery.Fluent#ISimplifiedStateControl#UpdateSimplifiedState(System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:Fluent.InRibbonGallery.Fluent#ILogicalChildSupport#AddLogicalChild(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:Fluent.InRibbonGallery.Fluent#ILogicalChildSupport#RemoveLogicalChild(System.Object)">
            <inheritdoc />
        </member>
        <member name="P:Fluent.InRibbonGallery.LogicalChildren">
            <inheritdoc />
        </member>
        <member name="M:Fluent.InRibbonGallery.OnCreateAutomationPeer">
            <inheritdoc />
        </member>
        <member name="M:Fluent.InRibbonGallery.ScrollIntoView(System.Object)">
            <summary>
            Causes the object to scroll into view.  If it is not visible, it is aligned either at the top or bottom of the viewport.
            </summary>
        </member>
        <member name="T:Fluent.KeyTip">
            <summary>
            Represents KeyTip control
            </summary>
        </member>
        <member name="F:Fluent.KeyTip.KeysProperty">
            <summary>
            Using a DependencyProperty as the backing store for Keys.
            This enables animation, styling, binding, etc...
            </summary>
        </member>
        <member name="M:Fluent.KeyTip.SetKeys(System.Windows.DependencyObject,System.String)">
            <summary>
            Sets value of attached property Keys for the given element
            </summary>
            <param name="element">The given element</param>
            <param name="value">Value</param>
        </member>
        <member name="M:Fluent.KeyTip.GetKeys(System.Windows.DependencyObject)">
            <summary>
            Gets value of the attached property Keys of the given element
            </summary>
            <param name="element">The given element</param>
        </member>
        <member name="F:Fluent.KeyTip.AutoPlacementProperty">
            <summary>
            Using a DependencyProperty as the backing store for AutoPlacement.
            This enables animation, styling, binding, etc...
            </summary>
        </member>
        <member name="M:Fluent.KeyTip.SetAutoPlacement(System.Windows.DependencyObject,System.Boolean)">
            <summary>
            Sets whether key tip placement is auto
            or defined by alignment and margin properties
            </summary>
            <param name="element">The given element</param>
            <param name="value">Value</param>
        </member>
        <member name="M:Fluent.KeyTip.GetAutoPlacement(System.Windows.DependencyObject)">
            <summary>
            Gets whether key tip placement is auto
            or defined by alignment and margin properties
            </summary>
            <param name="element">The given element</param>
        </member>
        <member name="F:Fluent.KeyTip.HorizontalAlignmentProperty">
            <summary>
            Using a DependencyProperty as the backing store for HorizontalAlignment.
            This enables animation, styling, binding, etc...
            </summary>
        </member>
        <member name="M:Fluent.KeyTip.SetHorizontalAlignment(System.Windows.DependencyObject,System.Windows.HorizontalAlignment)">
            <summary>
            Sets Horizontal Alignment of the key tip
            </summary>
            <param name="element">The given element</param>
            <param name="value">Value</param>
        </member>
        <member name="M:Fluent.KeyTip.GetHorizontalAlignment(System.Windows.DependencyObject)">
            <summary>
            Gets Horizontal alignment of the key tip
            </summary>
            <param name="element">The given element</param>
        </member>
        <member name="M:Fluent.KeyTip.GetVerticalAlignment(System.Windows.DependencyObject)">
            <summary>
            Gets vertical alignment of the key tip
            </summary>
            <param name="element">The given element</param>
        </member>
        <member name="M:Fluent.KeyTip.SetVerticalAlignment(System.Windows.DependencyObject,System.Windows.VerticalAlignment)">
            <summary>
            Sets vertical alignment of the key tip
            </summary>
            <param name="obj">The given element</param>
            <param name="value">Value</param>
        </member>
        <member name="F:Fluent.KeyTip.VerticalAlignmentProperty">
            <summary>
            Using a DependencyProperty as the backing store for VerticalAlignment.
            This enables animation, styling, binding, etc...
            </summary>
        </member>
        <member name="M:Fluent.KeyTip.GetMargin(System.Windows.DependencyObject)">
            <summary>
            Gets margin of the key tip
            </summary>
            <param name="obj">The key tip</param>
            <returns>Margin</returns>
        </member>
        <member name="M:Fluent.KeyTip.SetMargin(System.Windows.DependencyObject,System.Windows.Thickness)">
            <summary>
            Sets margin of the key tip
            </summary>
            <param name="obj">The key tip</param>
            <param name="value">Value</param>
        </member>
        <member name="F:Fluent.KeyTip.MarginProperty">
            <summary>
            Using a DependencyProperty as the backing store for Margin.
            This enables animation, styling, binding, etc...
            </summary>
        </member>
        <member name="T:Fluent.MenuItem">
            <summary>
            Represents menu item
            </summary>
        </member>
        <member name="P:Fluent.MenuItem.Size">
            <inheritdoc />
        </member>
        <member name="F:Fluent.MenuItem.SizeProperty">
            <summary>Identifies the <see cref="P:Fluent.MenuItem.Size"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.MenuItem.SizeDefinition">
            <inheritdoc />
        </member>
        <member name="F:Fluent.MenuItem.SizeDefinitionProperty">
            <summary>Identifies the <see cref="P:Fluent.MenuItem.SizeDefinition"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.MenuItem.KeyTip">
            <inheritdoc />
        </member>
        <member name="F:Fluent.MenuItem.KeyTipProperty">
            <summary>
            Using a DependencyProperty as the backing store for Keys.
            This enables animation, styling, binding, etc...
            </summary>
        </member>
        <member name="P:Fluent.MenuItem.DropDownPopup">
            <inheritdoc />
        </member>
        <member name="P:Fluent.MenuItem.IsContextMenuOpened">
            <inheritdoc />
        </member>
        <member name="P:Fluent.MenuItem.Description">
            <summary>
            Useless property only used in secon level application menu items
            </summary>
        </member>
        <member name="F:Fluent.MenuItem.DescriptionProperty">
            <summary>Identifies the <see cref="P:Fluent.MenuItem.Description"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.MenuItem.IsDropDownOpen">
            <inheritdoc />
        </member>
        <member name="P:Fluent.MenuItem.IsDefinitive">
            <summary>
            Gets or sets whether ribbon control click must close backstage
            </summary>
        </member>
        <member name="F:Fluent.MenuItem.IsDefinitiveProperty">
            <summary>Identifies the <see cref="P:Fluent.MenuItem.IsDefinitive"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.MenuItem.ResizeMode">
            <summary>
            Gets or sets context menu resize mode
            </summary>
        </member>
        <member name="F:Fluent.MenuItem.ResizeModeProperty">
            <summary>Identifies the <see cref="P:Fluent.MenuItem.ResizeMode"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.MenuItem.MaxDropDownHeight">
            <summary>
            Get or sets max height of drop down popup
            </summary>
        </member>
        <member name="F:Fluent.MenuItem.MaxDropDownHeightProperty">
            <summary>Identifies the <see cref="P:Fluent.MenuItem.MaxDropDownHeight"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.MenuItem.IsSplit">
            <summary>
            Gets or sets a value indicating whether menu item is split.
            </summary>
        </member>
        <member name="F:Fluent.MenuItem.IsSplitProperty">
            <summary>Identifies the <see cref="P:Fluent.MenuItem.IsSplit"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.MenuItem.GroupName">
            <inheritdoc />
        </member>
        <member name="P:Fluent.MenuItem.Fluent#IToggleButton#IsChecked">
            <inheritdoc />
        </member>
        <member name="F:Fluent.MenuItem.GroupNameProperty">
            <summary>Identifies the <see cref="P:Fluent.MenuItem.GroupName"/> dependency property.</summary>
        </member>
        <member name="E:Fluent.MenuItem.DropDownOpened">
            <inheritdoc />
        </member>
        <member name="E:Fluent.MenuItem.DropDownClosed">
            <inheritdoc />
        </member>
        <member name="M:Fluent.MenuItem.#cctor">
            <summary>
            Initializes static members of the <see cref="T:Fluent.MenuItem"/> class.
            </summary>
        </member>
        <member name="M:Fluent.MenuItem.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Fluent.MenuItem"/> class.
            </summary>
        </member>
        <member name="M:Fluent.MenuItem.OnMouseWheel(System.Windows.Input.MouseWheelEventArgs)">
            <inheritdoc />
        </member>
        <member name="F:Fluent.MenuItem.RecognizesAccessKeyProperty">
            <summary>Identifies the <see cref="P:Fluent.MenuItem.RecognizesAccessKey"/> dependency property.</summary>
        </member>
        <member name="M:Fluent.MenuItem.SetRecognizesAccessKey(System.Windows.DependencyObject,System.Boolean)">
            <summary>Helper for setting <see cref="F:Fluent.MenuItem.RecognizesAccessKeyProperty"/> on <paramref name="element"/>.</summary>
            <param name="element"><see cref="T:System.Windows.DependencyObject"/> to set <see cref="F:Fluent.MenuItem.RecognizesAccessKeyProperty"/> on.</param>
            <param name="value">RecognizesAccessKey property value.</param>
        </member>
        <member name="M:Fluent.MenuItem.GetRecognizesAccessKey(System.Windows.DependencyObject)">
            <summary>Helper for getting <see cref="F:Fluent.MenuItem.RecognizesAccessKeyProperty"/> from <paramref name="element"/>.</summary>
            <param name="element"><see cref="T:System.Windows.DependencyObject"/> to read <see cref="F:Fluent.MenuItem.RecognizesAccessKeyProperty"/> from.</param>
            <returns>RecognizesAccessKey property value.</returns>
        </member>
        <member name="P:Fluent.MenuItem.RecognizesAccessKey">
            <summary>
            Defines if access keys should be recognized.
            </summary>
        </member>
        <member name="M:Fluent.MenuItem.CreateQuickAccessItem">
            <inheritdoc />
        </member>
        <member name="M:Fluent.MenuItem.OnQuickAccessOpened(System.Object,System.EventArgs)">
            <summary>
            Handles quick access button drop down menu opened
            </summary>
        </member>
        <member name="M:Fluent.MenuItem.OnQuickAccessMenuClosedOrUnloaded(System.Object,System.EventArgs)">
            <summary>
            Handles quick access button drop down menu closed
            </summary>
        </member>
        <member name="P:Fluent.MenuItem.CanAddToQuickAccessToolBar">
            <inheritdoc />
        </member>
        <member name="F:Fluent.MenuItem.CanAddToQuickAccessToolBarProperty">
            <summary>Identifies the <see cref="P:Fluent.MenuItem.CanAddToQuickAccessToolBar"/> dependency property.</summary>
        </member>
        <member name="M:Fluent.MenuItem.OnKeyTipPressed">
            <inheritdoc />
        </member>
        <member name="M:Fluent.MenuItem.OnKeyTipBack">
            <inheritdoc />
        </member>
        <member name="M:Fluent.MenuItem.IsItemItsOwnContainerOverride(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:Fluent.MenuItem.GetContainerForItemOverride">
            <inheritdoc />
        </member>
        <member name="P:Fluent.MenuItem.LogicalParent">
            <summary>
            Returns logical parent; either Parent or ItemsControlFromItemContainer(this).
            </summary>
            <remarks>
            Copied from <see cref="T:System.Windows.Controls.MenuItem"/>.
            </remarks>
        </member>
        <member name="M:Fluent.MenuItem.OnIsKeyboardFocusedChanged(System.Windows.DependencyPropertyChangedEventArgs)">
            <inheritdoc />
        </member>
        <member name="M:Fluent.MenuItem.OnMouseEnter(System.Windows.Input.MouseEventArgs)">
            <inheritdoc />
        </member>
        <member name="M:Fluent.MenuItem.OnMouseLeave(System.Windows.Input.MouseEventArgs)">
            <inheritdoc />
        </member>
        <member name="M:Fluent.MenuItem.OnContextMenuOpening(System.Windows.Controls.ContextMenuEventArgs)">
            <inheritdoc />
        </member>
        <member name="M:Fluent.MenuItem.OnContextMenuClosing(System.Windows.Controls.ContextMenuEventArgs)">
            <inheritdoc />
        </member>
        <member name="M:Fluent.MenuItem.OnMouseLeftButtonUp(System.Windows.Input.MouseButtonEventArgs)">
            <inheritdoc />
        </member>
        <member name="M:Fluent.MenuItem.OnClick">
            <inheritdoc />
        </member>
        <member name="M:Fluent.MenuItem.OnApplyTemplate">
            <inheritdoc />
        </member>
        <member name="M:Fluent.MenuItem.OnKeyDown(System.Windows.Input.KeyEventArgs)">
            <inheritdoc />
        </member>
        <member name="M:Fluent.MenuItem.Fluent#ILogicalChildSupport#AddLogicalChild(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:Fluent.MenuItem.Fluent#ILogicalChildSupport#RemoveLogicalChild(System.Object)">
            <inheritdoc />
        </member>
        <member name="P:Fluent.MenuItem.LogicalChildren">
            <inheritdoc />
        </member>
        <member name="T:Fluent.IQuickAccessItemProvider">
            <summary>
            This interface must be implemented for controls
            which are intended to insert to quick access toolbar
            </summary>
        </member>
        <member name="M:Fluent.IQuickAccessItemProvider.CreateQuickAccessItem">
            <summary>
            Gets control which represents shortcut item.
            This item MUST be syncronized with the original
            and send command to original one control.
            </summary>
            <returns>Control which represents shortcut item</returns>
        </member>
        <member name="P:Fluent.IQuickAccessItemProvider.CanAddToQuickAccessToolBar">
            <summary>
            Gets or sets a value indicating whether control can be added to quick access toolbar
            </summary>
        </member>
        <member name="T:Fluent.QuickAccessMenuItem">
            <summary>
            Peresents quick access shortcut to another control
            </summary>
        </member>
        <member name="M:Fluent.QuickAccessMenuItem.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="P:Fluent.QuickAccessMenuItem.Target">
            <summary>
            Gets or sets shortcut to the target control
            </summary>
        </member>
        <member name="F:Fluent.QuickAccessMenuItem.TargetProperty">
            <summary>Identifies the <see cref="P:Fluent.QuickAccessMenuItem.Target"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.QuickAccessMenuItem.LogicalChildren">
            <inheritdoc />
        </member>
        <member name="T:Fluent.QuickAccessItemsProvider">
            <summary>
            The class responds to mine controls for QuickAccessToolBar
            </summary>
        </member>
        <member name="M:Fluent.QuickAccessItemsProvider.IsSupported(System.Windows.UIElement)">
            <summary>
            Determines whether the given control can provide a quick access toolbar item
            </summary>
            <param name="element">Control</param>
            <returns>True if this control is able to provide
            a quick access toolbar item, false otherwise</returns>
        </member>
        <member name="M:Fluent.QuickAccessItemsProvider.GetQuickAccessItem(System.Windows.UIElement)">
            <summary>
            Gets control which represents quick access toolbar item
            </summary>
            <param name="element">Host control</param>
            <returns>Control which represents quick access toolbar item</returns>
        </member>
        <member name="M:Fluent.QuickAccessItemsProvider.FindSupportedControl(System.Windows.Media.Visual,System.Windows.Point)">
            <summary>
            Finds the top supported control
            </summary>
        </member>
        <member name="T:Fluent.QuickAccessToolBar">
            <summary>
            Represents quick access toolbar
            </summary>
        </member>
        <member name="E:Fluent.QuickAccessToolBar.ItemsChanged">
            <summary>
            Occured when items are added or removed from Quick Access toolbar
            </summary>
        </member>
        <member name="P:Fluent.QuickAccessToolBar.Items">
            <summary>
            Gets items collection
            </summary>
        </member>
        <member name="P:Fluent.QuickAccessToolBar.HasOverflowItems">
            <summary>
            Gets whether QuickAccessToolBar has overflow items
            </summary>
        </member>
        <member name="F:Fluent.QuickAccessToolBar.HasOverflowItemsProperty">
            <summary>Identifies the <see cref="P:Fluent.QuickAccessToolBar.HasOverflowItems"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.QuickAccessToolBar.QuickAccessItems">
            <summary>
            Gets quick access menu items
            </summary>
        </member>
        <member name="M:Fluent.QuickAccessToolBar.OnQuickAccessItemsCollectionChanged(System.Object,System.Collections.Specialized.NotifyCollectionChangedEventArgs)">
            <summary>
            Handles collection of quick access menu items changes
            </summary>
            <param name="sender">Sender</param>
            <param name="e">The event data</param>
        </member>
        <member name="P:Fluent.QuickAccessToolBar.ShowAboveRibbon">
            <summary>
            Gets or sets whether quick access toolbar showes above ribbon
            </summary>
        </member>
        <member name="F:Fluent.QuickAccessToolBar.ShowAboveRibbonProperty">
            <summary>Identifies the <see cref="P:Fluent.QuickAccessToolBar.ShowAboveRibbon"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.QuickAccessToolBar.CanQuickAccessLocationChanging">
            <summary>
            Gets or sets whether user can change location of QAT
            </summary>
        </member>
        <member name="F:Fluent.QuickAccessToolBar.CanQuickAccessLocationChangingProperty">
            <summary>Identifies the <see cref="P:Fluent.QuickAccessToolBar.CanQuickAccessLocationChanging"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.QuickAccessToolBar.IsMenuDropDownVisible">
            <summary>
            Gets or sets whether the Menu-DropDown is visible or not.
            </summary>
        </member>
        <member name="F:Fluent.QuickAccessToolBar.IsMenuDropDownVisibleProperty">
            <summary>Identifies the <see cref="P:Fluent.QuickAccessToolBar.IsMenuDropDownVisible"/> dependency property.</summary>
        </member>
        <member name="M:Fluent.QuickAccessToolBar.#cctor">
            <summary>
            Static constructor
            </summary>
        </member>
        <member name="M:Fluent.QuickAccessToolBar.#ctor">
            <summary>
            Creates a new instance.
            </summary>
        </member>
        <member name="M:Fluent.QuickAccessToolBar.OnApplyTemplate">
            <inheritdoc />
        </member>
        <member name="M:Fluent.QuickAccessToolBar.OnShowBelowClick(System.Object,System.Windows.RoutedEventArgs)">
            <summary>
            Handles show below menu item click
            </summary>
            <param name="sender">Sender</param>
            <param name="e">The event data</param>
        </member>
        <member name="M:Fluent.QuickAccessToolBar.OnShowAboveClick(System.Object,System.Windows.RoutedEventArgs)">
            <summary>
            Handles show above menu item click
            </summary>
            <param name="sender">Sender</param>
            <param name="e">The event data</param>
        </member>
        <member name="M:Fluent.QuickAccessToolBar.MeasureOverride(System.Windows.Size)">
            <inheritdoc />
        </member>
        <member name="M:Fluent.QuickAccessToolBar.UpdateHasOverflowItems">
            <summary>
            We have to use this function because setting a <see cref="T:System.Windows.DependencyProperty"/> very frequently is quite expensive
            </summary>
        </member>
        <member name="M:Fluent.QuickAccessToolBar.Refresh">
            <summary>
            First calls <see cref="M:System.Windows.UIElement.InvalidateMeasure"/> and then <see cref="M:Fluent.QuickAccessToolBar.InvalidateMeasureOfTitleBar"/>
            </summary>
        </member>
        <member name="P:Fluent.QuickAccessToolBar.UpdateKeyTipsAction">
            <summary>
            Gets or sets a custom action to generate KeyTips for items in this control.
            </summary>
        </member>
        <member name="F:Fluent.QuickAccessToolBar.UpdateKeyTipsActionProperty">
            <summary>Identifies the <see cref="P:Fluent.QuickAccessToolBar.UpdateKeyTipsAction"/> dependency property.</summary>
        </member>
        <member name="M:Fluent.QuickAccessToolBar.OnCreateAutomationPeer">
            <inheritdoc />
        </member>
        <member name="M:Fluent.QuickAccessToolBar.Fluent#ILogicalChildSupport#AddLogicalChild(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:Fluent.QuickAccessToolBar.Fluent#ILogicalChildSupport#RemoveLogicalChild(System.Object)">
            <inheritdoc />
        </member>
        <member name="P:Fluent.QuickAccessToolBar.LogicalChildren">
            <inheritdoc />
        </member>
        <member name="T:Fluent.RadioButton">
            <summary>
            Represents Fluent UI specific RadioButton
            </summary>
        </member>
        <member name="P:Fluent.RadioButton.Size">
            <inheritdoc />
        </member>
        <member name="F:Fluent.RadioButton.SizeProperty">
            <summary>Identifies the <see cref="P:Fluent.RadioButton.Size"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.RadioButton.SizeDefinition">
            <inheritdoc />
        </member>
        <member name="F:Fluent.RadioButton.SizeDefinitionProperty">
            <summary>Identifies the <see cref="P:Fluent.RadioButton.SizeDefinition"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.RadioButton.SimplifiedSizeDefinition">
            <inheritdoc />
        </member>
        <member name="F:Fluent.RadioButton.SimplifiedSizeDefinitionProperty">
            <summary>Identifies the <see cref="P:Fluent.RadioButton.SimplifiedSizeDefinition"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.RadioButton.KeyTip">
            <inheritdoc />
        </member>
        <member name="F:Fluent.RadioButton.KeyTipProperty">
            <summary>
            Using a DependencyProperty as the backing store for Keys.
            This enables animation, styling, binding, etc...
            </summary>
        </member>
        <member name="P:Fluent.RadioButton.Header">
            <inheritdoc />
        </member>
        <member name="F:Fluent.RadioButton.HeaderProperty">
            <summary>Identifies the <see cref="P:Fluent.RadioButton.Header"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.RadioButton.HeaderTemplate">
            <inheritdoc />
        </member>
        <member name="F:Fluent.RadioButton.HeaderTemplateProperty">
            <summary>Identifies the <see cref="P:Fluent.RadioButton.HeaderTemplate"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.RadioButton.HeaderTemplateSelector">
            <inheritdoc />
        </member>
        <member name="F:Fluent.RadioButton.HeaderTemplateSelectorProperty">
            <summary>Identifies the <see cref="P:Fluent.RadioButton.HeaderTemplateSelector"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.RadioButton.Icon">
            <inheritdoc />
        </member>
        <member name="F:Fluent.RadioButton.IconProperty">
            <summary>Identifies the <see cref="P:Fluent.RadioButton.Icon"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.RadioButton.LargeIcon">
            <inheritdoc />
        </member>
        <member name="F:Fluent.RadioButton.LargeIconProperty">
            <summary>Identifies the <see cref="P:Fluent.RadioButton.LargeIcon"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.RadioButton.MediumIcon">
            <inheritdoc />
        </member>
        <member name="F:Fluent.RadioButton.MediumIconProperty">
            <summary>Identifies the <see cref="P:Fluent.RadioButton.MediumIcon"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.RadioButton.IsSimplified">
            <summary>
            Gets or sets whether or not the ribbon is in Simplified mode
            </summary>
        </member>
        <member name="F:Fluent.RadioButton.IsSimplifiedProperty">
            <summary>Identifies the <see cref="P:Fluent.RadioButton.IsSimplified"/> dependency property.</summary>
        </member>
        <member name="M:Fluent.RadioButton.#cctor">
            <summary>
            Static constructor
            </summary>
        </member>
        <member name="M:Fluent.RadioButton.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:Fluent.RadioButton.CreateQuickAccessItem">
            <inheritdoc />
        </member>
        <member name="P:Fluent.RadioButton.CanAddToQuickAccessToolBar">
            <inheritdoc />
        </member>
        <member name="F:Fluent.RadioButton.CanAddToQuickAccessToolBarProperty">
            <summary>Identifies the <see cref="P:Fluent.RadioButton.CanAddToQuickAccessToolBar"/> dependency property.</summary>
        </member>
        <member name="M:Fluent.RadioButton.OnKeyTipPressed">
            <inheritdoc />
        </member>
        <member name="M:Fluent.RadioButton.OnKeyTipBack">
            <inheritdoc />
        </member>
        <member name="M:Fluent.RadioButton.Fluent#ISimplifiedStateControl#UpdateSimplifiedState(System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:Fluent.RadioButton.Fluent#ILogicalChildSupport#AddLogicalChild(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:Fluent.RadioButton.Fluent#ILogicalChildSupport#RemoveLogicalChild(System.Object)">
            <inheritdoc />
        </member>
        <member name="P:Fluent.RadioButton.LogicalChildren">
            <inheritdoc />
        </member>
        <member name="M:Fluent.RadioButton.OnCreateAutomationPeer">
            <inheritdoc />
        </member>
        <member name="T:Fluent.ResizeableContentControl">
            <inheritdoc />
        </member>
        <member name="P:Fluent.ResizeableContentControl.ResizeMode">
            <summary>
            Gets or sets context menu resize mode
            </summary>
        </member>
        <member name="F:Fluent.ResizeableContentControl.ResizeModeProperty">
            <summary>Identifies the <see cref="P:Fluent.ResizeableContentControl.ResizeMode"/> dependency property.</summary>
        </member>
        <member name="M:Fluent.ResizeableContentControl.OnApplyTemplate">
            <inheritdoc />
        </member>
        <member name="P:Fluent.ResizeableContentControl.IsMouseOverResizeThumbs">
            <summary>
            Gets whether the mouse is over any of the resize thumbs.
            </summary>
        </member>
        <member name="T:Fluent.Ribbon">
            <summary>
            Represents the main Ribbon control which consists of multiple tabs, each of which
            containing groups of controls.  The Ribbon also provides improved context
            menus, enhanced screen tips, and keyboard shortcuts.
            </summary>
        </member>
        <member name="P:Fluent.Ribbon.RibbonStateStorage">
            <summary>
            Gets the current instance for storing the state of this control.
            </summary>
        </member>
        <member name="M:Fluent.Ribbon.CreateRibbonStateStorage">
            <summary>
            Create a new instance for storing the state of this control.
            </summary>
            <returns>Instance of a state storage class.</returns>
        </member>
        <member name="F:Fluent.Ribbon.MinimalVisibleWidth">
            <summary>
            Minimal width of ribbon parent window
            </summary>
        </member>
        <member name="F:Fluent.Ribbon.MinimalVisibleHeight">
            <summary>
            Minimal height of ribbon parent window
            </summary>
        </member>
        <member name="F:Fluent.Ribbon.IsDefaultContextMenuEnabledProperty">
            <summary>Identifies the <see cref="P:Fluent.Ribbon.IsDefaultContextMenuEnabled"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.Ribbon.IsDefaultContextMenuEnabled">
            <summary>
            Gets or sets whether the default context menu should be enabled/used.
            </summary>
        </member>
        <member name="P:Fluent.Ribbon.RibbonContextMenu">
            <summary>
            Context menu for ribbon in current thread
            </summary>
        </member>
        <member name="M:Fluent.Ribbon.OnContextMenuOpening(System.Windows.Controls.ContextMenuEventArgs)">
            <inheritdoc />
        </member>
        <member name="M:Fluent.Ribbon.OnContextMenuClosing(System.Windows.Controls.ContextMenuEventArgs)">
            <inheritdoc />
        </member>
        <member name="E:Fluent.Ribbon.SelectedTabChanged">
            <summary>
            Occurs when selected tab has been changed (be aware that SelectedTab can be null)
            </summary>
        </member>
        <member name="E:Fluent.Ribbon.CustomizeTheRibbon">
            <summary>
            Occurs when customize the ribbon
            </summary>
        </member>
        <member name="E:Fluent.Ribbon.CustomizeQuickAccessToolbar">
            <summary>
            Occurs when customize quick access toolbar
            </summary>
        </member>
        <member name="E:Fluent.Ribbon.IsMinimizedChanged">
            <summary>
            Occurs when IsMinimized property is changing
            </summary>
        </member>
        <member name="E:Fluent.Ribbon.IsCollapsedChanged">
            <summary>
            Occurs when IsCollapsed property is changing
            </summary>
        </member>
        <member name="P:Fluent.Ribbon.Menu">
            <summary>
            Gets or sets file menu control (can be application menu button, backstage button and so on)
            </summary>
        </member>
        <member name="F:Fluent.Ribbon.MenuProperty">
            <summary>Identifies the <see cref="P:Fluent.Ribbon.Menu"/> dependency property.</summary>
        </member>
        <member name="F:Fluent.Ribbon.IsBackstageOrStartScreenOpenProperty">
            <summary>Identifies the <see cref="P:Fluent.Ribbon.IsBackstageOrStartScreenOpen"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.Ribbon.IsBackstageOrStartScreenOpen">
            <summary>
            Defines if the backstage or startscreen is currently open or not.
            </summary>
        </member>
        <member name="P:Fluent.Ribbon.StartScreen">
            <summary>
            Property for defining the start screen.
            </summary>
        </member>
        <member name="F:Fluent.Ribbon.StartScreenProperty">
            <summary>Identifies the <see cref="P:Fluent.Ribbon.StartScreen"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.Ribbon.QuickAccessToolBar">
            <summary>
            Property for defining the QuickAccessToolBar.
            </summary>
        </member>
        <member name="F:Fluent.Ribbon.QuickAccessToolBarProperty">
            <summary>Identifies the <see cref="P:Fluent.Ribbon.QuickAccessToolBar"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.Ribbon.TabControl">
            <summary>
            Property for defining the TabControl.
            </summary>
        </member>
        <member name="F:Fluent.Ribbon.TabControlProperty">
            <summary>Identifies the <see cref="P:Fluent.Ribbon.TabControl"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.Ribbon.IsSimplified">
            <summary>
            Gets or sets whether or not the ribbon is in Simplified mode
            </summary>
        </member>
        <member name="F:Fluent.Ribbon.IsSimplifiedProperty">
            <summary>Identifies the <see cref="P:Fluent.Ribbon.IsSimplified"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.Ribbon.SelectedTabItem">
            <summary>
            Gets or sets selected tab item
            </summary>
        </member>
        <member name="F:Fluent.Ribbon.SelectedTabItemProperty">
            <summary>Identifies the <see cref="P:Fluent.Ribbon.SelectedTabItem"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.Ribbon.SelectedTabIndex">
            <summary>
            Gets or sets selected tab index
            </summary>
        </member>
        <member name="F:Fluent.Ribbon.SelectedTabIndexProperty">
            <summary>Identifies the <see cref="P:Fluent.Ribbon.SelectedTabIndex"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.Ribbon.FirstVisibleItem">
            <summary>
            Gets the first visible TabItem
            </summary>
        </member>
        <member name="P:Fluent.Ribbon.LastVisibleItem">
            <summary>
            Gets the last visible TabItem
            </summary>
        </member>
        <member name="P:Fluent.Ribbon.QuickAccessElements">
            <summary>
            Gets currently active quick access elements.
            </summary>
        </member>
        <member name="M:Fluent.Ribbon.GetQuickAccessElements">
            <summary>
            Gets a copy of currently active quick access elements.
            </summary>
        </member>
        <member name="P:Fluent.Ribbon.TitleBar">
            <summary>
            Gets ribbon titlebar
            </summary>
        </member>
        <member name="F:Fluent.Ribbon.TitleBarProperty">
            <summary>Identifies the <see cref="P:Fluent.Ribbon.TitleBar"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.Ribbon.ShowQuickAccessToolBarAboveRibbon">
            <summary>
            Gets or sets whether quick access toolbar showes above ribbon
            </summary>
        </member>
        <member name="F:Fluent.Ribbon.ShowQuickAccessToolBarAboveRibbonProperty">
            <summary>Identifies the <see cref="P:Fluent.Ribbon.ShowQuickAccessToolBarAboveRibbon"/> dependency property.</summary>
        </member>
        <member name="M:Fluent.Ribbon.OnShowQuickAccessToolBarAboveRibbonChanged(System.Windows.DependencyObject,System.Windows.DependencyPropertyChangedEventArgs)">
            <summary>
            Handles ShowQuickAccessToolBarAboveRibbon property changed
            </summary>
            <param name="d">Object</param>
            <param name="e">The event data</param>
        </member>
        <member name="P:Fluent.Ribbon.QuickAccessToolBarHeight">
            <summary>
            Gets or sets the height which is used to render the window title.
            </summary>
        </member>
        <member name="F:Fluent.Ribbon.QuickAccessToolBarHeightProperty">
            <summary>Identifies the <see cref="P:Fluent.Ribbon.QuickAccessToolBarHeight"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.Ribbon.ContextualGroups">
            <summary>
            Gets collection of contextual tab groups
            </summary>
        </member>
        <member name="P:Fluent.Ribbon.Tabs">
            <summary>
            gets collection of ribbon tabs
            </summary>
        </member>
        <member name="M:Fluent.Ribbon.OnTabItemsCollectionChanged(System.Object,System.Collections.Specialized.NotifyCollectionChangedEventArgs)">
            <summary>
            Handles collection of ribbon tab items changes
            </summary>
            <param name="sender">Sender</param>
            <param name="e">The event data</param>
        </member>
        <member name="P:Fluent.Ribbon.ToolBarItems">
            <summary>
            Gets collection of toolbar items
            </summary>
        </member>
        <member name="P:Fluent.Ribbon.QuickAccessItems">
            <summary>
            Gets collection of quick access menu items
            </summary>
        </member>
        <member name="M:Fluent.Ribbon.OnQuickAccessItemsCollectionChanged(System.Object,System.Collections.Specialized.NotifyCollectionChangedEventArgs)">
            <summary>
            Handles collection of quick access menu items changes
            </summary>
            <param name="sender">Sender</param>
            <param name="e">The event data</param>
        </member>
        <member name="P:Fluent.Ribbon.CanCustomizeQuickAccessToolBar">
            <summary>
            Gets or sets whether Customize Quick Access Toolbar menu item is shown
            </summary>
        </member>
        <member name="F:Fluent.Ribbon.CanCustomizeQuickAccessToolBarProperty">
            <summary>Identifies the <see cref="P:Fluent.Ribbon.CanCustomizeQuickAccessToolBar"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.Ribbon.CanCustomizeQuickAccessToolBarItems">
            <summary>
            Gets or sets whether items can be added or removed from the quick access toolbar by users.
            </summary>
        </member>
        <member name="F:Fluent.Ribbon.CanCustomizeQuickAccessToolBarItemsProperty">
            <summary>Identifies the <see cref="P:Fluent.Ribbon.CanCustomizeQuickAccessToolBarItems"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.Ribbon.IsQuickAccessToolBarMenuDropDownVisible">
            <summary>
            Gets or sets whether the QAT Menu-DropDown is visible or not.
            </summary>
        </member>
        <member name="F:Fluent.Ribbon.IsQuickAccessToolBarMenuDropDownVisibleProperty">
            <summary>Identifies the <see cref="P:Fluent.Ribbon.IsQuickAccessToolBarMenuDropDownVisible"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.Ribbon.CanCustomizeRibbon">
            <summary>
            Gets or sets whether Customize Ribbon menu item is shown
            </summary>
        </member>
        <member name="F:Fluent.Ribbon.CanCustomizeRibbonProperty">
            <summary>Identifies the <see cref="P:Fluent.Ribbon.CanCustomizeRibbon"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.Ribbon.CanMinimize">
            <summary>
            Gets or sets whether ribbon can be minimized
            </summary>
        </member>
        <member name="P:Fluent.Ribbon.IsMinimized">
            <summary>
            Gets or sets whether ribbon is minimized
            </summary>
        </member>
        <member name="F:Fluent.Ribbon.IsMinimizedProperty">
            <summary>Identifies the <see cref="P:Fluent.Ribbon.IsMinimized"/> dependency property.</summary>
        </member>
        <member name="F:Fluent.Ribbon.CanMinimizeProperty">
            <summary>Identifies the <see cref="P:Fluent.Ribbon.CanMinimize"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.Ribbon.CanUseSimplified">
            <summary>
            Gets or sets whether ribbon can be switched
            </summary>
        </member>
        <member name="F:Fluent.Ribbon.CanUseSimplifiedProperty">
            <summary>Identifies the <see cref="P:Fluent.Ribbon.CanUseSimplified"/> dependency property.</summary>
        </member>
        <member name="F:Fluent.Ribbon.IsDisplayOptionsButtonVisibleProperty">
            <summary>Identifies the <see cref="P:Fluent.Ribbon.IsDisplayOptionsButtonVisible"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.Ribbon.IsDisplayOptionsButtonVisible">
            <summary>
            Defines whether display options button is visible or not.
            </summary>
        </member>
        <member name="P:Fluent.Ribbon.ContentGapHeight">
            <summary>
            Gets or sets the height of the gap between the ribbon and the regular window content
            </summary>
        </member>
        <member name="F:Fluent.Ribbon.ContentGapHeightProperty">
            <summary>Identifies the <see cref="P:Fluent.Ribbon.ContentGapHeight"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.Ribbon.ContentHeight">
            <summary>
            Gets or sets the height of the ribbon content area
            </summary>
        </member>
        <member name="F:Fluent.Ribbon.ContentHeightProperty">
            <summary>Identifies the <see cref="P:Fluent.Ribbon.ContentHeight"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.Ribbon.IsCollapsed">
            <summary>
            Gets whether ribbon is collapsed
            </summary>
        </member>
        <member name="F:Fluent.Ribbon.IsCollapsedProperty">
            <summary>Identifies the <see cref="P:Fluent.Ribbon.IsCollapsed"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.Ribbon.IsAutomaticCollapseEnabled">
            <summary>
            Defines if the Ribbon should automatically set <see cref="P:Fluent.Ribbon.IsCollapsed"/> when the width or height of the owner window drop under <see cref="F:Fluent.Ribbon.MinimalVisibleWidth"/> or <see cref="F:Fluent.Ribbon.MinimalVisibleHeight"/>
            </summary>
        </member>
        <member name="F:Fluent.Ribbon.IsAutomaticCollapseEnabledProperty">
            <summary>Identifies the <see cref="P:Fluent.Ribbon.IsAutomaticCollapseEnabled"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.Ribbon.IsQuickAccessToolBarVisible">
            <summary>
            Gets or sets whether QAT is visible
            </summary>
        </member>
        <member name="F:Fluent.Ribbon.IsQuickAccessToolBarVisibleProperty">
            <summary>Identifies the <see cref="P:Fluent.Ribbon.IsQuickAccessToolBarVisible"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.Ribbon.CanQuickAccessLocationChanging">
            <summary>
            Gets or sets whether user can change location of QAT
            </summary>
        </member>
        <member name="F:Fluent.Ribbon.CanQuickAccessLocationChangingProperty">
            <summary>Identifies the <see cref="P:Fluent.Ribbon.CanQuickAccessLocationChanging"/> dependency property.</summary>
        </member>
        <member name="F:Fluent.Ribbon.AreTabHeadersVisibleProperty">
            <summary>Identifies the <see cref="P:Fluent.Ribbon.AreTabHeadersVisible"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.Ribbon.AreTabHeadersVisible">
            <summary>
            Defines whether tab headers are visible or not.
            </summary>
        </member>
        <member name="F:Fluent.Ribbon.IsToolBarVisibleProperty">
            <summary>Identifies the <see cref="P:Fluent.Ribbon.IsToolBarVisible"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.Ribbon.IsToolBarVisible">
            <summary>
            Defines whether the toolbar is visible or not.
            </summary>
        </member>
        <member name="F:Fluent.Ribbon.IsMouseWheelScrollingEnabledProperty">
            <summary>Identifies the <see cref="P:Fluent.Ribbon.IsMouseWheelScrollingEnabled"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.Ribbon.IsMouseWheelScrollingEnabled">
            <summary>
            Defines whether scrolling by mouse wheel on the tab container area to cycle tabs is enabled or not.
            </summary>
        </member>
        <member name="F:Fluent.Ribbon.IsMouseWheelScrollingEnabledEverywhereProperty">
            <summary>Identifies the <see cref="P:Fluent.Ribbon.IsMouseWheelScrollingEnabledEverywhere"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.Ribbon.IsMouseWheelScrollingEnabledEverywhere">
            <summary>
            Defines whether scrolling by mouse wheel always cycles selected tab, also outside the tab container area.
            </summary>
        </member>
        <member name="P:Fluent.Ribbon.AreAnyKeyTipsVisible">
            <summary>
            Checks if any keytips are visible.
            </summary>
        </member>
        <member name="F:Fluent.Ribbon.IsKeyTipHandlingEnabledProperty">
            <summary>Identifies the <see cref="P:Fluent.Ribbon.IsKeyTipHandlingEnabled"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.Ribbon.IsKeyTipHandlingEnabled">
            <summary>
            Defines whether handling of key tips is enabled or not.
            </summary>
        </member>
        <member name="P:Fluent.Ribbon.KeyTipKeys">
            <summary>
            Defines the keys that are used to activate the key tips.
            </summary>
        </member>
        <member name="F:Fluent.Ribbon.AddToQuickAccessCommand">
            <summary>
            Gets add to quick access toolbar command
            </summary>
        </member>
        <member name="F:Fluent.Ribbon.RemoveFromQuickAccessCommand">
            <summary>
            Gets remove from quick access command
            </summary>
        </member>
        <member name="F:Fluent.Ribbon.ShowQuickAccessAboveCommand">
            <summary>
            Gets show quick access above command
            </summary>
        </member>
        <member name="F:Fluent.Ribbon.ShowQuickAccessBelowCommand">
            <summary>
            Gets show quick access below command
            </summary>
        </member>
        <member name="F:Fluent.Ribbon.ToggleMinimizeTheRibbonCommand">
            <summary>
            Gets toggle ribbon minimize command
            </summary>
        </member>
        <member name="F:Fluent.Ribbon.SwitchToTheClassicRibbonCommand">
            <summary>
            Gets Switch to classic ribbon command
            </summary>
        </member>
        <member name="F:Fluent.Ribbon.SwitchToTheSimplifiedRibbonCommand">
            <summary>
            Gets Switch to simplified ribbon command
            </summary>
        </member>
        <member name="F:Fluent.Ribbon.CustomizeQuickAccessToolbarCommand">
            <summary>
            Gets customize quick access toolbar command
            </summary>
        </member>
        <member name="F:Fluent.Ribbon.CustomizeTheRibbonCommand">
            <summary>
            Gets customize the ribbon command
            </summary>
        </member>
        <member name="M:Fluent.Ribbon.#cctor">
            <summary>
            Initializes static members of the <see cref="T:Fluent.Ribbon"/> class.
            </summary>
        </member>
        <member name="M:Fluent.Ribbon.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:Fluent.Ribbon.OnGotFocus(System.Windows.RoutedEventArgs)">
            <inheritdoc />
        </member>
        <member name="M:Fluent.Ribbon.OnApplyTemplate">
            <inheritdoc />
        </member>
        <member name="M:Fluent.Ribbon.OnCreateAutomationPeer">
            <inheritdoc />
        </member>
        <member name="M:Fluent.Ribbon.OnOwnerWindowClosed(System.Object,System.EventArgs)">
            <summary>
            Called when the <see cref="F:Fluent.Ribbon.ownerWindow"/> is closed, so that we set it to null.
            </summary>
        </member>
        <member name="M:Fluent.Ribbon.IsInQuickAccessToolBar(System.Windows.UIElement)">
            <summary>
            Determines whether the given element is in quick access toolbar
            </summary>
            <param name="element">Element</param>
            <returns>True if element in quick access toolbar</returns>
        </member>
        <member name="M:Fluent.Ribbon.AddToQuickAccessToolBar(System.Windows.UIElement)">
            <summary>
            Adds the given element to quick access toolbar
            </summary>
            <param name="element">Element</param>
        </member>
        <member name="M:Fluent.Ribbon.RemoveFromQuickAccessToolBar(System.Windows.UIElement)">
            <summary>
            Removes the given elements from quick access toolbar
            </summary>
            <param name="element">Element</param>
        </member>
        <member name="M:Fluent.Ribbon.ClearQuickAccessToolBar">
            <summary>
            Clears quick access toolbar
            </summary>
        </member>
        <member name="P:Fluent.Ribbon.AutomaticStateManagement">
            <summary>
            Gets or sets whether Quick Access ToolBar can
            save and load its state automatically
            </summary>
        </member>
        <member name="F:Fluent.Ribbon.AutomaticStateManagementProperty">
            <summary>Identifies the <see cref="P:Fluent.Ribbon.AutomaticStateManagement"/> dependency property.</summary>
        </member>
        <member name="M:Fluent.Ribbon.Fluent#ILogicalChildSupport#AddLogicalChild(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:Fluent.Ribbon.Fluent#ILogicalChildSupport#RemoveLogicalChild(System.Object)">
            <inheritdoc />
        </member>
        <member name="P:Fluent.Ribbon.LogicalChildren">
            <inheritdoc />
        </member>
        <member name="T:Fluent.RibbonContextualGroupsContainer">
            <summary>
            Represents contextual groups container
            </summary>
        </member>
        <member name="M:Fluent.RibbonContextualGroupsContainer.ArrangeOverride(System.Windows.Size)">
            <inheritdoc />
        </member>
        <member name="M:Fluent.RibbonContextualGroupsContainer.MeasureOverride(System.Windows.Size)">
            <inheritdoc />
        </member>
        <member name="T:Fluent.RibbonContextualTabGroup">
            <summary>
            Represents contextual tab group
            </summary>
        </member>
        <member name="F:Fluent.RibbonContextualTabGroup.TabItemForegroundProperty">
            <summary>Identifies the <see cref="P:Fluent.RibbonContextualTabGroup.TabItemForeground"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.RibbonContextualTabGroup.TabItemForeground">
            <summary>
            Gets or sets the foreground brush to be used for a <see cref="T:Fluent.RibbonTabItem"/> belonging to this group.
            </summary>
        </member>
        <member name="F:Fluent.RibbonContextualTabGroup.TabItemSelectedForegroundProperty">
            <summary>Identifies the <see cref="P:Fluent.RibbonContextualTabGroup.TabItemSelectedForeground"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.RibbonContextualTabGroup.TabItemSelectedForeground">
            <summary>
            Gets or sets the foreground brush to be used for a selected <see cref="T:Fluent.RibbonTabItem"/> belonging to this group.
            </summary>
        </member>
        <member name="F:Fluent.RibbonContextualTabGroup.TabItemMouseOverForegroundProperty">
            <summary>Identifies the <see cref="P:Fluent.RibbonContextualTabGroup.TabItemMouseOverForeground"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.RibbonContextualTabGroup.TabItemMouseOverForeground">
            <summary>
            Gets or sets the foreground brush to be used when the mouse is over a <see cref="T:Fluent.RibbonTabItem"/> belonging to this group.
            </summary>
        </member>
        <member name="F:Fluent.RibbonContextualTabGroup.TabItemSelectedMouseOverForegroundProperty">
            <summary>Identifies the <see cref="P:Fluent.RibbonContextualTabGroup.TabItemSelectedMouseOverForeground"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.RibbonContextualTabGroup.TabItemSelectedMouseOverForeground">
            <summary>
            Gets or sets the foreground brush to be used when the mouse is over a selected <see cref="T:Fluent.RibbonTabItem"/> belonging to this group.
            </summary>
        </member>
        <member name="P:Fluent.RibbonContextualTabGroup.Header">
            <summary>
            Gets or sets group header
            </summary>
        </member>
        <member name="F:Fluent.RibbonContextualTabGroup.HeaderProperty">
            <summary>Identifies the <see cref="P:Fluent.RibbonContextualTabGroup.Header"/> dependency property.</summary>
        </member>
        <member name="M:Fluent.RibbonContextualTabGroup.OnHeaderChanged(System.Windows.DependencyObject,System.Windows.DependencyPropertyChangedEventArgs)">
            <summary>
            Handles header chages
            </summary>
            <param name="d">Object</param>
            <param name="e">The event data.</param>
        </member>
        <member name="P:Fluent.RibbonContextualTabGroup.Items">
            <summary>
            Gets collection of tab items
            </summary>
        </member>
        <member name="P:Fluent.RibbonContextualTabGroup.InnerVisibility">
            <summary>
            Gets or sets the visibility this group for internal use (this enables us to hide this group when all items in this group are hidden)
            </summary>
        </member>
        <member name="F:Fluent.RibbonContextualTabGroup.InnerVisibilityProperty">
            <summary>Identifies the <see cref="P:Fluent.RibbonContextualTabGroup.InnerVisibility"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.RibbonContextualTabGroup.FirstVisibleItem">
            <summary>
            Gets the first visible TabItem in this group
            </summary>
        </member>
        <member name="P:Fluent.RibbonContextualTabGroup.FirstVisibleAndEnabledItem">
            <summary>
            Gets the first visible TabItem in this group
            </summary>
        </member>
        <member name="P:Fluent.RibbonContextualTabGroup.LastVisibleItem">
            <summary>
            Gets the last visible TabItem in this group
            </summary>
        </member>
        <member name="M:Fluent.RibbonContextualTabGroup.#cctor">
            <summary>
            Static constructor
            </summary>
        </member>
        <member name="M:Fluent.RibbonContextualTabGroup.OnVisibilityChanged(System.Windows.DependencyObject,System.Windows.DependencyPropertyChangedEventArgs)">
            <summary>
            Handles visibility prioperty changed
            </summary>
            <param name="d">Object</param>
            <param name="e">The event data</param>
        </member>
        <member name="M:Fluent.RibbonContextualTabGroup.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:Fluent.RibbonContextualTabGroup.AppendTabItem(Fluent.RibbonTabItem)">
            <summary>
            Appends tab item
            </summary>
            <param name="item">Ribbon tab item</param>
        </member>
        <member name="M:Fluent.RibbonContextualTabGroup.RemoveTabItem(Fluent.RibbonTabItem)">
            <summary>
            Removes tab item
            </summary>
            <param name="item">Ribbon tab item</param>
        </member>
        <member name="M:Fluent.RibbonContextualTabGroup.UpdateInnerVisiblityAndGroupBorders">
            <summary>
            Updates the group border
            </summary>
        </member>
        <member name="M:Fluent.RibbonContextualTabGroup.OnMouseLeftButtonUp(System.Windows.Input.MouseButtonEventArgs)">
            <inheritdoc />
        </member>
        <member name="M:Fluent.RibbonContextualTabGroup.UpdateInnerVisibility">
            <summary>
            Updates the Visibility of the inner container
            </summary>
        </member>
        <member name="T:Fluent.RibbonControl">
            <summary>
            Represent base class for Fluent controls
            </summary>
        </member>
        <member name="P:Fluent.RibbonControl.KeyTip">
            <inheritdoc />
        </member>
        <member name="F:Fluent.RibbonControl.KeyTipProperty">
            <summary>
            Using a DependencyProperty as the backing store for Keys.
            This enables animation, styling, binding, etc...
            </summary>
        </member>
        <member name="P:Fluent.RibbonControl.Header">
            <inheritdoc />
        </member>
        <member name="F:Fluent.RibbonControl.HeaderProperty">
            <summary>Identifies the <see cref="P:Fluent.RibbonControl.Header"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.RibbonControl.HeaderTemplate">
            <inheritdoc />
        </member>
        <member name="F:Fluent.RibbonControl.HeaderTemplateProperty">
            <summary>Identifies the <see cref="P:Fluent.RibbonControl.HeaderTemplate"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.RibbonControl.HeaderTemplateSelector">
            <inheritdoc />
        </member>
        <member name="F:Fluent.RibbonControl.HeaderTemplateSelectorProperty">
            <summary>Identifies the <see cref="P:Fluent.RibbonControl.HeaderTemplateSelector"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.RibbonControl.Icon">
            <inheritdoc />
        </member>
        <member name="F:Fluent.RibbonControl.IconProperty">
            <summary>Identifies the <see cref="P:Fluent.RibbonControl.Icon"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.RibbonControl.Command">
            <inheritdoc />
        </member>
        <member name="P:Fluent.RibbonControl.CommandParameter">
            <inheritdoc />
        </member>
        <member name="P:Fluent.RibbonControl.CommandTarget">
            <inheritdoc />
        </member>
        <member name="F:Fluent.RibbonControl.CommandParameterProperty">
            <summary>Identifies the <see cref="P:Fluent.RibbonControl.CommandParameter"/> dependency property.</summary>
        </member>
        <member name="F:Fluent.RibbonControl.CommandProperty">
            <summary>Identifies the <see cref="P:Fluent.RibbonControl.Command"/> dependency property.</summary>
        </member>
        <member name="F:Fluent.RibbonControl.CommandTargetProperty">
            <summary>Identifies the <see cref="P:Fluent.RibbonControl.CommandTarget"/> dependency property.</summary>
        </member>
        <member name="M:Fluent.RibbonControl.OnCommandChanged(System.Windows.DependencyObject,System.Windows.DependencyPropertyChangedEventArgs)">
            <summary>
            Handles Command changed
            </summary>
        </member>
        <member name="M:Fluent.RibbonControl.OnCommandCanExecuteChanged(System.Object,System.EventArgs)">
            <summary>
            Handles Command CanExecute changed
            </summary>
        </member>
        <member name="P:Fluent.RibbonControl.IsEnabledCore">
            <inheritdoc />
        </member>
        <member name="P:Fluent.RibbonControl.Size">
            <inheritdoc />
        </member>
        <member name="F:Fluent.RibbonControl.SizeProperty">
            <summary>Identifies the <see cref="P:Fluent.RibbonControl.Size"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.RibbonControl.SizeDefinition">
            <inheritdoc />
        </member>
        <member name="F:Fluent.RibbonControl.SizeDefinitionProperty">
            <summary>Identifies the <see cref="P:Fluent.RibbonControl.SizeDefinition"/> dependency property.</summary>
        </member>
        <member name="M:Fluent.RibbonControl.#cctor">
            <summary>
            Static constructor
            </summary>
        </member>
        <member name="M:Fluent.RibbonControl.#ctor">
            <summary>
            Default Constructor
            </summary>
        </member>
        <member name="M:Fluent.RibbonControl.CreateQuickAccessItem">
            <inheritdoc />
        </member>
        <member name="M:Fluent.RibbonControl.BindQuickAccessItem(System.Windows.FrameworkElement,System.Windows.FrameworkElement)">
            <summary>
            Binds default properties of control to quick access element
            </summary>
            <param name="source">Source item</param>
            <param name="element">Toolbar item</param>
        </member>
        <member name="P:Fluent.RibbonControl.CanAddToQuickAccessToolBar">
            <inheritdoc />
        </member>
        <member name="F:Fluent.RibbonControl.CanAddToQuickAccessToolBarProperty">
            <summary>Identifies the <see cref="P:Fluent.RibbonControl.CanAddToQuickAccessToolBar"/> dependency property.</summary>
        </member>
        <member name="M:Fluent.RibbonControl.OnCanAddToQuickAccessToolBarChanged(System.Windows.DependencyObject,System.Windows.DependencyPropertyChangedEventArgs)">
            <summary>
            Occurs then CanAddToQuickAccessToolBar property changed
            </summary>
        </member>
        <member name="M:Fluent.RibbonControl.OnKeyTipPressed">
            <inheritdoc />
        </member>
        <member name="M:Fluent.RibbonControl.OnKeyTipBack">
            <inheritdoc />
        </member>
        <member name="M:Fluent.RibbonControl.GetControlWorkArea(System.Windows.FrameworkElement)">
            <summary>
            Returns screen workarea in witch control is placed
            </summary>
            <param name="control">Control</param>
            <returns>Workarea in witch control is placed</returns>
        </member>
        <member name="M:Fluent.RibbonControl.GetControlMonitor(System.Windows.FrameworkElement)">
            <summary>
            Returns monitor in witch control is placed
            </summary>
            <param name="control">Control</param>
            <returns>Workarea in witch control is placed</returns>
        </member>
        <member name="M:Fluent.RibbonControl.GetParentRibbon(System.Windows.DependencyObject)">
            <summary>
            Get the parent <see cref="T:Fluent.Ribbon"/>.
            </summary>
            <returns>The found <see cref="T:Fluent.Ribbon"/> or <c>null</c> of no parent <see cref="T:Fluent.Ribbon"/> could be found.</returns>
        </member>
        <member name="M:Fluent.RibbonControl.Fluent#ILogicalChildSupport#AddLogicalChild(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:Fluent.RibbonControl.Fluent#ILogicalChildSupport#RemoveLogicalChild(System.Object)">
            <inheritdoc />
        </member>
        <member name="P:Fluent.RibbonControl.LogicalChildren">
            <inheritdoc />
        </member>
        <member name="M:Fluent.RibbonControl.OnCreateAutomationPeer">
            <inheritdoc />
        </member>
        <member name="T:Fluent.RibbonGroupBox">
            <summary>
            RibbonGroup represents a logical group of controls as they appear on
            a RibbonTab.  These groups can resize its content
            </summary>
        </member>
        <member name="P:Fluent.RibbonGroupBox.HeaderContentControl">
            <summary>
            Get the <see cref="T:System.Windows.Controls.ContentControl"/> responsible for rendering the header.
            </summary>
        </member>
        <member name="P:Fluent.RibbonGroupBox.CollapsedHeaderContentControl">
            <summary>
            Get the <see cref="T:System.Windows.Controls.ContentControl"/> responsible for rendering the header when <see cref="P:Fluent.RibbonGroupBox.State"/> is equal to <see cref="F:Fluent.RibbonGroupBoxState.Collapsed"/>.
            </summary>
        </member>
        <member name="P:Fluent.RibbonGroupBox.KeyTip">
            <inheritdoc />
        </member>
        <member name="F:Fluent.RibbonGroupBox.KeyTipProperty">
            <summary>
            Using a DependencyProperty as the backing store for Keys.
            This enables animation, styling, binding, etc...
            </summary>
        </member>
        <member name="F:Fluent.RibbonGroupBox.IsCollapsedHeaderContentPresenterProperty">
            <summary>
            <see cref="T:System.Windows.DependencyProperty"/> for IsCollapsedHeaderContentPresenter.
            </summary>
        </member>
        <member name="M:Fluent.RibbonGroupBox.SetIsCollapsedHeaderContentPresenter(System.Windows.DependencyObject,System.Boolean)">
            <summary>
            Sets the value of <see cref="F:Fluent.RibbonGroupBox.IsCollapsedHeaderContentPresenterProperty"/>.
            </summary>
        </member>
        <member name="M:Fluent.RibbonGroupBox.GetIsCollapsedHeaderContentPresenter(System.Windows.DependencyObject)">
            <summary>
            Gets the value of <see cref="F:Fluent.RibbonGroupBox.IsCollapsedHeaderContentPresenterProperty"/>.
            </summary>
        </member>
        <member name="P:Fluent.RibbonGroupBox.DropDownPopup">
            <inheritdoc />
        </member>
        <member name="P:Fluent.RibbonGroupBox.IsContextMenuOpened">
            <inheritdoc />
        </member>
        <member name="P:Fluent.RibbonGroupBox.IsInButtonState">
            <summary>
            Shorthand for whether the GroupBox is in a state where it can act as a button
            </summary>
        </member>
        <member name="P:Fluent.RibbonGroupBox.StateDefinition">
            <summary>
            Gets or sets the state transition for full mode
            </summary>
        </member>
        <member name="F:Fluent.RibbonGroupBox.StateDefinitionProperty">
            <summary>Identifies the <see cref="P:Fluent.RibbonGroupBox.StateDefinition"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.RibbonGroupBox.SimplifiedStateDefinition">
            <summary>
            Gets or sets the state transition for simplified mode
            </summary>
        </member>
        <member name="F:Fluent.RibbonGroupBox.SimplifiedStateDefinitionProperty">
            <summary>Identifies the <see cref="P:Fluent.RibbonGroupBox.SimplifiedStateDefinition"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.RibbonGroupBox.State">
            <summary>
            Gets or sets the current state of the group
            </summary>
        </member>
        <member name="F:Fluent.RibbonGroupBox.StateProperty">
            <summary>Identifies the <see cref="P:Fluent.RibbonGroupBox.State"/> dependency property.</summary>
        </member>
        <member name="M:Fluent.RibbonGroupBox.OnStateChanged(System.Windows.DependencyObject,System.Windows.DependencyPropertyChangedEventArgs)">
            <summary>
            On state property changed
            </summary>
            <param name="d">Object</param>
            <param name="e">The event data</param>
        </member>
        <member name="P:Fluent.RibbonGroupBox.Scale">
            <summary>
            Gets or sets scale index (for internal IRibbonScalableControl)
            </summary>
        </member>
        <member name="P:Fluent.RibbonGroupBox.CacheResetGuard">
            <summary>
            Gets or sets whether to reset cache when scalable control is scaled
            </summary>
        </member>
        <member name="P:Fluent.RibbonGroupBox.IsLauncherVisible">
            <summary>
            Gets or sets dialog launcher button visibility
            </summary>
        </member>
        <member name="F:Fluent.RibbonGroupBox.IsLauncherVisibleProperty">
            <summary>Identifies the <see cref="P:Fluent.RibbonGroupBox.IsLauncherVisible"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.RibbonGroupBox.LauncherKeys">
            <summary>
            Gets or sets key tip for dialog launcher button
            </summary>
        </member>
        <member name="F:Fluent.RibbonGroupBox.LauncherKeysProperty">
            <summary>Identifies the <see cref="P:Fluent.RibbonGroupBox.LauncherKeys"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.RibbonGroupBox.LauncherIcon">
            <summary>
            Gets or sets launcher button icon
            </summary>
        </member>
        <member name="F:Fluent.RibbonGroupBox.LauncherIconProperty">
            <summary>Identifies the <see cref="P:Fluent.RibbonGroupBox.LauncherIcon"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.RibbonGroupBox.LauncherText">
            <summary>
            Gets or sets launcher button text
            </summary>
        </member>
        <member name="F:Fluent.RibbonGroupBox.LauncherTextProperty">
            <summary>Identifies the <see cref="P:Fluent.RibbonGroupBox.LauncherText"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.RibbonGroupBox.LauncherCommand">
            <summary>
            Gets or sets the command to invoke when this button is pressed. This is a dependency property.
            </summary>
        </member>
        <member name="P:Fluent.RibbonGroupBox.LauncherCommandParameter">
            <summary>
            Gets or sets the parameter to pass to the System.Windows.Controls.Primitives.ButtonBase.Command property. This is a dependency property.
            </summary>
        </member>
        <member name="P:Fluent.RibbonGroupBox.LauncherCommandTarget">
            <summary>
            Gets or sets the element on which to raise the specified command. This is a dependency property.
            </summary>
        </member>
        <member name="F:Fluent.RibbonGroupBox.LauncherCommandParameterProperty">
            <summary>Identifies the <see cref="P:Fluent.RibbonGroupBox.LauncherCommandParameter"/> dependency property.</summary>
        </member>
        <member name="F:Fluent.RibbonGroupBox.LauncherCommandProperty">
            <summary>Identifies the <see cref="P:Fluent.RibbonGroupBox.LauncherCommand"/> dependency property.</summary>
        </member>
        <member name="F:Fluent.RibbonGroupBox.LauncherCommandTargetProperty">
            <summary>Identifies the <see cref="P:Fluent.RibbonGroupBox.LauncherCommandTarget"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.RibbonGroupBox.LauncherToolTip">
            <summary>
            Gets or sets launcher button tooltip
            </summary>
        </member>
        <member name="F:Fluent.RibbonGroupBox.LauncherToolTipProperty">
            <summary>Identifies the <see cref="P:Fluent.RibbonGroupBox.LauncherToolTip"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.RibbonGroupBox.IsLauncherEnabled">
            <summary>
            Gets or sets whether launcher button is enabled
            </summary>
        </member>
        <member name="F:Fluent.RibbonGroupBox.IsLauncherEnabledProperty">
            <summary>Identifies the <see cref="P:Fluent.RibbonGroupBox.IsLauncherEnabled"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.RibbonGroupBox.LauncherButton">
            <summary>
            Gets launcher button
            </summary>
        </member>
        <member name="F:Fluent.RibbonGroupBox.LauncherButtonProperty">
            <summary>Identifies the <see cref="P:Fluent.RibbonGroupBox.LauncherButton"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.RibbonGroupBox.IsDropDownOpen">
            <inheritdoc />
        </member>
        <member name="F:Fluent.RibbonGroupBox.IsDropDownOpenProperty">
            <summary>Identifies the <see cref="P:Fluent.RibbonGroupBox.IsDropDownOpen"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.RibbonGroupBox.Icon">
            <summary>
            Gets or sets icon
            </summary>
        </member>
        <member name="F:Fluent.RibbonGroupBox.IconProperty">
            <summary>Identifies the <see cref="P:Fluent.RibbonGroupBox.Icon"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.RibbonGroupBox.MediumIcon">
            <inheritdoc />
        </member>
        <member name="F:Fluent.RibbonGroupBox.MediumIconProperty">
            <summary>Identifies the <see cref="P:Fluent.RibbonGroupBox.MediumIcon"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.RibbonGroupBox.LargeIcon">
            <inheritdoc />
        </member>
        <member name="F:Fluent.RibbonGroupBox.LargeIconProperty">
            <summary>Identifies the <see cref="P:Fluent.RibbonGroupBox.LargeIcon"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.RibbonGroupBox.IsSeparatorVisible">
            <summary>
            Gets or sets whether the groupbox shows a separator.
            </summary>
        </member>
        <member name="F:Fluent.RibbonGroupBox.IsSeparatorVisibleProperty">
            <summary>Identifies the <see cref="P:Fluent.RibbonGroupBox.IsSeparatorVisible"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.RibbonGroupBox.IsSimplified">
            <summary>
            Gets or sets whether or not the ribbon is in simplified mode.
            </summary>
        </member>
        <member name="F:Fluent.RibbonGroupBox.IsSimplifiedProperty">
            <summary>Identifies the <see cref="P:Fluent.RibbonGroupBox.IsSimplified"/> dependency property.</summary>
        </member>
        <member name="M:Fluent.RibbonGroupBox.OnIsSimplifiedChanged(System.Windows.DependencyObject,System.Windows.DependencyPropertyChangedEventArgs)">
            <summary>
            Called when <see cref="P:Fluent.RibbonGroupBox.IsSimplified"/> changes.
            </summary>
        </member>
        <member name="E:Fluent.RibbonGroupBox.LauncherClick">
            <summary>
            Dialog launcher btton click event
            </summary>
        </member>
        <member name="E:Fluent.RibbonGroupBox.DropDownOpened">
            <inheritdoc />
        </member>
        <member name="E:Fluent.RibbonGroupBox.DropDownClosed">
            <inheritdoc />
        </member>
        <member name="M:Fluent.RibbonGroupBox.#cctor">
            <summary>
            Initializes static members of the <see cref="T:Fluent.RibbonGroupBox"/> class.
            </summary>
        </member>
        <member name="M:Fluent.RibbonGroupBox.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:Fluent.RibbonGroupBox.GetPanel">
            <summary>
            Gets a panel with items
            </summary>
            <returns></returns>
        </member>
        <member name="M:Fluent.RibbonGroupBox.GetLayoutRoot">
            <summary>
            Gets cmmon layout root for popup and groupbox
            </summary>
            <returns></returns>
        </member>
        <member name="P:Fluent.RibbonGroupBox.IsSnapped">
            <summary>
            Snaps / Unsnaps the Visual
            (remove visuals and substitute with freezed image)
            </summary>
        </member>
        <member name="P:Fluent.RibbonGroupBox.StateIntermediate">
            <summary>
            Gets or sets intermediate state of the group box
            </summary>
        </member>
        <member name="P:Fluent.RibbonGroupBox.ScaleIntermediate">
            <summary>
            Gets or sets intermediate scale of the group box
            </summary>
        </member>
        <member name="M:Fluent.RibbonGroupBox.GetDesiredSizeIntermediate">
            <summary>
            Gets intermediate desired size
            </summary>
        </member>
        <member name="M:Fluent.RibbonGroupBox.TryClearCacheAndResetStateAndScaleAndNotifyParentRibbonGroupsContainer">
            <summary>
            Tries to clear the cache, reset the state and reset the scale.
            If that succeeds the parent <see cref="T:Fluent.RibbonGroupsContainer"/> is notified about that.
            </summary>
            <returns><c>true</c> if the cache was reset. Otherwise <c>false</c>.</returns>
        </member>
        <member name="M:Fluent.RibbonGroupBox.InvalidateLayout">
            <summary>
            Invalidates layout (with children)
            </summary>
        </member>
        <member name="M:Fluent.RibbonGroupBox.OnApplyTemplate">
            <inheritdoc />
        </member>
        <member name="M:Fluent.RibbonGroupBox.OnItemsChanged(System.Collections.Specialized.NotifyCollectionChangedEventArgs)">
            <inheritdoc />
        </member>
        <member name="M:Fluent.RibbonGroupBox.OnMouseLeftButtonDown(System.Windows.Input.MouseButtonEventArgs)">
            <inheritdoc />
        </member>
        <member name="M:Fluent.RibbonGroupBox.OnKeyDown(System.Windows.Input.KeyEventArgs)">
            <inheritdoc />
        </member>
        <member name="M:Fluent.RibbonGroupBox.OnDialogLauncherButtonClick(System.Object,System.Windows.RoutedEventArgs)">
            <summary>
            Dialog launcher button click handler
            </summary>
            <param name="sender">Sender</param>
            <param name="e">the event data</param>
        </member>
        <member name="M:Fluent.RibbonGroupBox.OnIsDropDownOpenChanged(System.Windows.DependencyObject,System.Windows.DependencyPropertyChangedEventArgs)">
            <summary>
            Handles IsOpen propertyu changes
            </summary>
            <param name="d">Object</param>
            <param name="e">The event data</param>
        </member>
        <member name="M:Fluent.RibbonGroupBox.CreateQuickAccessItem">
            <inheritdoc />
        </member>
        <member name="P:Fluent.RibbonGroupBox.CanAddToQuickAccessToolBar">
            <inheritdoc />
        </member>
        <member name="F:Fluent.RibbonGroupBox.CanAddToQuickAccessToolBarProperty">
            <summary>Identifies the <see cref="P:Fluent.RibbonGroupBox.CanAddToQuickAccessToolBar"/> dependency property.</summary>
        </member>
        <member name="M:Fluent.RibbonGroupBox.OnKeyTipPressed">
            <inheritdoc />
        </member>
        <member name="M:Fluent.RibbonGroupBox.OnKeyTipBack">
            <inheritdoc />
        </member>
        <member name="M:Fluent.RibbonGroupBox.Fluent#ISimplifiedStateControl#UpdateSimplifiedState(System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:Fluent.RibbonGroupBox.Fluent#ILogicalChildSupport#AddLogicalChild(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:Fluent.RibbonGroupBox.Fluent#ILogicalChildSupport#RemoveLogicalChild(System.Object)">
            <inheritdoc />
        </member>
        <member name="P:Fluent.RibbonGroupBox.LogicalChildren">
            <inheritdoc />
        </member>
        <member name="M:Fluent.RibbonGroupBox.OnCreateAutomationPeer">
            <inheritdoc />
        </member>
        <member name="T:Fluent.RibbonGroupBoxWrapPanel">
            <summary>
            Special wrap panel for <see cref="T:Fluent.RibbonGroupBox" />.
            </summary>
        </member>
        <member name="F:Fluent.RibbonGroupBoxWrapPanel.SharedSizeGroupNameProperty">
            <summary>
            Attached <see cref="T:System.Windows.DependencyProperty" /> for <c>SharedSizeGroupName</c>.
            </summary>
        </member>
        <member name="F:Fluent.RibbonGroupBoxWrapPanel.ExcludeFromSharedSizeProperty">
            <summary>
            Attached <see cref="T:System.Windows.DependencyProperty" /> for <c>SharedSizeGroupName</c>.
            </summary>
        </member>
        <member name="F:Fluent.RibbonGroupBoxWrapPanel.ItemWidthProperty">
            <summary>Identifies the <see cref="P:Fluent.RibbonGroupBoxWrapPanel.ItemWidth"/> dependency property.</summary>
        </member>
        <member name="F:Fluent.RibbonGroupBoxWrapPanel.ItemHeightProperty">
            <summary>Identifies the <see cref="P:Fluent.RibbonGroupBoxWrapPanel.ItemHeight"/> dependency property.</summary>
        </member>
        <member name="F:Fluent.RibbonGroupBoxWrapPanel.OrientationProperty">
            <summary>Identifies the <see cref="P:Fluent.RibbonGroupBoxWrapPanel.Orientation"/> dependency property.</summary>
        </member>
        <member name="F:Fluent.RibbonGroupBoxWrapPanel.IsSimplifiedProperty">
            <summary>Identifies the <see cref="P:Fluent.RibbonGroupBoxWrapPanel.IsSimplified"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.RibbonGroupBoxWrapPanel.ItemWidth">
            <summary>
            The ItemWidth and ItemHeight properties specify the size of all items in the WrapPanel.
            Note that children of
            WrapPanel may have their own Width/Height properties set - the ItemWidth/ItemHeight
            specifies the size of "layout partition" reserved by WrapPanel for the child.
            If this property is not set (or set to "Auto" in markup or Double.NaN in code) - the size of layout
            partition is equal to DesiredSize of the child element.
            </summary>
        </member>
        <member name="P:Fluent.RibbonGroupBoxWrapPanel.ItemHeight">
            <summary>
            The ItemWidth and ItemHeight properties specify the size of all items in the WrapPanel.
            Note that children of
            WrapPanel may have their own Width/Height properties set - the ItemWidth/ItemHeight
            specifies the size of "layout partition" reserved by WrapPanel for the child.
            If this property is not set (or set to "Auto" in markup or Double.NaN in code) - the size of layout
            partition is equal to DesiredSize of the child element.
            </summary>
        </member>
        <member name="P:Fluent.RibbonGroupBoxWrapPanel.Orientation">
            <summary>
            Specifies dimension of children positioning in absence of wrapping.
            Wrapping occurs in orthogonal direction. For example, if Orientation is Horizontal,
            the items try to form horizontal rows first and if needed are wrapped and form vertical stack of rows.
            If Orientation is Vertical, items first positioned in a vertical column, and if there is
            not enough space - wrapping creates additional columns in horizontal dimension.
            </summary>
        </member>
        <member name="P:Fluent.RibbonGroupBoxWrapPanel.IsSimplified">
            <summary>
            Gets or sets whether or not the ribbon is in simplified mode.
            </summary>
        </member>
        <member name="M:Fluent.RibbonGroupBoxWrapPanel.SetSharedSizeGroupName(System.Windows.DependencyObject,System.String)">
            <summary>
            Sets <see cref="F:Fluent.RibbonGroupBoxWrapPanel.SharedSizeGroupNameProperty" /> for <paramref name="element" />.
            </summary>
        </member>
        <member name="M:Fluent.RibbonGroupBoxWrapPanel.GetSharedSizeGroupName(System.Windows.DependencyObject)">
            <summary>
            Gets <see cref="F:Fluent.RibbonGroupBoxWrapPanel.SharedSizeGroupNameProperty" /> for <paramref name="element" />.
            </summary>
        </member>
        <member name="M:Fluent.RibbonGroupBoxWrapPanel.SetExcludeFromSharedSize(System.Windows.DependencyObject,System.Boolean)">
            <summary>
            Sets <see cref="F:Fluent.RibbonGroupBoxWrapPanel.ExcludeFromSharedSizeProperty" /> for <paramref name="element" />.
            </summary>
        </member>
        <member name="M:Fluent.RibbonGroupBoxWrapPanel.GetExcludeFromSharedSize(System.Windows.DependencyObject)">
            <summary>
            Gets <see cref="F:Fluent.RibbonGroupBoxWrapPanel.ExcludeFromSharedSizeProperty" /> for <paramref name="element" />.
            </summary>
        </member>
        <member name="M:Fluent.RibbonGroupBoxWrapPanel.MeasureOverride(System.Windows.Size)">
            <inheritdoc />
        </member>
        <member name="M:Fluent.RibbonGroupBoxWrapPanel.ArrangeOverride(System.Windows.Size)">
            <inheritdoc />
        </member>
        <member name="T:Fluent.RibbonGroupsContainer">
            <summary>
            Represent panel with ribbon group.
            It is automatically adjusting size of controls
            </summary>
        </member>
        <member name="P:Fluent.RibbonGroupsContainer.ReduceOrder">
            <summary>
            Gets or sets reduce order of group in the ribbon panel.
            It must be enumerated with comma from the first to reduce to
            the last to reduce (use Control.Name as group name in the enum).
            Enclose in parentheses as (Control.Name) to reduce/enlarge
            scalable elements in the given group
            </summary>
        </member>
        <member name="F:Fluent.RibbonGroupsContainer.ReduceOrderProperty">
            <summary>Identifies the <see cref="P:Fluent.RibbonGroupsContainer.ReduceOrder"/> dependency property.</summary>
        </member>
        <member name="M:Fluent.RibbonGroupsContainer.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:Fluent.RibbonGroupsContainer.CreateUIElementCollection(System.Windows.FrameworkElement)">
            <inheritdoc />
        </member>
        <member name="M:Fluent.RibbonGroupsContainer.MeasureOverride(System.Windows.Size)">
            <inheritdoc />
        </member>
        <member name="M:Fluent.RibbonGroupsContainer.ArrangeOverride(System.Windows.Size)">
            <inheritdoc />
        </member>
        <member name="P:Fluent.RibbonGroupsContainer.ScrollOwner">
            <inheritdoc />
        </member>
        <member name="M:Fluent.RibbonGroupsContainer.SetHorizontalOffset(System.Double)">
            <inheritdoc />
        </member>
        <member name="P:Fluent.RibbonGroupsContainer.ExtentWidth">
            <inheritdoc />
        </member>
        <member name="P:Fluent.RibbonGroupsContainer.HorizontalOffset">
            <inheritdoc />
        </member>
        <member name="P:Fluent.RibbonGroupsContainer.ViewportWidth">
            <inheritdoc />
        </member>
        <member name="M:Fluent.RibbonGroupsContainer.LineLeft">
            <inheritdoc />
        </member>
        <member name="M:Fluent.RibbonGroupsContainer.LineRight">
            <inheritdoc />
        </member>
        <member name="M:Fluent.RibbonGroupsContainer.MakeVisible(System.Windows.Media.Visual,System.Windows.Rect)">
            <inheritdoc />
        </member>
        <member name="M:Fluent.RibbonGroupsContainer.MouseWheelDown">
            <summary>
            Not implemented
            </summary>
        </member>
        <member name="M:Fluent.RibbonGroupsContainer.MouseWheelLeft">
            <inheritdoc />
        </member>
        <member name="M:Fluent.RibbonGroupsContainer.MouseWheelRight">
            <inheritdoc />
        </member>
        <member name="M:Fluent.RibbonGroupsContainer.MouseWheelUp">
            <summary>
            Not implemented
            </summary>
        </member>
        <member name="M:Fluent.RibbonGroupsContainer.LineDown">
            <summary>
            Not implemented
            </summary>
        </member>
        <member name="M:Fluent.RibbonGroupsContainer.LineUp">
            <summary>
            Not implemented
            </summary>
        </member>
        <member name="M:Fluent.RibbonGroupsContainer.PageDown">
            <summary>
            Not implemented
            </summary>
        </member>
        <member name="M:Fluent.RibbonGroupsContainer.PageLeft">
            <summary>
            Not implemented
            </summary>
        </member>
        <member name="M:Fluent.RibbonGroupsContainer.PageRight">
            <summary>
            Not implemented
            </summary>
        </member>
        <member name="M:Fluent.RibbonGroupsContainer.PageUp">
            <summary>
            Not implemented
            </summary>
        </member>
        <member name="M:Fluent.RibbonGroupsContainer.SetVerticalOffset(System.Double)">
            <summary>
            Not implemented
            </summary>
        </member>
        <member name="P:Fluent.RibbonGroupsContainer.CanVerticallyScroll">
            <inheritdoc />
        </member>
        <member name="P:Fluent.RibbonGroupsContainer.CanHorizontallyScroll">
            <inheritdoc />
        </member>
        <member name="P:Fluent.RibbonGroupsContainer.ExtentHeight">
            <summary>
            Not implemented
            </summary>
        </member>
        <member name="P:Fluent.RibbonGroupsContainer.VerticalOffset">
            <summary>
            Not implemented
            </summary>
        </member>
        <member name="P:Fluent.RibbonGroupsContainer.ViewportHeight">
            <summary>
            Not implemented
            </summary>
        </member>
        <member name="M:Fluent.RibbonGroupsContainer.OnChildDesiredSizeChanged(System.Windows.UIElement)">
            <inheritdoc />
        </member>
        <member name="T:Fluent.RibbonGroupsContainerScrollViewer">
            <summary>
            Represents a <see cref="T:System.Windows.Controls.ScrollViewer" /> specific to <see cref="T:Fluent.RibbonGroupsContainer" />.
            </summary>
        </member>
        <member name="M:Fluent.RibbonGroupsContainerScrollViewer.OnMouseWheel(System.Windows.Input.MouseWheelEventArgs)">
            <inheritdoc />
        </member>
        <member name="T:Fluent.RibbonMenu">
            <summary>
            Represents menu in combo box and gallery
            </summary>
        </member>
        <member name="M:Fluent.RibbonMenu.GetContainerForItemOverride">
            <inheritdoc />
        </member>
        <member name="T:Fluent.RibbonScrollViewer">
            <summary>
            Represents <see cref="T:System.Windows.Controls.ScrollViewer"/> with modified hit test
            </summary>
        </member>
        <member name="M:Fluent.RibbonScrollViewer.HitTestCore(System.Windows.Media.PointHitTestParameters)">
            <inheritdoc />
        </member>
        <member name="M:Fluent.RibbonScrollViewer.OnMouseWheel(System.Windows.Input.MouseWheelEventArgs)">
            <inheritdoc />
        </member>
        <member name="T:Fluent.RibbonTabControl">
            <summary>
            Represents ribbon tab control
            </summary>
        </member>
        <member name="F:Fluent.RibbonTabControl.DefaultContentGapHeight">
            <summary>
            Default value for <see cref="P:Fluent.RibbonTabControl.ContentGapHeight"/>.
            </summary>
        </member>
        <member name="F:Fluent.RibbonTabControl.DefaultContentHeight">
            <summary>
            Default value for <see cref="P:Fluent.RibbonTabControl.ContentHeight"/>.
            </summary>
        </member>
        <member name="F:Fluent.RibbonTabControl.AdditionalPopupSpaceForKeyTips">
            <summary>
            Provides a value needed to add space to the popup to accomodate for overlapping keytips.
            </summary>
        </member>
        <member name="F:Fluent.RibbonTabControl.AdditionalPopupSpaceForKeyTipsGridLength">
            <summary>
            Provides a value needed to add space to the popup to accomodate for overlapping keytips.
            </summary>
        </member>
        <member name="E:Fluent.RibbonTabControl.RequestBackstageClose">
            <summary>
            Event which is fired when the, maybe listening, <see cref="T:Fluent.Backstage"/> should be closed
            </summary>
        </member>
        <member name="E:Fluent.RibbonTabControl.DropDownOpened">
            <inheritdoc />
        </member>
        <member name="E:Fluent.RibbonTabControl.DropDownClosed">
            <inheritdoc />
        </member>
        <member name="P:Fluent.RibbonTabControl.Menu">
            <summary>
            Gets or sets file menu control (can be application menu button, backstage button and so on)
            </summary>
        </member>
        <member name="F:Fluent.RibbonTabControl.MenuProperty">
            <summary>Identifies the <see cref="P:Fluent.RibbonTabControl.Menu"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.RibbonTabControl.DropDownPopup">
            <inheritdoc />
        </member>
        <member name="P:Fluent.RibbonTabControl.TabsContainer">
            <summary>
            Gets the <see cref="T:System.Windows.Controls.Panel"/> responsible for displaying the selected tabs content.
            </summary>
        </member>
        <member name="P:Fluent.RibbonTabControl.SelectedContentPresenter">
            <summary>
            Gets the <see cref="T:System.Windows.Controls.ContentControl"/> responsible for displaying the selected tabs content.
            </summary>
        </member>
        <member name="P:Fluent.RibbonTabControl.IsContextMenuOpened">
            <inheritdoc />
        </member>
        <member name="P:Fluent.RibbonTabControl.SelectedContent">
            <summary>
            Gets content of selected tab item
            </summary>
        </member>
        <member name="F:Fluent.RibbonTabControl.SelectedContentProperty">
            <summary>Identifies the <see cref="P:Fluent.RibbonTabControl.SelectedContent"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.RibbonTabControl.IsMinimized">
            <summary>
            Gets or sets whether ribbon is minimized
            </summary>
        </member>
        <member name="F:Fluent.RibbonTabControl.IsMinimizedProperty">
            <summary>Identifies the <see cref="P:Fluent.RibbonTabControl.IsMinimized"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.RibbonTabControl.CanMinimize">
            <summary>
            Gets or sets whether ribbon can be minimized
            </summary>
        </member>
        <member name="F:Fluent.RibbonTabControl.CanMinimizeProperty">
            <summary>Identifies the <see cref="P:Fluent.RibbonTabControl.CanMinimize"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.RibbonTabControl.IsSimplified">
            <summary>
            Gets or sets whether ribbon is simplified
            </summary>
        </member>
        <member name="F:Fluent.RibbonTabControl.IsSimplifiedProperty">
            <summary>Identifies the <see cref="P:Fluent.RibbonTabControl.IsSimplified"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.RibbonTabControl.CanUseSimplified">
            <summary>
            Gets or sets whether ribbon can be switched simplified
            </summary>
        </member>
        <member name="F:Fluent.RibbonTabControl.CanUseSimplifiedProperty">
            <summary>Identifies the <see cref="P:Fluent.RibbonTabControl.CanUseSimplified"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.RibbonTabControl.IsDropDownOpen">
            <inheritdoc />
        </member>
        <member name="F:Fluent.RibbonTabControl.IsDropDownOpenProperty">
            <summary>Identifies the <see cref="P:Fluent.RibbonTabControl.IsDropDownOpen"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.RibbonTabControl.HighlightSelectedItem">
            <summary>
            Defines if the currently selected item should draw it's highlight/selected borders
            </summary>
        </member>
        <member name="F:Fluent.RibbonTabControl.HighlightSelectedItemProperty">
            <summary>Identifies the <see cref="P:Fluent.RibbonTabControl.HighlightSelectedItem"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.RibbonTabControl.CanScroll">
            <summary>
            Gets whether ribbon tabs can scroll
            </summary>
        </member>
        <member name="P:Fluent.RibbonTabControl.SelectedTabItem">
            <summary>
            Gets or sets selected tab item
            </summary>
        </member>
        <member name="F:Fluent.RibbonTabControl.SelectedTabItemProperty">
            <summary>Identifies the <see cref="P:Fluent.RibbonTabControl.SelectedTabItem"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.RibbonTabControl.ToolBarItems">
            <summary>
            Gets collection of ribbon toolbar items
            </summary>
        </member>
        <member name="P:Fluent.RibbonTabControl.ContentHeight">
            <summary>
            Gets or sets the height of the content area.
            </summary>
        </member>
        <member name="F:Fluent.RibbonTabControl.ContentHeightProperty">
            <summary>Identifies the <see cref="P:Fluent.RibbonTabControl.ContentHeight"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.RibbonTabControl.ContentGapHeight">
            <summary>
            Gets or sets the height of the gap between the ribbon and the content
            </summary>
        </member>
        <member name="F:Fluent.RibbonTabControl.ContentGapHeightProperty">
            <summary>Identifies the <see cref="P:Fluent.RibbonTabControl.ContentGapHeight"/> dependency property.</summary>
        </member>
        <member name="F:Fluent.RibbonTabControl.AreTabHeadersVisibleProperty">
            <summary>Identifies the <see cref="P:Fluent.RibbonTabControl.AreTabHeadersVisible"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.RibbonTabControl.AreTabHeadersVisible">
            <summary>
            Defines whether tab headers are visible or not.
            </summary>
        </member>
        <member name="F:Fluent.RibbonTabControl.IsToolBarVisibleProperty">
            <summary>Identifies the <see cref="P:Fluent.RibbonTabControl.IsToolBarVisible"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.RibbonTabControl.IsToolBarVisible">
            <summary>
            Defines whether tab headers are visible or not.
            </summary>
        </member>
        <member name="F:Fluent.RibbonTabControl.IsMouseWheelScrollingEnabledProperty">
            <summary>Identifies the <see cref="P:Fluent.RibbonTabControl.IsMouseWheelScrollingEnabled"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.RibbonTabControl.IsMouseWheelScrollingEnabled">
            <summary>
            Defines whether scrolling by mouse wheel on the tab container area to cycle tabs is enabled or not.
            </summary>
        </member>
        <member name="F:Fluent.RibbonTabControl.IsMouseWheelScrollingEnabledEverywhereProperty">
            <summary>Identifies the <see cref="P:Fluent.RibbonTabControl.IsMouseWheelScrollingEnabledEverywhere"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.RibbonTabControl.IsMouseWheelScrollingEnabledEverywhere">
            <summary>
            Defines whether scrolling by mouse wheel always cycles selected tab, also outside the tab container area.
            </summary>
        </member>
        <member name="F:Fluent.RibbonTabControl.IsDisplayOptionsButtonVisibleProperty">
            <summary>Identifies the <see cref="P:Fluent.RibbonTabControl.IsDisplayOptionsButtonVisible"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.RibbonTabControl.IsDisplayOptionsButtonVisible">
            <summary>
            Defines whether display options button is visible or not.
            </summary>
        </member>
        <member name="M:Fluent.RibbonTabControl.#cctor">
            <summary>
            Initializes static members of the <see cref="T:Fluent.RibbonTabControl"/> class.
            </summary>
        </member>
        <member name="M:Fluent.RibbonTabControl.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Fluent.RibbonTabControl"/> class.
            </summary>
        </member>
        <member name="M:Fluent.RibbonTabControl.OnInitialized(System.EventArgs)">
            <inheritdoc />
        </member>
        <member name="M:Fluent.RibbonTabControl.GetContainerForItemOverride">
            <inheritdoc />
        </member>
        <member name="M:Fluent.RibbonTabControl.IsItemItsOwnContainerOverride(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:Fluent.RibbonTabControl.OnApplyTemplate">
            <inheritdoc />
        </member>
        <member name="M:Fluent.RibbonTabControl.OnItemsChanged(System.Collections.Specialized.NotifyCollectionChangedEventArgs)">
            <inheritdoc />
        </member>
        <member name="M:Fluent.RibbonTabControl.OnSelectionChanged(System.Windows.Controls.SelectionChangedEventArgs)">
            <inheritdoc />
        </member>
        <member name="M:Fluent.RibbonTabControl.OnPreviewMouseWheel(System.Windows.Input.MouseWheelEventArgs)">
            <inheritdoc />
        </member>
        <member name="M:Fluent.RibbonTabControl.OnMouseWheel(System.Windows.Input.MouseWheelEventArgs)">
            <inheritdoc />
        </member>
        <member name="M:Fluent.RibbonTabControl.OnKeyDown(System.Windows.Input.KeyEventArgs)">
            <inheritdoc />
        </member>
        <member name="M:Fluent.RibbonTabControl.OnCreateAutomationPeer">
            <inheritdoc />
        </member>
        <member name="M:Fluent.RibbonTabControl.SelectFirstTab">
            <summary>
            Selects the first tab if <see cref="P:Fluent.RibbonTabControl.IsMinimized"/> is <c>false</c>.
            </summary>
        </member>
        <member name="M:Fluent.RibbonTabControl.CustomPopupPlacementMethod(System.Windows.Size,System.Windows.Size,System.Windows.Point)">
            <summary>
            Implements custom placement for ribbon popup
            </summary>
        </member>
        <member name="M:Fluent.RibbonTabControl.RaiseRequestBackstageClose">
            <summary>
            Raises an event causing the Backstage-View to be closed
            </summary>
        </member>
        <member name="M:Fluent.RibbonTabControl.GetFirstVisibleItem">
            <summary>
            Gets the first visible item
            </summary>
        </member>
        <member name="M:Fluent.RibbonTabControl.GetFirstVisibleAndEnabledItem">
            <summary>
            Gets the first visible and enabled item
            </summary>
        </member>
        <member name="M:Fluent.RibbonTabControl.Fluent#ILogicalChildSupport#AddLogicalChild(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:Fluent.RibbonTabControl.Fluent#ILogicalChildSupport#RemoveLogicalChild(System.Object)">
            <inheritdoc />
        </member>
        <member name="P:Fluent.RibbonTabControl.LogicalChildren">
            <inheritdoc />
        </member>
        <member name="T:Fluent.RibbonTabItem">
            <summary>
            Represents ribbon tab item
            </summary>
        </member>
        <member name="P:Fluent.RibbonTabItem.ActiveTabBackground">
            <summary>
            Gets or sets the <see cref="T:System.Windows.Media.Brush"/> which is used to render the background if this <see cref="T:Fluent.RibbonTabItem"/> is the currently active/selected one.
            </summary>
        </member>
        <member name="F:Fluent.RibbonTabItem.ActiveTabBackgroundProperty">
            <summary>Identifies the <see cref="P:Fluent.RibbonTabItem.ActiveTabBackground"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.RibbonTabItem.ActiveTabBorderBrush">
            <summary>
            Gets or sets the <see cref="T:System.Windows.Media.Brush"/> which is used to render the border if this <see cref="T:Fluent.RibbonTabItem"/> is the currently active/selected one.
            </summary>
        </member>
        <member name="F:Fluent.RibbonTabItem.ActiveTabBorderBrushProperty">
            <summary>Identifies the <see cref="P:Fluent.RibbonTabItem.ActiveTabBorderBrush"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.RibbonTabItem.KeyTip">
            <inheritdoc />
        </member>
        <member name="F:Fluent.RibbonTabItem.KeyTipProperty">
            <summary>
            Using a DependencyProperty as the backing store for Keys.
            This enables animation, styling, binding, etc...
            </summary>
        </member>
        <member name="P:Fluent.RibbonTabItem.GroupsContainer">
            <summary>
            Gets ribbon groups container
            </summary>
        </member>
        <member name="P:Fluent.RibbonTabItem.ReduceOrder">
            <summary>
            Gets or sets reduce order
            </summary>
        </member>
        <member name="P:Fluent.RibbonTabItem.IsContextual">
            <summary>
            Gets or sets whether tab item is contextual
            </summary>
        </member>
        <member name="F:Fluent.RibbonTabItem.IsContextualProperty">
            <summary>Identifies the <see cref="P:Fluent.RibbonTabItem.IsContextual"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.RibbonTabItem.IsSelected">
            <summary>
            Gets or sets whether tab item is selected
            </summary>
        </member>
        <member name="F:Fluent.RibbonTabItem.IsSelectedProperty">
            <summary>
            Using a DependencyProperty as the backing store for IsSelected.
            This enables animation, styling, binding, etc...
            </summary>
        </member>
        <member name="P:Fluent.RibbonTabItem.TabControlParent">
            <summary>
            Gets ribbon tab control parent
            </summary>
        </member>
        <member name="P:Fluent.RibbonTabItem.HeaderPadding">
            <summary>
            Gets or sets the padding for the header.
            </summary>
        </member>
        <member name="F:Fluent.RibbonTabItem.HeaderPaddingProperty">
            <summary>Identifies the <see cref="P:Fluent.RibbonTabItem.HeaderPadding"/> dependency property.</summary>
        </member>
        <member name="F:Fluent.RibbonTabItem.SeparatorOpacityProperty">
            <summary>Identifies the <see cref="P:Fluent.RibbonTabItem.SeparatorOpacity"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.RibbonTabItem.SeparatorOpacity">
            <summary>
            Gets or sets the opacity of the separator.
            </summary>
        </member>
        <member name="P:Fluent.RibbonTabItem.Group">
            <summary>
            Gets or sets ribbon contextual tab group
            </summary>
        </member>
        <member name="F:Fluent.RibbonTabItem.GroupProperty">
            <summary>Identifies the <see cref="P:Fluent.RibbonTabItem.Group"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.RibbonTabItem.HasLeftGroupBorder">
            <summary>
            Gets or sets whether tab item has left group border
            </summary>
        </member>
        <member name="F:Fluent.RibbonTabItem.HasLeftGroupBorderProperty">
            <summary>Identifies the <see cref="P:Fluent.RibbonTabItem.HasLeftGroupBorder"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.RibbonTabItem.HasRightGroupBorder">
            <summary>
            Gets or sets whether tab item has right group border
            </summary>
        </member>
        <member name="F:Fluent.RibbonTabItem.HasRightGroupBorderProperty">
            <summary>Identifies the <see cref="P:Fluent.RibbonTabItem.HasRightGroupBorder"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.RibbonTabItem.Groups">
            <summary>
            get collection of ribbon groups
            </summary>
        </member>
        <member name="P:Fluent.RibbonTabItem.Header">
            <inheritdoc />
        </member>
        <member name="F:Fluent.RibbonTabItem.HeaderProperty">
            <summary>Identifies the <see cref="P:Fluent.RibbonTabItem.Header"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.RibbonTabItem.HeaderTemplate">
            <inheritdoc />
        </member>
        <member name="F:Fluent.RibbonTabItem.HeaderTemplateProperty">
            <summary>Identifies the <see cref="P:Fluent.RibbonTabItem.HeaderTemplate"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.RibbonTabItem.HeaderTemplateSelector">
            <inheritdoc />
        </member>
        <member name="F:Fluent.RibbonTabItem.HeaderTemplateSelectorProperty">
            <summary>Identifies the <see cref="P:Fluent.RibbonTabItem.HeaderTemplateSelector"/> dependency property.</summary>
        </member>
        <member name="M:Fluent.RibbonTabItem.OnFocusableChanged(System.Windows.DependencyObject,System.Windows.DependencyPropertyChangedEventArgs)">
            <summary>
            Handles Focusable changes
            </summary>
        </member>
        <member name="M:Fluent.RibbonTabItem.CoerceFocusable(System.Windows.DependencyObject,System.Object)">
            <summary>
            Coerces Focusable
            </summary>
        </member>
        <member name="P:Fluent.RibbonTabItem.IsSimplified">
            <summary>
            Gets or sets whether or not the ribbon is in Simplified mode
            </summary>
        </member>
        <member name="F:Fluent.RibbonTabItem.IsSimplifiedProperty">
            <summary>Identifies the <see cref="P:Fluent.RibbonTabItem.IsSimplified"/> dependency property.</summary>
        </member>
        <member name="M:Fluent.RibbonTabItem.#cctor">
            <summary>
            Static constructor
            </summary>
        </member>
        <member name="M:Fluent.RibbonTabItem.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:Fluent.RibbonTabItem.MeasureOverride(System.Windows.Size)">
            <inheritdoc />
        </member>
        <member name="M:Fluent.RibbonTabItem.ArrangeOverride(System.Windows.Size)">
            <inheritdoc />
        </member>
        <member name="M:Fluent.RibbonTabItem.OnApplyTemplate">
            <inheritdoc />
        </member>
        <member name="M:Fluent.RibbonTabItem.OnMouseLeftButtonDown(System.Windows.Input.MouseButtonEventArgs)">
            <inheritdoc />
        </member>
        <member name="M:Fluent.RibbonTabItem.OnKeyDown(System.Windows.Input.KeyEventArgs)">
            <inheritdoc />
        </member>
        <member name="M:Fluent.RibbonTabItem.OnGotKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs)">
            <inheritdoc />
        </member>
        <member name="M:Fluent.RibbonTabItem.OnCreateAutomationPeer">
            <inheritdoc />
        </member>
        <member name="M:Fluent.RibbonTabItem.OnSelected(System.Windows.RoutedEventArgs)">
            <summary>
            Handles selected
            </summary>
            <param name="e">The event data</param>
        </member>
        <member name="M:Fluent.RibbonTabItem.OnUnselected(System.Windows.RoutedEventArgs)">
            <summary>
            handles unselected
            </summary>
            <param name="e">The event data</param>
        </member>
        <member name="M:Fluent.RibbonTabItem.OnKeyTipPressed">
            <inheritdoc />
        </member>
        <member name="M:Fluent.RibbonTabItem.OnKeyTipBack">
            <inheritdoc />
        </member>
        <member name="M:Fluent.RibbonTabItem.Fluent#ISimplifiedStateControl#UpdateSimplifiedState(System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:Fluent.RibbonTabItem.Fluent#ILogicalChildSupport#AddLogicalChild(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:Fluent.RibbonTabItem.Fluent#ILogicalChildSupport#RemoveLogicalChild(System.Object)">
            <inheritdoc />
        </member>
        <member name="P:Fluent.RibbonTabItem.LogicalChildren">
            <inheritdoc />
        </member>
        <member name="T:Fluent.RibbonTabsContainer">
            <summary>
            Represent panel with ribbon tab items.
            It is automatically adjusting size of tabs
            </summary>
        </member>
        <member name="M:Fluent.RibbonTabsContainer.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Fluent.RibbonTabsContainer"/> class.
            </summary>
        </member>
        <member name="M:Fluent.RibbonTabsContainer.MeasureOverride(System.Windows.Size)">
            <inheritdoc />
        </member>
        <member name="M:Fluent.RibbonTabsContainer.ArrangeOverride(System.Windows.Size)">
            <inheritdoc />
        </member>
        <member name="M:Fluent.RibbonTabsContainer.UpdateSeparators(System.Double)">
            <summary>
            Updates separator visibility
            </summary>
            <param name="opacity">If this parameter true, tabs will have separators</param>
        </member>
        <member name="P:Fluent.RibbonTabsContainer.ScrollOwner">
            <inheritdoc />
        </member>
        <member name="M:Fluent.RibbonTabsContainer.SetHorizontalOffset(System.Double)">
            <inheritdoc />
        </member>
        <member name="P:Fluent.RibbonTabsContainer.ExtentWidth">
            <inheritdoc />
        </member>
        <member name="P:Fluent.RibbonTabsContainer.HorizontalOffset">
            <inheritdoc />
        </member>
        <member name="P:Fluent.RibbonTabsContainer.ViewportWidth">
            <inheritdoc />
        </member>
        <member name="M:Fluent.RibbonTabsContainer.LineLeft">
            <inheritdoc />
        </member>
        <member name="M:Fluent.RibbonTabsContainer.LineRight">
            <inheritdoc />
        </member>
        <member name="M:Fluent.RibbonTabsContainer.MakeVisible(System.Windows.Media.Visual,System.Windows.Rect)">
            <inheritdoc />
        </member>
        <member name="M:Fluent.RibbonTabsContainer.MouseWheelDown">
            <summary>
            Not implemented
            </summary>
        </member>
        <member name="M:Fluent.RibbonTabsContainer.MouseWheelLeft">
            <inheritdoc />
        </member>
        <member name="M:Fluent.RibbonTabsContainer.MouseWheelRight">
            <inheritdoc />
        </member>
        <member name="M:Fluent.RibbonTabsContainer.MouseWheelUp">
            <summary>
            Not implemented
            </summary>
        </member>
        <member name="M:Fluent.RibbonTabsContainer.LineDown">
            <summary>
            Not implemented
            </summary>
        </member>
        <member name="M:Fluent.RibbonTabsContainer.LineUp">
            <summary>
            Not implemented
            </summary>
        </member>
        <member name="M:Fluent.RibbonTabsContainer.PageDown">
            <summary>
            Not implemented
            </summary>
        </member>
        <member name="M:Fluent.RibbonTabsContainer.PageLeft">
            <inheritdoc />
        </member>
        <member name="M:Fluent.RibbonTabsContainer.PageRight">
            <inheritdoc />
        </member>
        <member name="M:Fluent.RibbonTabsContainer.PageUp">
            <summary>
            Not implemented
            </summary>
        </member>
        <member name="M:Fluent.RibbonTabsContainer.SetVerticalOffset(System.Double)">
            <summary>
            Not implemented
            </summary>
        </member>
        <member name="P:Fluent.RibbonTabsContainer.CanVerticallyScroll">
            <inheritdoc />
        </member>
        <member name="P:Fluent.RibbonTabsContainer.CanHorizontallyScroll">
            <inheritdoc />
        </member>
        <member name="P:Fluent.RibbonTabsContainer.ExtentHeight">
            <summary>
            Not implemented
            </summary>
        </member>
        <member name="P:Fluent.RibbonTabsContainer.VerticalOffset">
            <summary>
            Not implemented
            </summary>
        </member>
        <member name="P:Fluent.RibbonTabsContainer.ViewportHeight">
            <summary>
            Not implemented
            </summary>
        </member>
        <member name="T:Fluent.ScrollData">
            <summary>
            Helper class to hold scrolling data.
            This class exists to reduce working set when SCP is delegating to another implementation of ISI.
            Standard "extra pointer always for less data sometimes" cache savings model:
            </summary>
        </member>
        <member name="P:Fluent.ScrollData.ScrollOwner">
            <summary>
            Scroll viewer
            </summary>
        </member>
        <member name="P:Fluent.ScrollData.OffsetX">
            <summary>
            Scroll offset
            </summary>
        </member>
        <member name="P:Fluent.ScrollData.ViewportWidth">
            <summary>
            ViewportSize is computed from our FinalSize, but may be in different units.
            </summary>
        </member>
        <member name="P:Fluent.ScrollData.ExtentWidth">
            <summary>
            Extent is the total size of our content.
            </summary>
        </member>
        <member name="T:Fluent.RibbonTitleBar">
            <summary>
            Represents title bar
            </summary>
        </member>
        <member name="P:Fluent.RibbonTitleBar.QuickAccessToolBar">
            <summary>
            Gets or sets quick access toolbar
            </summary>
        </member>
        <member name="F:Fluent.RibbonTitleBar.QuickAccessToolBarProperty">
            <summary>Identifies the <see cref="P:Fluent.RibbonTitleBar.QuickAccessToolBar"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.RibbonTitleBar.HeaderAlignment">
            <summary>
            Gets or sets header alignment
            </summary>
        </member>
        <member name="F:Fluent.RibbonTitleBar.HeaderAlignmentProperty">
            <summary>Identifies the <see cref="P:Fluent.RibbonTitleBar.HeaderAlignment"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.RibbonTitleBar.IsCollapsed">
            <summary>
            Defines whether title bar is collapsed
            </summary>
        </member>
        <member name="F:Fluent.RibbonTitleBar.IsCollapsedProperty">
            <summary>Identifies the <see cref="P:Fluent.RibbonTitleBar.IsCollapsed"/> dependency property.</summary>
        </member>
        <member name="F:Fluent.RibbonTitleBar.HideContextTabsProperty">
            <summary>Identifies the <see cref="P:Fluent.RibbonTitleBar.HideContextTabs"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.RibbonTitleBar.HideContextTabs">
            <summary>
             Gets or sets whether context tabs are hidden.
            </summary>
        </member>
        <member name="M:Fluent.RibbonTitleBar.#cctor">
            <summary>
            Static constructor
            </summary>
        </member>
        <member name="M:Fluent.RibbonTitleBar.HitTestCore(System.Windows.Media.PointHitTestParameters)">
            <inheritdoc />
        </member>
        <member name="M:Fluent.RibbonTitleBar.OnMouseRightButtonUp(System.Windows.Input.MouseButtonEventArgs)">
            <inheritdoc />
        </member>
        <member name="M:Fluent.RibbonTitleBar.OnMouseLeftButtonDown(System.Windows.Input.MouseButtonEventArgs)">
            <inheritdoc />
        </member>
        <member name="M:Fluent.RibbonTitleBar.GetContainerForItemOverride">
            <inheritdoc />
        </member>
        <member name="M:Fluent.RibbonTitleBar.IsItemItsOwnContainerOverride(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:Fluent.RibbonTitleBar.OnApplyTemplate">
            <inheritdoc />
        </member>
        <member name="M:Fluent.RibbonTitleBar.MeasureOverride(System.Windows.Size)">
            <inheritdoc />
        </member>
        <member name="M:Fluent.RibbonTitleBar.ArrangeOverride(System.Windows.Size)">
            <inheritdoc />
        </member>
        <member name="M:Fluent.RibbonTitleBar.EnsureCorrectLayoutAfterArrange">
            <summary>
            Sometimes the relative position only changes after the arrange phase.
            To compensate such sitiations we issue a second layout pass by invalidating our measure.
            This situation can occur if, for example, the icon of a ribbon window has it's visibility changed.
            </summary>
        </member>
        <member name="M:Fluent.RibbonTitleBar.ScheduleForceMeasureAndArrange">
            <summary>
            Schedules a call to <see cref="M:Fluent.Extensions.FrameworkElementExtensions.ForceMeasureAndArrangeImmediate(System.Windows.FrameworkElement)"/>.
            </summary>
        </member>
        <member name="M:Fluent.RibbonTitleBar.OnCreateAutomationPeer">
            <inheritdoc />
        </member>
        <member name="T:Fluent.RibbonToolBar">
            <summary>
            Represent panel for group box panel
            </summary>
        </member>
        <member name="P:Fluent.RibbonToolBar.SeparatorStyle">
            <summary>
            Gets or sets style for the separator
            </summary>
        </member>
        <member name="F:Fluent.RibbonToolBar.SeparatorStyleProperty">
            <summary>Identifies the <see cref="P:Fluent.RibbonToolBar.SeparatorStyle"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.RibbonToolBar.IsSimplified">
            <summary>
            Gets or sets whether or not the ribbon is in Simplified mode
            </summary>
        </member>
        <member name="F:Fluent.RibbonToolBar.IsSimplifiedProperty">
            <summary>Identifies the <see cref="P:Fluent.RibbonToolBar.IsSimplified"/> dependency property.</summary>
        </member>
        <member name="M:Fluent.RibbonToolBar.OnIsSimplifiedChanged(System.Windows.DependencyObject,System.Windows.DependencyPropertyChangedEventArgs)">
            <summary>
            Called when <see cref="P:Fluent.RibbonToolBar.IsSimplified"/> changes.
            </summary>
        </member>
        <member name="P:Fluent.RibbonToolBar.Children">
            <summary>
            Gets children
            </summary>
        </member>
        <member name="P:Fluent.RibbonToolBar.LayoutDefinitions">
            <summary>
            Gets particular rules  for layout in this group box panel
            </summary>
        </member>
        <member name="P:Fluent.RibbonToolBar.VisualChildrenCount">
            <inheritdoc />
        </member>
        <member name="M:Fluent.RibbonToolBar.GetVisualChild(System.Int32)">
            <inheritdoc />
        </member>
        <member name="P:Fluent.RibbonToolBar.LogicalChildren">
            <inheritdoc />
        </member>
        <member name="M:Fluent.RibbonToolBar.#cctor">
            <summary>
            Static constructor
            </summary>
        </member>
        <member name="M:Fluent.RibbonToolBar.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:Fluent.RibbonToolBar.GetCurrentLayoutDefinition">
            <summary>
            Gets current used layout definition (or null if no present definitions)
            </summary>
            <returns>Layout definition or null</returns>
        </member>
        <member name="M:Fluent.RibbonToolBar.OnSizePropertyChanged(Fluent.RibbonControlSize,Fluent.RibbonControlSize)">
            <inheritdoc />
        </member>
        <member name="M:Fluent.RibbonToolBar.Fluent#ISimplifiedStateControl#UpdateSimplifiedState(System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:Fluent.RibbonToolBar.MeasureOverride(System.Windows.Size)">
            <inheritdoc />
        </member>
        <member name="M:Fluent.RibbonToolBar.ArrangeOverride(System.Windows.Size)">
            <inheritdoc />
        </member>
        <member name="M:Fluent.RibbonToolBar.WrapPanelLayuot(System.Windows.Size,System.Boolean)">
            <summary>
            Unified method for wrap panel logic
            </summary>
            <param name="availableSize">Available or final size</param>
            <param name="measure">Pass true if measure required; pass false if arrange required</param>
            <returns>Final size</returns>
        </member>
        <member name="M:Fluent.RibbonToolBar.CustomLayout(Fluent.RibbonToolBarLayoutDefinition,System.Windows.Size,System.Boolean,System.Boolean)">
            <summary>
            Layout logic for the given layout definition
            </summary>
            <param name="layoutDefinition">Current layout definition</param>
            <param name="availableSize">Available or final size</param>
            <param name="measure">Pass true if measure required; pass false if arrange required</param>
            <param name="addchildren">Determines whether we have to add children to the logical and visual tree</param>
            <returns>Final size</returns>
        </member>
        <member name="M:Fluent.RibbonToolBar.CreateQuickAccessItem">
            <inheritdoc />
        </member>
        <member name="T:Fluent.RibbonToolBarControlDefinition">
            <summary>
            Represent logical definition for a control in toolbar
            </summary>
        </member>
        <member name="M:Fluent.RibbonToolBarControlDefinition.#ctor">
            <summary>
            Creates a new instance
            </summary>
        </member>
        <member name="P:Fluent.RibbonToolBarControlDefinition.Size">
            <summary>
            Gets or sets Size for the element.
            </summary>
        </member>
        <member name="F:Fluent.RibbonToolBarControlDefinition.SizeProperty">
            <summary>Identifies the <see cref="P:Fluent.RibbonToolBarControlDefinition.Size"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.RibbonToolBarControlDefinition.SizeDefinition">
            <summary>
            Gets or sets SizeDefinition for element.
            </summary>
        </member>
        <member name="F:Fluent.RibbonToolBarControlDefinition.SizeDefinitionProperty">
            <summary>Identifies the <see cref="P:Fluent.RibbonToolBarControlDefinition.SizeDefinition"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.RibbonToolBarControlDefinition.Target">
            <summary>
            Gets or sets name of the target control
            </summary>
        </member>
        <member name="F:Fluent.RibbonToolBarControlDefinition.TargetProperty">
            <summary>Identifies the <see cref="P:Fluent.RibbonToolBarControlDefinition.Target"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.RibbonToolBarControlDefinition.Width">
            <summary>
            Gets or sets width of the target control
            </summary>
        </member>
        <member name="F:Fluent.RibbonToolBarControlDefinition.WidthProperty">
            <summary>Identifies the <see cref="P:Fluent.RibbonToolBarControlDefinition.Width"/> dependency property.</summary>
        </member>
        <member name="E:Fluent.RibbonToolBarControlDefinition.PropertyChanged">
            <inheritdoc />
        </member>
        <member name="M:Fluent.RibbonToolBarControlDefinition.OnSizePropertyChanged(Fluent.RibbonControlSize,Fluent.RibbonControlSize)">
            <inheritdoc />
        </member>
        <member name="T:Fluent.RibbonToolBarControlGroup">
            <summary>
            Represent logical container for toolbar items
            </summary>
        </member>
        <member name="P:Fluent.RibbonToolBarControlGroup.IsFirstInRow">
            <summary>
            Gets whether the group is the fisrt control in the row
            </summary>
        </member>
        <member name="F:Fluent.RibbonToolBarControlGroup.IsFirstInRowProperty">
            <summary>Identifies the <see cref="P:Fluent.RibbonToolBarControlGroup.IsFirstInRow"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.RibbonToolBarControlGroup.IsLastInRow">
            <summary>
            Gets whether the group is the last control in the row
            </summary>
        </member>
        <member name="F:Fluent.RibbonToolBarControlGroup.IsLastInRowProperty">
            <summary>Identifies the <see cref="P:Fluent.RibbonToolBarControlGroup.IsLastInRow"/> dependency property.</summary>
        </member>
        <member name="T:Fluent.RibbonToolBarControlGroupDefinition">
            <summary>
            Represent logical container for toolbar items
            </summary>
        </member>
        <member name="E:Fluent.RibbonToolBarControlGroupDefinition.ChildrenChanged">
            <summary>
            Occures when children has been changed
            </summary>
        </member>
        <member name="P:Fluent.RibbonToolBarControlGroupDefinition.Children">
            <summary>
            Gets rows
            </summary>
        </member>
        <member name="M:Fluent.RibbonToolBarControlGroupDefinition.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="T:Fluent.RibbonToolBarLayoutDefinition">
            <summary>
            Represents size definition for group box
            </summary>
        </member>
        <member name="P:Fluent.RibbonToolBarLayoutDefinition.Size">
            <summary>
            Gets or sets Size for the element.
            </summary>
        </member>
        <member name="F:Fluent.RibbonToolBarLayoutDefinition.SizeProperty">
            <summary>Identifies the <see cref="P:Fluent.RibbonToolBarLayoutDefinition.Size"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.RibbonToolBarLayoutDefinition.SizeDefinition">
            <summary>
            Gets or sets SizeDefinition for element.
            </summary>
        </member>
        <member name="F:Fluent.RibbonToolBarLayoutDefinition.SizeDefinitionProperty">
            <summary>Identifies the <see cref="P:Fluent.RibbonToolBarLayoutDefinition.SizeDefinition"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.RibbonToolBarLayoutDefinition.RowCount">
            <summary>
            Gets or sets count of rows in the ribbon toolbar
            </summary>
        </member>
        <member name="F:Fluent.RibbonToolBarLayoutDefinition.RowCountProperty">
            <summary>Identifies the <see cref="P:Fluent.RibbonToolBarLayoutDefinition.RowCount"/> dependency property.</summary>
        </member>
        <member name="F:Fluent.RibbonToolBarLayoutDefinition.ForSimplifiedProperty">
            <summary>Identifies the <see cref="P:Fluent.RibbonToolBarLayoutDefinition.ForSimplified"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.RibbonToolBarLayoutDefinition.ForSimplified">
            <summary>
            Gets or sets whether the layout definition should be used in simplified state.
            </summary>
        </member>
        <member name="P:Fluent.RibbonToolBarLayoutDefinition.Rows">
            <summary>
            Gets rows
            </summary>
        </member>
        <member name="T:Fluent.RibbonToolBarRow">
            <summary>
            Represents size definition for group box
            </summary>
        </member>
        <member name="P:Fluent.RibbonToolBarRow.Children">
            <summary>
            Gets children.
            </summary>
        </member>
        <member name="T:Fluent.RibbonWindow">
            <summary>
            Represents basic window for ribbon
            </summary>
        </member>
        <member name="P:Fluent.RibbonWindow.TitleBar">
            <inheritdoc />
        </member>
        <member name="F:Fluent.RibbonWindow.TitleBarProperty">
            <summary>Identifies the <see cref="P:Fluent.RibbonWindow.TitleBar"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.RibbonWindow.TitleBarHeight">
            <summary>
            Gets or sets the height which is used to render the window title.
            </summary>
        </member>
        <member name="F:Fluent.RibbonWindow.TitleBarHeightProperty">
            <summary>Identifies the <see cref="P:Fluent.RibbonWindow.TitleBarHeight"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.RibbonWindow.TitleForeground">
            <summary>
            Gets or sets the <see cref="T:System.Windows.Media.Brush"/> which is used to render the window title.
            </summary>
        </member>
        <member name="F:Fluent.RibbonWindow.TitleForegroundProperty">
            <summary>Identifies the <see cref="P:Fluent.RibbonWindow.TitleForeground"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.RibbonWindow.TitleBackground">
            <summary>
            Gets or sets the <see cref="T:System.Windows.Media.Brush"/> which is used to render the window title background.
            </summary>
        </member>
        <member name="F:Fluent.RibbonWindow.TitleBackgroundProperty">
            <summary>Identifies the <see cref="P:Fluent.RibbonWindow.TitleBackground"/> dependency property.</summary>
        </member>
        <member name="F:Fluent.RibbonWindow.WindowCommandsProperty">
            <summary>Identifies the <see cref="P:Fluent.RibbonWindow.WindowCommands"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.RibbonWindow.WindowCommands">
            <summary>
            Gets or sets the window commands
            </summary>
        </member>
        <member name="F:Fluent.RibbonWindow.NonActiveBorderBrushProperty">
            <summary>Identifies the <see cref="P:Fluent.RibbonWindow.NonActiveBorderBrush"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.RibbonWindow.NonActiveBorderBrush">
            <summary>
            Gets or sets a brush which is used as the border brush when the window is not active.
            </summary>
        </member>
        <member name="P:Fluent.RibbonWindow.IsIconVisible">
            <summary>
            Gets or sets whether icon is visible.
            </summary>
        </member>
        <member name="F:Fluent.RibbonWindow.IsIconVisibleProperty">
            <summary>Identifies the <see cref="P:Fluent.RibbonWindow.IsIconVisible"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.RibbonWindow.VerticalIconAlignment">
            <summary>
            Gets or sets the vertical alignment of the icon.
            </summary>
        </member>
        <member name="F:Fluent.RibbonWindow.VerticalIconAlignmentProperty">
            <summary>Identifies the <see cref="P:Fluent.RibbonWindow.VerticalIconAlignment"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.RibbonWindow.IsCollapsed">
            <summary>
            Gets whether window is collapsed
            </summary>
        </member>
        <member name="F:Fluent.RibbonWindow.IsCollapsedProperty">
            <summary>Identifies the <see cref="P:Fluent.RibbonWindow.IsCollapsed"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.RibbonWindow.IsAutomaticCollapseEnabled">
            <summary>
            Defines if the Ribbon should automatically set <see cref="P:Fluent.RibbonWindow.IsCollapsed"/> when the width or height of the owner window drop under <see cref="F:Fluent.Ribbon.MinimalVisibleWidth"/> or <see cref="F:Fluent.Ribbon.MinimalVisibleHeight"/>
            </summary>
        </member>
        <member name="F:Fluent.RibbonWindow.IsAutomaticCollapseEnabledProperty">
            <summary>Identifies the <see cref="P:Fluent.RibbonWindow.IsAutomaticCollapseEnabled"/> dependency property.</summary>
        </member>
        <member name="M:Fluent.RibbonWindow.#cctor">
            <summary>
            Static constructor
            </summary>
        </member>
        <member name="M:Fluent.RibbonWindow.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:Fluent.RibbonWindow.OnApplyTemplate">
            <inheritdoc />
        </member>
        <member name="M:Fluent.RibbonWindow.OnStateChanged(System.EventArgs)">
            <inheritdoc />
        </member>
        <member name="M:Fluent.RibbonWindow.GetPart``1(System.String)">
            <summary>
            Gets the template child with the given name.
            </summary>
            <typeparam name="T">The interface type inheirted from DependencyObject.</typeparam>
            <param name="name">The name of the template child.</param>
        </member>
        <member name="T:Fluent.ScreenTip">
            <summary>
            ScreenTips display the name of the control,
            the keyboard shortcut for the control, and a brief description
            of how to use the control. ScreenTips also can provide F1 support,
            which opens help and takes the user directly to the related
            help topic for the control whose ScreenTip was
            displayed when the F1 button was pressed
            </summary>
        </member>
        <member name="M:Fluent.ScreenTip.#cctor">
            <summary>
            Static constructor
            </summary>
        </member>
        <member name="M:Fluent.ScreenTip.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="P:Fluent.ScreenTip.Title">
            <summary>
            Gets or sets title of the screen tip
            </summary>
        </member>
        <member name="F:Fluent.ScreenTip.TitleProperty">
            <summary>Identifies the <see cref="P:Fluent.ScreenTip.Title"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.ScreenTip.Text">
            <summary>
            Gets or sets text of the screen tip
            </summary>
        </member>
        <member name="F:Fluent.ScreenTip.TextProperty">
            <summary>Identifies the <see cref="P:Fluent.ScreenTip.Text"/> dependency property.</summary>
        </member>
        <member name="F:Fluent.ScreenTip.TextTemplateProperty">
            <summary>Identifies the <see cref="P:Fluent.ScreenTip.TextTemplate"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.ScreenTip.TextTemplate">
            <summary>
            Defines the <see cref="T:System.Windows.DataTemplate"/> being used to render <see cref="P:Fluent.ScreenTip.Text"/>.
            </summary>
        </member>
        <member name="P:Fluent.ScreenTip.DisableReason">
            <summary>
            Gets or sets disable reason of the associated screen tip's control
            </summary>
        </member>
        <member name="F:Fluent.ScreenTip.DisableReasonProperty">
            <summary>Identifies the <see cref="P:Fluent.ScreenTip.DisableReason"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.ScreenTip.HelpTopic">
            <summary>
            Gets or sets help topic of the ScreenTip
            </summary>
        </member>
        <member name="F:Fluent.ScreenTip.HelpTopicProperty">
            <summary>Identifies the <see cref="P:Fluent.ScreenTip.HelpTopic"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.ScreenTip.Image">
            <summary>
            Gets or sets image of the screen tip
            </summary>
        </member>
        <member name="F:Fluent.ScreenTip.ImageProperty">
            <summary>Identifies the <see cref="P:Fluent.ScreenTip.Image"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.ScreenTip.HelpLabelVisibility">
            <summary>
            Shows or hides the Help Label
            </summary>
        </member>
        <member name="F:Fluent.ScreenTip.HelpLabelVisibilityProperty">
            <summary>Identifies the <see cref="P:Fluent.ScreenTip.HelpLabelVisibility"/> dependency property.</summary>
        </member>
        <member name="E:Fluent.ScreenTip.HelpPressed">
            <summary>
            Occurs when user press F1 on ScreenTip with HelpTopic filled
            </summary>
        </member>
        <member name="P:Fluent.ScreenTip.IsRibbonAligned">
            <summary>
            Gets or set whether ScreenTip should positioned below Ribbon
            </summary>
        </member>
        <member name="F:Fluent.ScreenTip.IsRibbonAlignedProperty">
            <summary>Identifies the <see cref="P:Fluent.ScreenTip.IsRibbonAligned"/> dependency property.</summary>
        </member>
        <member name="M:Fluent.ScreenTip.OnCreateAutomationPeer">
            <inheritdoc />
        </member>
        <member name="M:Fluent.ScreenTip.Fluent#ILogicalChildSupport#AddLogicalChild(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:Fluent.ScreenTip.Fluent#ILogicalChildSupport#RemoveLogicalChild(System.Object)">
            <inheritdoc />
        </member>
        <member name="P:Fluent.ScreenTip.LogicalChildren">
            <inheritdoc />
        </member>
        <member name="T:Fluent.ScreenTipHelpEventArgs">
            <summary>
            Event args for HelpPressed event handler
            </summary>
        </member>
        <member name="M:Fluent.ScreenTipHelpEventArgs.#ctor(System.Object)">
            <summary>
            Constructor
            </summary>
            <param name="helpTopic">Help topic</param>
        </member>
        <member name="P:Fluent.ScreenTipHelpEventArgs.HelpTopic">
            <summary>
            Gets help topic associated with screen tip
            </summary>
        </member>
        <member name="T:Fluent.SeparatorTabItem">
            <summary>
            Represents separator to use in the TabControl
            </summary>
        </member>
        <member name="M:Fluent.SeparatorTabItem.#cctor">
            <summary>
            Static constructor
            </summary>
        </member>
        <member name="T:Fluent.Spinner">
            <summary>
            Represents spinner control
            </summary>
        </member>
        <member name="E:Fluent.Spinner.ValueChanged">
            <summary>
            Occurs when value has been changed
            </summary>
        </member>
        <member name="P:Fluent.Spinner.SimplifiedSizeDefinition">
            <inheritdoc />
        </member>
        <member name="F:Fluent.Spinner.SimplifiedSizeDefinitionProperty">
            <summary>Identifies the <see cref="P:Fluent.Spinner.SimplifiedSizeDefinition"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.Spinner.MediumIcon">
            <inheritdoc />
        </member>
        <member name="F:Fluent.Spinner.MediumIconProperty">
            <summary>Identifies the <see cref="P:Fluent.Spinner.MediumIcon"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.Spinner.Value">
            <summary>
            Gets or sets current value
            </summary>
        </member>
        <member name="F:Fluent.Spinner.ValueProperty">
            <summary>
            Using a DependencyProperty as the backing store for Value.
            This enables animation, styling, binding, etc...
            </summary>
        </member>
        <member name="P:Fluent.Spinner.Text">
            <summary>
            Gets current text from the spinner
            </summary>
        </member>
        <member name="F:Fluent.Spinner.TextProperty">
            <summary>Identifies the <see cref="P:Fluent.Spinner.Text"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.Spinner.Increment">
            <summary>
            Gets or sets a value added or subtracted from the value property
            </summary>
        </member>
        <member name="F:Fluent.Spinner.IncrementProperty">
            <summary>Identifies the <see cref="P:Fluent.Spinner.Increment"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.Spinner.Minimum">
            <summary>
            Gets or sets minimun value
            </summary>
        </member>
        <member name="F:Fluent.Spinner.MinimumProperty">
            <summary>
            Using a DependencyProperty as the backing store for Minimum.
            This enables animation, styling, binding, etc...
            </summary>
        </member>
        <member name="P:Fluent.Spinner.Maximum">
            <summary>
            Gets or sets maximum value
            </summary>
        </member>
        <member name="F:Fluent.Spinner.MaximumProperty">
            <summary>
            Using a DependencyProperty as the backing store for Maximum.
            This enables animation, styling, binding, etc...
            </summary>
        </member>
        <member name="P:Fluent.Spinner.Format">
            <summary>
            Gets or sets string format of value
            </summary>
        </member>
        <member name="F:Fluent.Spinner.FormatProperty">
            <summary>Identifies the <see cref="P:Fluent.Spinner.Format"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.Spinner.Delay">
            <summary>
            Gets or sets the amount of time, in milliseconds,
            the Spinner waits while it is pressed before it starts repeating.
            The value must be non-negative. This is a dependency property.
            </summary>
        </member>
        <member name="F:Fluent.Spinner.DelayProperty">
            <summary>Identifies the <see cref="P:Fluent.Spinner.Delay"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.Spinner.Interval">
            <summary>
            Gets or sets the amount of time, in milliseconds,
            between repeats once repeating starts. The value must be non-negative.
            This is a dependency property.
            </summary>
        </member>
        <member name="F:Fluent.Spinner.IntervalProperty">
            <summary>Identifies the <see cref="P:Fluent.Spinner.Interval"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.Spinner.TextToValueConverter">
            <summary>
            Gets or sets a converter which is used to convert from text to double and from double to text.
            </summary>
        </member>
        <member name="F:Fluent.Spinner.TextToValueConverterProperty">
            <summary>Identifies the <see cref="P:Fluent.Spinner.TextToValueConverter"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.Spinner.SelectAllTextOnFocus">
            <summary>
            Defines whether all text should be select as soon as this control gets focus.
            </summary>
        </member>
        <member name="F:Fluent.Spinner.SelectAllTextOnFocusProperty">
            <summary>Identifies the <see cref="P:Fluent.Spinner.SelectAllTextOnFocus"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.Spinner.IsSimplified">
            <summary>
            Gets or sets whether or not the ribbon is in Simplified mode
            </summary>
        </member>
        <member name="F:Fluent.Spinner.IsSimplifiedProperty">
            <summary>Identifies the <see cref="P:Fluent.Spinner.IsSimplified"/> dependency property.</summary>
        </member>
        <member name="M:Fluent.Spinner.#cctor">
            <summary>
            Static constructor
            </summary>
        </member>
        <member name="M:Fluent.Spinner.SelectAll">
            <summary>
            Select all text in the Spinner.
            </summary>
        </member>
        <member name="M:Fluent.Spinner.OnApplyTemplate">
            <summary>
            When overridden in a derived class, is invoked whenever application code or internal processes call <see cref="M:System.Windows.FrameworkElement.ApplyTemplate"/>.
            </summary>
        </member>
        <member name="M:Fluent.Spinner.OnKeyTipPressed">
            <inheritdoc />
        </member>
        <member name="M:Fluent.Spinner.OnKeyUp(System.Windows.Input.KeyEventArgs)">
            <summary>
            Invoked when an unhandled System.Windows.Input.Keyboard.KeyUp attached event reaches
            an element in its route that is derived from this class. Implement this method to add class handling for this event.
            </summary>
            <param name="e">The System.Windows.Input.KeyEventArgs that contains the event data.</param>
        </member>
        <member name="M:Fluent.Spinner.CreateQuickAccessItem">
            <summary>
            Gets control which represents shortcut item.
            This item MUST be syncronized with the original
            and send command to original one control.
            </summary>
            <returns>Control which represents shortcut item</returns>
        </member>
        <member name="M:Fluent.Spinner.BindQuickAccessItem(System.Windows.FrameworkElement)">
            <summary>
            This method must be overriden to bind properties to use in quick access creating
            </summary>
            <param name="element">Toolbar item</param>
        </member>
        <member name="M:Fluent.Spinner.Fluent#ISimplifiedStateControl#UpdateSimplifiedState(System.Boolean)">
            <inheritdoc />
        </member>
        <member name="P:Fluent.Spinner.LogicalChildren">
            <inheritdoc />
        </member>
        <member name="T:Fluent.SplitButton">
            <summary>
            Represents button control that allows
            you to add menu and handle clicks
            </summary>
        </member>
        <member name="P:Fluent.SplitButton.Command">
            <inheritdoc />
        </member>
        <member name="P:Fluent.SplitButton.CommandParameter">
            <inheritdoc />
        </member>
        <member name="P:Fluent.SplitButton.CommandTarget">
            <inheritdoc />
        </member>
        <member name="F:Fluent.SplitButton.CommandParameterProperty">
            <summary>Identifies the <see cref="P:Fluent.SplitButton.CommandParameter"/> dependency property.</summary>
        </member>
        <member name="F:Fluent.SplitButton.CommandProperty">
            <summary>Identifies the <see cref="P:Fluent.SplitButton.Command"/> dependency property.</summary>
        </member>
        <member name="F:Fluent.SplitButton.CommandTargetProperty">
            <summary>Identifies the <see cref="P:Fluent.SplitButton.CommandTarget"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.SplitButton.GroupName">
            <inheritdoc />
        </member>
        <member name="F:Fluent.SplitButton.GroupNameProperty">
            <summary>Identifies the <see cref="P:Fluent.SplitButton.GroupName"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.SplitButton.IsChecked">
            <inheritdoc />
        </member>
        <member name="F:Fluent.SplitButton.IsCheckedProperty">
            <summary>Identifies the <see cref="P:Fluent.SplitButton.IsChecked"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.SplitButton.IsCheckable">
            <summary>
            Gets or sets a value indicating whether SplitButton can be checked
            </summary>
        </member>
        <member name="F:Fluent.SplitButton.IsCheckableProperty">
            <summary>Identifies the <see cref="P:Fluent.SplitButton.IsCheckable"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.SplitButton.DropDownToolTip">
            <summary>
            Gets or sets tooltip of dropdown part of split button
            </summary>
        </member>
        <member name="F:Fluent.SplitButton.DropDownToolTipProperty">
            <summary>Identifies the <see cref="P:Fluent.SplitButton.DropDownToolTip"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.SplitButton.IsButtonEnabled">
            <summary>
            Gets or sets a value indicating whether the button part of split button is enabled.
            If you want to disable the button part and the DropDown please use <see cref="P:System.Windows.UIElement.IsEnabled"/>.
            </summary>
        </member>
        <member name="F:Fluent.SplitButton.IsButtonEnabledProperty">
            <summary>Identifies the <see cref="P:Fluent.SplitButton.IsButtonEnabled"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.SplitButton.IsDefinitive">
            <summary>
            Gets or sets whether ribbon control click must close backstage
            </summary>
        </member>
        <member name="F:Fluent.SplitButton.IsDefinitiveProperty">
            <summary>Identifies the <see cref="P:Fluent.SplitButton.IsDefinitive"/> dependency property.</summary>
        </member>
        <member name="F:Fluent.SplitButton.PrimaryActionKeyTipPostfixProperty">
            <summary>Identifies the <see cref="P:Fluent.SplitButton.PrimaryActionKeyTipPostfix"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.SplitButton.PrimaryActionKeyTipPostfix">
            <summary>
            Gets or sets the postfix for the primary keytip action.
            </summary>
        </member>
        <member name="F:Fluent.SplitButton.SecondaryActionKeyTipPostfixProperty">
            <summary>Identifies the <see cref="P:Fluent.SplitButton.SecondaryActionKeyTipPostfix"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.SplitButton.SecondaryActionKeyTipPostfix">
            <summary>
            Gets or sets the postfix for the secondary keytip action.
            </summary>
        </member>
        <member name="F:Fluent.SplitButton.SecondaryKeyTipProperty">
            <summary>Identifies the <see cref="P:Fluent.SplitButton.SecondaryKeyTip"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.SplitButton.SecondaryKeyTip">
            <summary>
            Gets or sets the keytip for the secondary action.
            </summary>
        </member>
        <member name="F:Fluent.SplitButton.ClickEvent">
            <summary>
            Occurs when user clicks
            </summary>
        </member>
        <member name="E:Fluent.SplitButton.Click">
            <summary>
            Occurs when user clicks
            </summary>
        </member>
        <member name="F:Fluent.SplitButton.CheckedEvent">
            <summary>
            Occurs when button is checked
            </summary>
        </member>
        <member name="E:Fluent.SplitButton.Checked">
            <summary>
            Occurs when button is checked
            </summary>
        </member>
        <member name="F:Fluent.SplitButton.UncheckedEvent">
            <summary>
            Occurs when button is unchecked
            </summary>
        </member>
        <member name="E:Fluent.SplitButton.Unchecked">
            <summary>
            Occurs when button is unchecked
            </summary>
        </member>
        <member name="F:Fluent.SplitButton.IndeterminateEvent">
            <summary>
            Occurs when button is unchecked
            </summary>
        </member>
        <member name="E:Fluent.SplitButton.Indeterminate">
            <summary>
            Occurs when button is unchecked
            </summary>
        </member>
        <member name="M:Fluent.SplitButton.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:Fluent.SplitButton.OnApplyTemplate">
            <inheritdoc />
        </member>
        <member name="M:Fluent.SplitButton.OnPreviewMouseLeftButtonDown(System.Windows.Input.MouseButtonEventArgs)">
            <inheritdoc />
        </member>
        <member name="M:Fluent.SplitButton.OnCreateAutomationPeer">
            <inheritdoc />
        </member>
        <member name="M:Fluent.SplitButton.OnKeyDown(System.Windows.Input.KeyEventArgs)">
            <inheritdoc />
        </member>
        <member name="M:Fluent.SplitButton.CreateQuickAccessItem">
            <inheritdoc />
        </member>
        <member name="M:Fluent.SplitButton.BindQuickAccessItem(System.Windows.FrameworkElement)">
            <inheritdoc />
        </member>
        <member name="P:Fluent.SplitButton.CanAddButtonToQuickAccessToolBar">
            <summary>
            Gets or sets whether button can be added to quick access toolbar
            </summary>
        </member>
        <member name="F:Fluent.SplitButton.CanAddButtonToQuickAccessToolBarProperty">
            <summary>Identifies the <see cref="P:Fluent.SplitButton.CanAddButtonToQuickAccessToolBar"/> dependency property.</summary>
        </member>
        <member name="M:Fluent.SplitButton.GetKeyTipInformations(System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:Fluent.SplitButton.OnIsSimplifiedChanged(System.Boolean,System.Boolean)">
            <inheritdoc />
        </member>
        <member name="P:Fluent.SplitButton.LogicalChildren">
            <inheritdoc />
        </member>
        <member name="T:Fluent.StartScreen">
            <summary>
            Represents the container for the <see cref="T:Fluent.StartScreenTabControl"/>.
            </summary>
        </member>
        <member name="P:Fluent.StartScreen.Shown">
            <summary>
            Indicates whether the <see cref="T:Fluent.StartScreen"/> has aleaady been shown or not.
            </summary>
        </member>
        <member name="F:Fluent.StartScreen.ShownProperty">
            <summary>Identifies the <see cref="P:Fluent.StartScreen.Shown"/> dependency property.</summary>
        </member>
        <member name="M:Fluent.StartScreen.Show">
            <summary>
            Shows the <see cref="T:Fluent.StartScreen"/>.
            </summary>
            <returns>
            <c>true</c> if the <see cref="T:Fluent.StartScreen"/> was made visible.
            <c>false</c> if the <see cref="T:Fluent.StartScreen"/> was previously shown and was not made visible during this call.
            </returns>
        </member>
        <member name="M:Fluent.StartScreen.Hide">
            <summary>
            Hides the <see cref="T:Fluent.StartScreen" />.
            </summary>
        </member>
        <member name="T:Fluent.StartScreenTabControl">
            <summary>
            Control for representing the left and right side of the start screen.
            </summary>
            <remarks>
            To control some aspects of the left handed side of this control please use properties prefixed with "ItemsPanel*".
            </remarks>
        </member>
        <member name="P:Fluent.StartScreenTabControl.LeftContent">
            <summary>
            Left side panel content of the startscreen.
            </summary>
        </member>
        <member name="F:Fluent.StartScreenTabControl.LeftContentProperty">
            <summary>Identifies the <see cref="P:Fluent.StartScreenTabControl.LeftContent"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.StartScreenTabControl.LeftContentMargin">
            <summary>
            Defines the margin for <see cref="P:Fluent.StartScreenTabControl.LeftContent"/>
            </summary>
        </member>
        <member name="F:Fluent.StartScreenTabControl.LeftContentMarginProperty">
            <summary>Identifies the <see cref="P:Fluent.StartScreenTabControl.LeftContentMargin"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.StartScreenTabControl.RightContent">
            <summary>
            Right side panel content of the startscreen.
            </summary>
        </member>
        <member name="F:Fluent.StartScreenTabControl.RightContentProperty">
            <summary>Identifies the <see cref="P:Fluent.StartScreenTabControl.RightContent"/> dependency property.</summary>
        </member>
        <member name="M:Fluent.StartScreenTabControl.#cctor">
            <summary>
            Static constructor.
            </summary>
        </member>
        <member name="P:Fluent.StartScreenTabControl.LogicalChildren">
            <inheritdoc />
        </member>
        <member name="T:Fluent.StatusBar">
            <summary>
            Represents ribbon status bar
            </summary>
        </member>
        <member name="M:Fluent.StatusBar.#cctor">
            <summary>
            Static constructor
            </summary>
        </member>
        <member name="M:Fluent.StatusBar.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:Fluent.StatusBar.GetContainerForItemOverride">
            <inheritdoc />
        </member>
        <member name="M:Fluent.StatusBar.IsItemItsOwnContainerOverride(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:Fluent.StatusBar.OnItemsChanged(System.Collections.Specialized.NotifyCollectionChangedEventArgs)">
            <inheritdoc />
        </member>
        <member name="T:Fluent.StatusBarItem">
            <summary>
            Represents ribbon status bar item
            </summary>
        </member>
        <member name="P:Fluent.StatusBarItem.Title">
            <summary>
            Gets or sets ribbon status bar item
            </summary>
        </member>
        <member name="F:Fluent.StatusBarItem.TitleProperty">
            <summary>Identifies the <see cref="P:Fluent.StatusBarItem.Title"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.StatusBarItem.Value">
            <summary>
            Gets or sets ribbon status bar value
            </summary>
        </member>
        <member name="F:Fluent.StatusBarItem.ValueProperty">
            <summary>Identifies the <see cref="P:Fluent.StatusBarItem.Value"/> dependency property.</summary>
        </member>
        <member name="F:Fluent.StatusBarItem.IsCheckableProperty">
            <summary>Identifies the <see cref="P:Fluent.StatusBarItem.IsCheckable"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.StatusBarItem.IsCheckable">
            <summary>
            Gets a value that indicates whether a <see cref="T:Fluent.StatusBarItem" /> can be added/removed from the <see cref="T:Fluent.StatusBar"/>.
            </summary>
        </member>
        <member name="P:Fluent.StatusBarItem.IsChecked">
            <summary>
            Gets or sets whether status bar item is checked in menu
            </summary>
        </member>
        <member name="F:Fluent.StatusBarItem.IsCheckedProperty">
            <summary>Identifies the <see cref="P:Fluent.StatusBarItem.IsChecked"/> dependency property.</summary>
        </member>
        <member name="E:Fluent.StatusBarItem.Checked">
            <summary>
            Occurs when status bar item checks
            </summary>
        </member>
        <member name="E:Fluent.StatusBarItem.Unchecked">
            <summary>
            Occurs when status bar item unchecks
            </summary>
        </member>
        <member name="M:Fluent.StatusBarItem.#cctor">
            <summary>
            Static constructor
            </summary>
        </member>
        <member name="T:Fluent.StatusBarMenuItem">
            <summary>
            Represents menu item in ribbon status bar menu
            </summary>
        </member>
        <member name="P:Fluent.StatusBarMenuItem.StatusBarItem">
            <summary>
            Gets or sets Ribbon Status Bar menu item
            </summary>
        </member>
        <member name="F:Fluent.StatusBarMenuItem.StatusBarItemProperty">
            <summary>Identifies the <see cref="P:Fluent.StatusBarMenuItem.StatusBarItem"/> dependency property.</summary>
        </member>
        <member name="M:Fluent.StatusBarMenuItem.#cctor">
            <summary>
            Static constructor
            </summary>
        </member>
        <member name="M:Fluent.StatusBarMenuItem.#ctor(Fluent.StatusBarItem)">
            <summary>
            Default constructor
            </summary>
            <param name="item">Ribbon Status Bar menu item</param>
        </member>
        <member name="T:Fluent.StatusBarPanel">
            <summary>
            Represents panel for status bar
            </summary>
        </member>
        <member name="M:Fluent.StatusBarPanel.MeasureOverride(System.Windows.Size)">
            <inheritdoc />
        </member>
        <member name="M:Fluent.StatusBarPanel.ArrangeOverride(System.Windows.Size)">
            <inheritdoc />
        </member>
        <member name="T:Fluent.TextBox">
            <summary>
            Represents custom Fluent UI TextBox
            </summary>
        </member>
        <member name="P:Fluent.TextBox.IsSimplified">
            <summary>
            Gets or sets whether or not the ribbon is in Simplified mode
            </summary>
        </member>
        <member name="F:Fluent.TextBox.IsSimplifiedProperty">
            <summary>Identifies the <see cref="P:Fluent.TextBox.IsSimplified"/> dependency property.</summary>
        </member>
        <member name="M:Fluent.TextBox.#cctor">
            <summary>
            Static constructor
            </summary>
        </member>
        <member name="M:Fluent.TextBox.OnApplyTemplate">
            <inheritdoc />
        </member>
        <member name="M:Fluent.TextBox.OnContextMenuOpening(System.Windows.Controls.ContextMenuEventArgs)">
            <inheritdoc />
        </member>
        <member name="M:Fluent.TextBox.OnContextMenuClosing(System.Windows.Controls.ContextMenuEventArgs)">
            <inheritdoc />
        </member>
        <member name="M:Fluent.TextBox.OnKeyUp(System.Windows.Input.KeyEventArgs)">
            <inheritdoc />
        </member>
        <member name="M:Fluent.TextBox.CreateQuickAccessItem">
            <inheritdoc />
        </member>
        <member name="P:Fluent.TextBox.CanAddToQuickAccessToolBar">
            <inheritdoc />
        </member>
        <member name="F:Fluent.TextBox.CanAddToQuickAccessToolBarProperty">
            <summary>Identifies the <see cref="P:Fluent.TextBox.CanAddToQuickAccessToolBar"/> dependency property.</summary>
        </member>
        <member name="M:Fluent.TextBox.BindQuickAccessItem(System.Windows.FrameworkElement)">
            <summary>
            This method must be overridden to bind properties to use in quick access creating
            </summary>
            <param name="element">Toolbar item</param>
        </member>
        <member name="M:Fluent.TextBox.OnKeyTipPressed">
            <inheritdoc />
        </member>
        <member name="M:Fluent.TextBox.OnKeyTipBack">
            <inheritdoc />
        </member>
        <member name="P:Fluent.TextBox.Size">
            <inheritdoc />
        </member>
        <member name="F:Fluent.TextBox.SizeProperty">
            <summary>Identifies the <see cref="P:Fluent.TextBox.Size"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.TextBox.SizeDefinition">
            <inheritdoc />
        </member>
        <member name="F:Fluent.TextBox.SizeDefinitionProperty">
            <summary>Identifies the <see cref="P:Fluent.TextBox.SizeDefinition"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.TextBox.SimplifiedSizeDefinition">
            <inheritdoc />
        </member>
        <member name="F:Fluent.TextBox.SimplifiedSizeDefinitionProperty">
            <summary>Identifies the <see cref="P:Fluent.TextBox.SimplifiedSizeDefinition"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.TextBox.KeyTip">
            <inheritdoc />
        </member>
        <member name="F:Fluent.TextBox.KeyTipProperty">
            <inheritdoc cref="F:Fluent.KeyTip.KeysProperty"/>
        </member>
        <member name="P:Fluent.TextBox.Header">
            <inheritdoc />
        </member>
        <member name="F:Fluent.TextBox.HeaderProperty">
            <summary>Identifies the <see cref="P:Fluent.TextBox.Header"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.TextBox.HeaderTemplate">
            <inheritdoc />
        </member>
        <member name="F:Fluent.TextBox.HeaderTemplateProperty">
            <summary>Identifies the <see cref="P:Fluent.TextBox.HeaderTemplate"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.TextBox.HeaderTemplateSelector">
            <inheritdoc />
        </member>
        <member name="F:Fluent.TextBox.HeaderTemplateSelectorProperty">
            <summary>Identifies the <see cref="P:Fluent.TextBox.HeaderTemplateSelector"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.TextBox.Icon">
            <inheritdoc />
        </member>
        <member name="F:Fluent.TextBox.IconProperty">
            <summary>Identifies the <see cref="P:Fluent.TextBox.Icon"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.TextBox.MediumIcon">
            <inheritdoc />
        </member>
        <member name="F:Fluent.TextBox.MediumIconProperty">
            <summary>Identifies the <see cref="P:Fluent.TextBox.MediumIcon"/> dependency property.</summary>
        </member>
        <member name="M:Fluent.TextBox.Fluent#ISimplifiedStateControl#UpdateSimplifiedState(System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:Fluent.TextBox.Fluent#ILogicalChildSupport#AddLogicalChild(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:Fluent.TextBox.Fluent#ILogicalChildSupport#RemoveLogicalChild(System.Object)">
            <inheritdoc />
        </member>
        <member name="P:Fluent.TextBox.LogicalChildren">
            <inheritdoc />
        </member>
        <member name="M:Fluent.TextBox.OnCreateAutomationPeer">
            <inheritdoc />
        </member>
        <member name="T:Fluent.ToggleButton">
            <summary>
            Represents toggle button
            </summary>
        </member>
        <member name="P:Fluent.ToggleButton.Size">
            <inheritdoc />
        </member>
        <member name="F:Fluent.ToggleButton.SizeProperty">
            <summary>Identifies the <see cref="P:Fluent.ToggleButton.Size"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.ToggleButton.SizeDefinition">
            <inheritdoc />
        </member>
        <member name="F:Fluent.ToggleButton.SizeDefinitionProperty">
            <summary>Identifies the <see cref="P:Fluent.ToggleButton.SizeDefinition"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.ToggleButton.SimplifiedSizeDefinition">
            <inheritdoc />
        </member>
        <member name="F:Fluent.ToggleButton.SimplifiedSizeDefinitionProperty">
            <summary>Identifies the <see cref="P:Fluent.ToggleButton.SimplifiedSizeDefinition"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.ToggleButton.KeyTip">
            <inheritdoc />
        </member>
        <member name="F:Fluent.ToggleButton.KeyTipProperty">
            <inheritdoc cref="F:Fluent.KeyTip.KeysProperty"/>
        </member>
        <member name="P:Fluent.ToggleButton.GroupName">
            <inheritdoc />
        </member>
        <member name="F:Fluent.ToggleButton.GroupNameProperty">
            <summary>Identifies the <see cref="P:Fluent.ToggleButton.GroupName"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.ToggleButton.Header">
            <inheritdoc />
        </member>
        <member name="F:Fluent.ToggleButton.HeaderProperty">
            <summary>Identifies the <see cref="P:Fluent.ToggleButton.Header"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.ToggleButton.HeaderTemplate">
            <inheritdoc />
        </member>
        <member name="F:Fluent.ToggleButton.HeaderTemplateProperty">
            <summary>Identifies the <see cref="P:Fluent.ToggleButton.HeaderTemplate"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.ToggleButton.HeaderTemplateSelector">
            <inheritdoc />
        </member>
        <member name="F:Fluent.ToggleButton.HeaderTemplateSelectorProperty">
            <summary>Identifies the <see cref="P:Fluent.ToggleButton.HeaderTemplateSelector"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.ToggleButton.Icon">
            <inheritdoc />
        </member>
        <member name="F:Fluent.ToggleButton.IconProperty">
            <summary>Identifies the <see cref="P:Fluent.ToggleButton.Icon"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.ToggleButton.LargeIcon">
            <inheritdoc />
        </member>
        <member name="F:Fluent.ToggleButton.LargeIconProperty">
            <summary>Identifies the <see cref="P:Fluent.ToggleButton.LargeIcon"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.ToggleButton.MediumIcon">
            <inheritdoc />
        </member>
        <member name="F:Fluent.ToggleButton.MediumIconProperty">
            <summary>Identifies the <see cref="P:Fluent.ToggleButton.MediumIcon"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.ToggleButton.IsDefinitive">
            <summary>
            Gets or sets whether ribbon control click must close backstage
            </summary>
        </member>
        <member name="F:Fluent.ToggleButton.IsDefinitiveProperty">
            <summary>Identifies the <see cref="P:Fluent.ToggleButton.IsDefinitive"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.ToggleButton.IsSimplified">
            <summary>
            Gets or sets whether or not the ribbon is in Simplified mode
            </summary>
        </member>
        <member name="F:Fluent.ToggleButton.IsSimplifiedProperty">
            <summary>Identifies the <see cref="P:Fluent.ToggleButton.IsSimplified"/> dependency property.</summary>
        </member>
        <member name="M:Fluent.ToggleButton.#cctor">
            <summary>
            Initializes static members of the <see cref="T:Fluent.ToggleButton"/> class.
            </summary>
        </member>
        <member name="M:Fluent.ToggleButton.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Fluent.ToggleButton"/> class.
            </summary>
        </member>
        <member name="M:Fluent.ToggleButton.OnClick">
            <inheritdoc />
        </member>
        <member name="M:Fluent.ToggleButton.OnChecked(System.Windows.RoutedEventArgs)">
            <inheritdoc />
        </member>
        <member name="M:Fluent.ToggleButton.InvokeClick">
            <summary>
            Used to call OnClick (which is protected)
            </summary>
        </member>
        <member name="M:Fluent.ToggleButton.CreateQuickAccessItem">
            <inheritdoc />
        </member>
        <member name="P:Fluent.ToggleButton.CanAddToQuickAccessToolBar">
            <inheritdoc />
        </member>
        <member name="F:Fluent.ToggleButton.CanAddToQuickAccessToolBarProperty">
            <summary>Identifies the <see cref="P:Fluent.ToggleButton.CanAddToQuickAccessToolBar"/> dependency property.</summary>
        </member>
        <member name="M:Fluent.ToggleButton.OnKeyTipPressed">
            <inheritdoc />
        </member>
        <member name="M:Fluent.ToggleButton.OnKeyTipBack">
            <inheritdoc />
        </member>
        <member name="M:Fluent.ToggleButton.Fluent#ISimplifiedStateControl#UpdateSimplifiedState(System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:Fluent.ToggleButton.Fluent#ILogicalChildSupport#AddLogicalChild(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:Fluent.ToggleButton.Fluent#ILogicalChildSupport#RemoveLogicalChild(System.Object)">
            <inheritdoc />
        </member>
        <member name="P:Fluent.ToggleButton.LogicalChildren">
            <inheritdoc />
        </member>
        <member name="M:Fluent.ToggleButton.OnCreateAutomationPeer">
            <inheritdoc />
        </member>
        <member name="T:Fluent.TransitioningControl">
            <summary>
            Enables transitons for content changes.
            </summary>
        </member>
        <member name="F:Fluent.TransitioningControl.PreviousContentPartName">
            <summary>
            The part name for the content presenter represeting the previous/old content.
            </summary>
        </member>
        <member name="F:Fluent.TransitioningControl.CurrentContentPartName">
            <summary>
            The part name for the content presenter represeting the new/current content.
            </summary>
        </member>
        <member name="F:Fluent.TransitioningControl.NextContentProperty">
            <summary>Identifies the <see cref="P:Fluent.TransitioningControl.NextContent"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.TransitioningControl.NextContent">
            <summary>
            The next content, which will be the current content.
            </summary>
        </member>
        <member name="F:Fluent.TransitioningControl.TransitionStoryboardProperty">
            <summary>Identifies the <see cref="P:Fluent.TransitioningControl.TransitionStoryboard"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.TransitioningControl.TransitionStoryboard">
            <summary>
            The <see cref="T:System.Windows.Media.Animation.Storyboard"/> being used to animate transitions.
            </summary>
        </member>
        <member name="M:Fluent.TransitioningControl.OnApplyTemplate">
            <inheritdoc />
        </member>
        <member name="M:Fluent.TransitioningControl.StartTransition(System.Object,System.Object)">
            <summary>
            Starts the transtion from old to new content.
            </summary>
        </member>
        <member name="M:Fluent.TransitioningControl.StopTransition">
            <summary>
            Stops the current transition and finally removes the old content.
            </summary>
        </member>
        <member name="T:Fluent.TwoLineLabel">
            <summary>
            Represents specific label to use in particular ribbon controls
            </summary>
        </member>
        <member name="F:Fluent.TwoLineLabel.textRun">
            <summary>
            Run with text
            </summary>
        </member>
        <member name="P:Fluent.TwoLineLabel.HasTwoLines">
            <summary>
            Gets or sets whether label must have two lines
            </summary>
        </member>
        <member name="F:Fluent.TwoLineLabel.HasTwoLinesProperty">
            <summary>Identifies the <see cref="P:Fluent.TwoLineLabel.HasTwoLines"/> dependency property.</summary>
        </member>
        <member name="M:Fluent.TwoLineLabel.OnHasTwoLinesChanged(System.Windows.DependencyObject,System.Windows.DependencyPropertyChangedEventArgs)">
            <summary>
            Handles HasTwoLines property changes
            </summary>
            <param name="d">Object</param>
            <param name="e">The event data</param>
        </member>
        <member name="P:Fluent.TwoLineLabel.HasGlyph">
            <summary>
            Gets or sets whether label has glyph
            </summary>
        </member>
        <member name="F:Fluent.TwoLineLabel.HasGlyphProperty">
            <summary>Identifies the <see cref="P:Fluent.TwoLineLabel.HasGlyph"/> dependency property.</summary>
        </member>
        <member name="M:Fluent.TwoLineLabel.OnHasGlyphChanged(System.Windows.DependencyObject,System.Windows.DependencyPropertyChangedEventArgs)">
            <summary>
            Handles HasGlyph property changes
            </summary>
            <param name="d">Object</param>
            <param name="e">The event data</param>
        </member>
        <member name="P:Fluent.TwoLineLabel.Text">
            <summary>
            Gets or sets the text
            </summary>
        </member>
        <member name="F:Fluent.TwoLineLabel.TextProperty">
            <summary>Identifies the <see cref="P:Fluent.TwoLineLabel.Text"/> dependency property.</summary>
        </member>
        <member name="M:Fluent.TwoLineLabel.#cctor">
            <summary>
            Static constructor
            </summary>
        </member>
        <member name="M:Fluent.TwoLineLabel.OnApplyTemplate">
            <inheritdoc />
        </member>
        <member name="M:Fluent.TwoLineLabel.OnCreateAutomationPeer">
            <inheritdoc />
        </member>
        <member name="M:Fluent.TwoLineLabel.OnTextChanged(System.Windows.DependencyObject,System.Windows.DependencyPropertyChangedEventArgs)">
            <summary>
            Handles text property changes
            </summary>
            <param name="d">Object</param>
            <param name="e">The event data</param>
        </member>
        <member name="M:Fluent.TwoLineLabel.UpdateTextRun">
            <summary>
            Updates text runs and adds newline if HasTwoLines == true
            </summary>
        </member>
        <member name="T:Fluent.UniformGridWithItemSize">
            <summary>
            UniformGrid is used to arrange children in a grid with all equal cell sizes.
            </summary>
        </member>
        <member name="P:Fluent.UniformGridWithItemSize.Orientation">
            <summary>
            Gets or sets panel orientation
            </summary>
        </member>
        <member name="F:Fluent.UniformGridWithItemSize.OrientationProperty">
            <summary>Identifies the <see cref="P:Fluent.UniformGridWithItemSize.Orientation"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.UniformGridWithItemSize.MinColumns">
            <summary>
            Specifies the number of maximum columns in the grid
            </summary>
        </member>
        <member name="F:Fluent.UniformGridWithItemSize.MinColumnsProperty">
            <summary>Identifies the <see cref="P:Fluent.UniformGridWithItemSize.MinColumns"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.UniformGridWithItemSize.MaxColumns">
            <summary>
            Specifies the number of maximum columns in the grid
            </summary>
        </member>
        <member name="F:Fluent.UniformGridWithItemSize.MaxColumnsProperty">
            <summary>Identifies the <see cref="P:Fluent.UniformGridWithItemSize.MaxColumns"/> dependency property.</summary>
        </member>
        <member name="F:Fluent.UniformGridWithItemSize.ItemWidthProperty">
            <summary>Identifies the <see cref="P:Fluent.UniformGridWithItemSize.ItemWidth"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.UniformGridWithItemSize.ItemWidth">
            <summary>
            Specifies the item width.
            </summary>
        </member>
        <member name="F:Fluent.UniformGridWithItemSize.ItemHeightProperty">
            <summary>Identifies the <see cref="P:Fluent.UniformGridWithItemSize.ItemHeight"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.UniformGridWithItemSize.ItemHeight">
            <summary>
            Specifies the item height.
            </summary>
        </member>
        <member name="M:Fluent.UniformGridWithItemSize.MeasureOverride(System.Windows.Size)">
            <summary>
            Compute the desired size of this UniformGrid by measuring all of the
            children with a constraint equal to a cell's portion of the given
            constraint (e.g. for a 2 x 4 grid, the child constraint would be
            constraint.Width*0.5 x constraint.Height*0.25).  The maximum child
            width and maximum child height are tracked, and then the desired size
            is computed by multiplying these maximums by the row and column count
            (e.g. for a 2 x 4 grid, the desired size for the UniformGrid would be
            maxChildDesiredWidth*2 x maxChildDesiredHeight*4).
            </summary>
            <param name="constraint">Constraint</param>
            <returns>Desired size</returns>
        </member>
        <member name="M:Fluent.UniformGridWithItemSize.ArrangeOverride(System.Windows.Size)">
            <summary>
            Arrange the children of this UniformGrid by distributing space evenly 
            among all of the children, making each child the size equal to a cell's
            portion of the given arrangeSize (e.g. for a 2 x 4 grid, the child size
            would be arrangeSize*0.5 x arrangeSize*0.25)
            </summary>
            <param name="arrangeSize">Arrange size</param>
        </member>
        <member name="M:Fluent.UniformGridWithItemSize.UpdateComputedValues(System.Int32)">
             <summary>
             If either Rows or Columns are set to 0, then dynamically compute these
             values based on the actual number of non-collapsed children.
            
             In the case when both Rows and Columns are set to 0, then make Rows 
             and Columns be equal, thus laying out in a square grid.
             </summary>
        </member>
        <member name="T:Fluent.WindowSteeringHelperControl">
            <summary>
            Helper control which enables easy embedding of window steering functions.
            </summary>
        </member>
        <member name="M:Fluent.WindowSteeringHelperControl.#cctor">
            <summary>
            Static constructor
            </summary>
        </member>
        <member name="M:Fluent.WindowSteeringHelperControl.OnMouseLeftButtonDown(System.Windows.Input.MouseButtonEventArgs)">
            <inheritdoc />
        </member>
        <member name="M:Fluent.WindowSteeringHelperControl.OnMouseRightButtonUp(System.Windows.Input.MouseButtonEventArgs)">
            <inheritdoc />
        </member>
        <member name="T:Fluent.Converters.ApplicationMenuRightScrollViewerExtractorConverter">
            <summary>
            Extracts right content presenter of application menu converter
            </summary>
        </member>
        <member name="M:Fluent.Converters.ApplicationMenuRightScrollViewerExtractorConverter.Convert(System.Object,System.Type,System.Object,System.Globalization.CultureInfo)">
            <inheritdoc />
        </member>
        <member name="M:Fluent.Converters.ApplicationMenuRightScrollViewerExtractorConverter.ConvertBack(System.Object,System.Type,System.Object,System.Globalization.CultureInfo)">
            <inheritdoc />
        </member>
        <member name="T:Fluent.Converters.ColorToSolidColorBrushValueConverter">
            <summary>
            Converts <see cref="T:System.Windows.Media.Color"/> to a <see cref="T:System.Windows.Media.SolidColorBrush"/> and back.
            </summary>
        </member>
        <member name="M:Fluent.Converters.ColorToSolidColorBrushValueConverter.Convert(System.Object,System.Type,System.Object,System.Globalization.CultureInfo)">
            <inheritdoc />
        </member>
        <member name="M:Fluent.Converters.ColorToSolidColorBrushValueConverter.ConvertBack(System.Object,System.Type,System.Object,System.Globalization.CultureInfo)">
            <inheritdoc />
        </member>
        <member name="T:Fluent.Converters.CornerRadiusConverter">
            <summary>
            Used to convert from four double values to <see cref="T:System.Windows.CornerRadius"/>
            </summary>
        </member>
        <member name="M:Fluent.Converters.CornerRadiusConverter.Convert(System.Object,System.Type,System.Object,System.Globalization.CultureInfo)">
            <inheritdoc />
        </member>
        <member name="M:Fluent.Converters.CornerRadiusConverter.ConvertBack(System.Object,System.Type,System.Object,System.Globalization.CultureInfo)">
            <inheritdoc />
        </member>
        <member name="M:Fluent.Converters.CornerRadiusConverter.Convert(System.Object[],System.Type,System.Object,System.Globalization.CultureInfo)">
            <inheritdoc />
        </member>
        <member name="M:Fluent.Converters.CornerRadiusConverter.ConvertBack(System.Object,System.Type[],System.Object,System.Globalization.CultureInfo)">
            <inheritdoc />
        </member>
        <member name="T:Fluent.Converters.CornerRadiusPart">
            <summary>
            Defines parts of a <see cref="T:System.Windows.CornerRadius"/>.
            </summary>
        </member>
        <member name="F:Fluent.Converters.CornerRadiusPart.None">
            <summary>
            None.
            </summary>
        </member>
        <member name="F:Fluent.Converters.CornerRadiusPart.TopLeft">
            <summary>
            Top left.
            </summary>
        </member>
        <member name="F:Fluent.Converters.CornerRadiusPart.TopRight">
            <summary>
            Top right.
            </summary>
        </member>
        <member name="F:Fluent.Converters.CornerRadiusPart.BottomRight">
            <summary>
            Bottom right.
            </summary>
        </member>
        <member name="F:Fluent.Converters.CornerRadiusPart.BottomLeft">
            <summary>
            Bottom left.
            </summary>
        </member>
        <member name="F:Fluent.Converters.CornerRadiusPart.All">
            <summary>
            All parts.
            </summary>
        </member>
        <member name="T:Fluent.Converters.EqualsToVisibilityConverter">
            <summary>
            Checks equality of value and the converter parameter.
            Returns <see cref="F:System.Windows.Visibility.Visible"/> if they are equal.
            Returns <see cref="F:System.Windows.Visibility.Collapsed"/> if they are NOT equal.
            </summary>
        </member>
        <member name="M:Fluent.Converters.EqualsToVisibilityConverter.Convert(System.Object,System.Type,System.Object,System.Globalization.CultureInfo)">
            <inheritdoc />
        </member>
        <member name="M:Fluent.Converters.EqualsToVisibilityConverter.ConvertBack(System.Object,System.Type,System.Object,System.Globalization.CultureInfo)">
            <inheritdoc />
        </member>
        <member name="T:Fluent.Converters.ExtractLeftRightFromThicknessConverter">
            <summary>
            Used to convert the left and right values from an input <see cref="T:System.Windows.Thickness"/> to an output <see cref="T:System.Windows.Thickness"/>.
            </summary>
        </member>
        <member name="F:Fluent.Converters.ExtractLeftRightFromThicknessConverter.Default">
            <summary>
            The default converter instance.
            </summary>
        </member>
        <member name="M:Fluent.Converters.ExtractLeftRightFromThicknessConverter.Convert(System.Object,System.Type,System.Object,System.Globalization.CultureInfo)">
            <inheritdoc />
        </member>
        <member name="M:Fluent.Converters.ExtractLeftRightFromThicknessConverter.ConvertBack(System.Object,System.Type,System.Object,System.Globalization.CultureInfo)">
            <inheritdoc />
        </member>
        <member name="T:Fluent.Converters.InverseBoolConverter">
            <summary>
            Converter used to invert a boolean value.
            </summary>
        </member>
        <member name="M:Fluent.Converters.InverseBoolConverter.Convert(System.Object,System.Type,System.Object,System.Globalization.CultureInfo)">
            <inheritdoc />
        </member>
        <member name="M:Fluent.Converters.InverseBoolConverter.ConvertBack(System.Object,System.Type,System.Object,System.Globalization.CultureInfo)">
            <inheritdoc />
        </member>
        <member name="T:Fluent.Converters.InvertNumericConverter">
            <summary>
            Used to invert numbers
            </summary>
        </member>
        <member name="M:Fluent.Converters.InvertNumericConverter.Convert(System.Object,System.Type,System.Object,System.Globalization.CultureInfo)">
            <inheritdoc />
        </member>
        <member name="M:Fluent.Converters.InvertNumericConverter.ConvertBack(System.Object,System.Type,System.Object,System.Globalization.CultureInfo)">
            <inheritdoc />
        </member>
        <member name="T:Fluent.Converters.IsNullConverter">
            <summary>
                Converts <c>null</c> to <c>true</c> and not <c>null</c> to <c>false</c>.
            </summary>
        </member>
        <member name="F:Fluent.Converters.IsNullConverter.Instance">
            <summary>
                A singleton instance for <see cref="T:Fluent.Converters.IsNullConverter" />.
            </summary>
        </member>
        <member name="M:Fluent.Converters.IsNullConverter.Convert(System.Object,System.Type,System.Object,System.Globalization.CultureInfo)">
            <inheritdoc />
        </member>
        <member name="M:Fluent.Converters.IsNullConverter.ConvertBack(System.Object,System.Type,System.Object,System.Globalization.CultureInfo)">
            <inheritdoc />
        </member>
        <member name="T:Fluent.Converters.ObjectToImageConverter">
            <summary>
            Converts <see cref="T:System.String"/>, <see cref="T:System.Uri"/>, <see cref="T:System.Drawing.Icon"/> or <see cref="T:System.Windows.Media.ImageSource"/> to <see cref="T:System.Windows.Controls.Image"/> or <see cref="T:System.Windows.Media.ImageSource"/> (dependent upon target type).
            When converting you can pass a desired size as the converter parameter.
            The returned <see cref="T:System.Windows.Media.ImageSource"/> will be the closest <see cref="T:System.Windows.Media.Imaging.BitmapFrame"/> found in the provided image.
            </summary>
            <remarks>
            - This converter is also a <see cref="T:System.Windows.Markup.MarkupExtension"/> to be able to extract the <see cref="T:System.Windows.DpiScale"/> from the target control.
            - This converter is also a <see cref="T:System.Windows.Data.IMultiValueConverter"/>. The order for parameters/values is:
              0 = value to convert
              1 = visual target or desired size
              2 = desired size
              Index checks are applied during value extraction, so providing null or just the value to convert are considered valid.
            </remarks>
        </member>
        <member name="M:Fluent.Converters.ObjectToImageConverter.#ctor">
            <summary>
            Creates a new instance.
            </summary>
        </member>
        <member name="M:Fluent.Converters.ObjectToImageConverter.#ctor(System.Object)">
            <summary>
            Creates a new instance.
            </summary>
            <param name="input">The object or binding to which the converter should be applied to.</param>
        </member>
        <member name="M:Fluent.Converters.ObjectToImageConverter.#ctor(System.Object,System.Windows.Size)">
            <summary>
            Creates a new instance.
            </summary>
            <param name="input">The object or binding to which the converter should be applied to.</param>
            <param name="desiredSize">The desired size for the image.</param>
        </member>
        <member name="M:Fluent.Converters.ObjectToImageConverter.#ctor(System.Object,System.Object)">
            <summary>
            Creates a new instance.
            </summary>
            <param name="input">The object or binding to which the converter should be applied to.</param>
            <param name="desiredSize">The desired size for the image.</param>
        </member>
        <member name="M:Fluent.Converters.ObjectToImageConverter.#ctor(System.Object,System.Object,System.Windows.Data.Binding)">
            <summary>
            Creates a new instance.
            </summary>
            <param name="input">The object or binding to which the converter should be applied to.</param>
            <param name="desiredSize">The desired size for the image.</param>
            <param name="targetVisualBinding">The target visual on which the image/icon should be shown.</param>
        </member>
        <member name="P:Fluent.Converters.ObjectToImageConverter.TargetVisualBinding">
            <summary>
            The target visual on which the image/icon should be shown.
            </summary>
        </member>
        <member name="P:Fluent.Converters.ObjectToImageConverter.IconBinding">
            <summary>
            The binding to which the converter should be applied to.
            </summary>
        </member>
        <member name="P:Fluent.Converters.ObjectToImageConverter.DesiredSizeBinding">
            <summary>
            The binding for the desired size for the image.
            </summary>
        </member>
        <member name="M:Fluent.Converters.ObjectToImageConverter.Convert(System.Object,System.Type,System.Object,System.Globalization.CultureInfo)">
            <inheritdoc />
        </member>
        <member name="M:Fluent.Converters.ObjectToImageConverter.ConvertBack(System.Object,System.Type,System.Object,System.Globalization.CultureInfo)">
            <inheritdoc />
        </member>
        <member name="M:Fluent.Converters.ObjectToImageConverter.GetValueToConvert(System.Object,System.Windows.Size,System.Windows.Media.Visual)">
            <summary>
            Returns the value to convert.
            </summary>
        </member>
        <member name="M:Fluent.Converters.ObjectToImageConverter.Convert(System.Object[],System.Type,System.Object,System.Globalization.CultureInfo)">
            <inheritdoc />
        </member>
        <member name="M:Fluent.Converters.ObjectToImageConverter.ConvertBack(System.Object,System.Type[],System.Object,System.Globalization.CultureInfo)">
            <inheritdoc />
        </member>
        <member name="M:Fluent.Converters.ObjectToImageConverter.ProvideValue(System.IServiceProvider)">
            <inheritdoc />
        </member>
        <member name="M:Fluent.Converters.ObjectToImageConverter.ServiceProviderWrapper.GetService(System.Type)">
            <inheritdoc />
        </member>
        <member name="P:Fluent.Converters.ObjectToImageConverter.ServiceProviderWrapper.TargetObject">
            <inheritdoc />
        </member>
        <member name="P:Fluent.Converters.ObjectToImageConverter.ServiceProviderWrapper.TargetProperty">
            <inheritdoc />
        </member>
        <member name="M:Fluent.Converters.ObjectToImageConverter.CreateFrozenImageSource(System.Object,System.Windows.Size)">
            <summary>
            Extracts an <see cref="T:System.Windows.Media.ImageSource"/> from <paramref name="value"/> which closest matches the <paramref name="desiredSize"/>.
            </summary>
            <param name="value">Value from which the <see cref="T:System.Windows.Media.ImageSource"/> should be extracted. It can be of type <see cref="T:System.Windows.Media.ImageSource"/></param>
            <param name="desiredSize">The desired size to extract from <paramref name="value"/> .</param>
            <returns>An frozen <see cref="T:System.Windows.Media.ImageSource"/> which closest matches <paramref name="desiredSize"/></returns>
        </member>
        <member name="M:Fluent.Converters.ObjectToImageConverter.CreateFrozenImageSource(System.Object,System.Windows.Media.Visual,System.Windows.Size)">
            <summary>
            Extracts an <see cref="T:System.Windows.Media.ImageSource"/> from <paramref name="value"/> which closest matches the <paramref name="desiredSize"/>.
            </summary>
            <param name="value">Value from which the <see cref="T:System.Windows.Media.ImageSource"/> should be extracted. It can be of type <see cref="T:System.Windows.Media.ImageSource"/></param>
            <param name="targetVisual">The target on which the <see cref="T:System.Windows.Media.ImageSource"/> will be used.</param>
            <param name="desiredSize">The desired size to extract from <paramref name="value"/> .</param>
            <returns>An frozen <see cref="T:System.Windows.Media.ImageSource"/> which closest matches <paramref name="desiredSize"/></returns>
        </member>
        <member name="M:Fluent.Converters.ObjectToImageConverter.CreateImageSource(System.Object,System.Windows.Size)">
            <summary>
            Extracts an <see cref="T:System.Windows.Media.ImageSource"/> from <paramref name="value"/> which closest matches the <paramref name="desiredSize"/>.
            </summary>
            <param name="value">Value from which the <see cref="T:System.Windows.Media.ImageSource"/> should be extracted. It can be of type <see cref="T:System.Windows.Media.ImageSource"/></param>
            <param name="desiredSize">The desired size to extract from <paramref name="value"/> .</param>
            <returns>An <see cref="T:System.Windows.Media.ImageSource"/> which closest matches <paramref name="desiredSize"/></returns>
        </member>
        <member name="M:Fluent.Converters.ObjectToImageConverter.CreateImageSource(System.Object,System.Windows.Media.Visual,System.Windows.Size)">
            <summary>
            Extracts an <see cref="T:System.Windows.Media.ImageSource"/> from <paramref name="value"/> which closest matches the <paramref name="desiredSize"/>.
            </summary>
            <param name="value">Value from which the <see cref="T:System.Windows.Media.ImageSource"/> should be extracted. It can be of type <see cref="T:System.Windows.Media.ImageSource"/></param>
            /// <param name="targetVisual">The target on which the <see cref="T:System.Windows.Media.ImageSource"/> will be used.</param>
            <param name="desiredSize">The desired size to extract from <paramref name="value"/> .</param>
            <returns>An <see cref="T:System.Windows.Media.ImageSource"/> which closest matches <paramref name="desiredSize"/></returns>
        </member>
        <member name="M:Fluent.Converters.ObjectToImageConverter.GetScaledDesiredSize(System.Windows.Size,System.Windows.Media.Visual)">
            <summary>
            Get the scaled desired size.
            </summary>
        </member>
        <member name="M:Fluent.Converters.ObjectToImageConverter.GetScaledDesiredSize(System.Windows.Size,System.Windows.DpiScale)">
            <summary>
            Get the scaled desired size.
            </summary>
        </member>
        <member name="T:Fluent.Converters.RibbonGroupBoxStateDefinitionConverter">
            <summary>
            Class which enables conversion from <see cref="T:System.String"/> to <see cref="T:Fluent.RibbonGroupBoxStateDefinition"/>
            </summary>
        </member>
        <member name="M:Fluent.Converters.RibbonGroupBoxStateDefinitionConverter.CanConvertFrom(System.ComponentModel.ITypeDescriptorContext,System.Type)">
            <inheritdoc />
        </member>
        <member name="M:Fluent.Converters.RibbonGroupBoxStateDefinitionConverter.ConvertFrom(System.ComponentModel.ITypeDescriptorContext,System.Globalization.CultureInfo,System.Object)">
            <inheritdoc />
        </member>
        <member name="T:Fluent.Converters.SizeDefinitionConverter">
            <summary>
            Class which enables conversion from <see cref="T:System.String"/> to <see cref="T:Fluent.RibbonControlSizeDefinition"/>
            </summary>
        </member>
        <member name="M:Fluent.Converters.SizeDefinitionConverter.CanConvertFrom(System.ComponentModel.ITypeDescriptorContext,System.Type)">
            <inheritdoc />
        </member>
        <member name="M:Fluent.Converters.SizeDefinitionConverter.ConvertFrom(System.ComponentModel.ITypeDescriptorContext,System.Globalization.CultureInfo,System.Object)">
            <inheritdoc />
        </member>
        <member name="T:Fluent.Converters.SpinnerTextToValueConverter">
            <summary>
            Converter class which converts from <see cref="T:System.String"/> to <see cref="T:System.Double"/> and back.
            </summary>
        </member>
        <member name="F:Fluent.Converters.SpinnerTextToValueConverter.DefaultInstance">
            <summary>
            Gets a default instance of <see cref="T:Fluent.Converters.SpinnerTextToValueConverter"/>.
            </summary>
        </member>
        <member name="M:Fluent.Converters.SpinnerTextToValueConverter.Convert(System.Object,System.Type,System.Object,System.Globalization.CultureInfo)">
            <inheritdoc />
        </member>
        <member name="M:Fluent.Converters.SpinnerTextToValueConverter.ConvertBack(System.Object,System.Type,System.Object,System.Globalization.CultureInfo)">
            <inheritdoc />
        </member>
        <member name="M:Fluent.Converters.SpinnerTextToValueConverter.TextToDouble(System.String,System.String,System.Double,System.Globalization.CultureInfo)">
            <summary>
            Converts the given <paramref name="text"/> to a <see cref="T:System.Double"/>.
            </summary>
            <returns>The <see cref="T:System.Double"/> value converted from <paramref name="text"/> or <paramref name="previousValue"/> if the conversion fails.</returns>
        </member>
        <member name="M:Fluent.Converters.SpinnerTextToValueConverter.DoubleToText(System.Double,System.String,System.Globalization.CultureInfo)">
            <summary>
            Converts <paramref name="value"/> to a formatted text using <paramref name="format"/>.
            </summary>
            <returns><paramref name="value"/> converted to a <see cref="T:System.String"/>.</returns>
        </member>
        <member name="T:Fluent.Converters.StaticConverters">
            <summary>
            Hold static instances of several commonly used converters.
            </summary>
        </member>
        <member name="F:Fluent.Converters.StaticConverters.InvertNumericConverter">
            <summary>
            Get a static instance of <see cref="F:Fluent.Converters.StaticConverters.InvertNumericConverter"/>
            </summary>
        </member>
        <member name="F:Fluent.Converters.StaticConverters.ThicknessConverter">
            <summary>
            Get a static instance of <see cref="F:Fluent.Converters.StaticConverters.ThicknessConverter"/>
            </summary>
        </member>
        <member name="F:Fluent.Converters.StaticConverters.CornerRadiusConverter">
            <summary>
            Get a static instance of <see cref="F:Fluent.Converters.StaticConverters.CornerRadiusConverter"/>
            </summary>
        </member>
        <member name="F:Fluent.Converters.StaticConverters.ObjectToImageConverter">
            <summary>
            Get a static instance of <see cref="F:Fluent.Converters.StaticConverters.ObjectToImageConverter"/>
            </summary>
        </member>
        <member name="F:Fluent.Converters.StaticConverters.ColorToSolidColorBrushValueConverter">
            <summary>
            Get a static instance of <see cref="F:Fluent.Converters.StaticConverters.ColorToSolidColorBrushValueConverter"/>
            </summary>
        </member>
        <member name="F:Fluent.Converters.StaticConverters.EqualsToVisibilityConverter">
            <summary>
            Get a static instance of <see cref="F:Fluent.Converters.StaticConverters.EqualsToVisibilityConverter"/>
            </summary>
        </member>
        <member name="F:Fluent.Converters.StaticConverters.InverseBoolConverter">
            <summary>
            Get a static instance of <see cref="F:Fluent.Converters.StaticConverters.InverseBoolConverter"/>
            </summary>
        </member>
        <member name="T:Fluent.Converters.ThicknessConverter">
            <summary>
            Used to convert from four double values to <see cref="T:System.Windows.Thickness"/>
            </summary>
        </member>
        <member name="M:Fluent.Converters.ThicknessConverter.Convert(System.Object[],System.Type,System.Object,System.Globalization.CultureInfo)">
            <inheritdoc />
        </member>
        <member name="M:Fluent.Converters.ThicknessConverter.ConvertBack(System.Object,System.Type[],System.Object,System.Globalization.CultureInfo)">
            <inheritdoc />
        </member>
        <member name="T:Fluent.IconConverter">
            <summary>
            Icon converter provides window or application default icon if user-defined is not present.
            </summary>
        </member>
        <member name="M:Fluent.IconConverter.#ctor(System.Windows.Data.Binding)">
            <summary>
            Creates a new instance.
            </summary>
            <param name="iconBinding">The binding to which the converter should be applied to.</param>
        </member>
        <member name="M:Fluent.IconConverter.#ctor(System.Windows.Data.Binding,System.Windows.Data.Binding)">
            <summary>
            Creates a new instance.
            </summary>
            <param name="iconBinding">The binding to which the converter should be applied to.</param>
            <param name="targetVisualBinding">The target visual on which the image/icon should be shown.</param>
        </member>
        <member name="M:Fluent.IconConverter.#ctor(System.Windows.Data.Binding,System.Object,System.Windows.Data.Binding)">
            <summary>
            Creates a new instance.
            </summary>
            <param name="iconBinding">The binding to which the converter should be applied to.</param>
            <param name="desiredSize">The desired size for the image.</param>
            <param name="targetVisualBinding">The target visual on which the image/icon should be shown.</param>
        </member>
        <member name="M:Fluent.IconConverter.GetValueToConvert(System.Object,System.Windows.Size,System.Windows.Media.Visual)">
            <inheritdoc />
        </member>
        <member name="T:Fluent.KeyTipInformation">
            <summary>
            Container class for KeyTip informations
            </summary>
        </member>
        <member name="M:Fluent.KeyTipInformation.#ctor(System.String,System.Windows.FrameworkElement,System.Boolean)">
            <summary>
            Creates a new instance.
            </summary>
            <param name="keys">The keys to be used for <see cref="P:Fluent.KeyTipInformation.KeyTip"/>.</param>
            <param name="associatedElement">The element to which this instance belongs to.</param>
            <param name="hide">Defines if the created <see cref="P:Fluent.KeyTipInformation.KeyTip"/> should be hidden or not.</param>
        </member>
        <member name="P:Fluent.KeyTipInformation.Keys">
            <summary>
            Gets <see cref="F:Fluent.KeyTip.KeysProperty"/>
            </summary>
        </member>
        <member name="P:Fluent.KeyTipInformation.AssociatedElement">
            <summary>
            Gets the element this instance belongs to.
            </summary>
        </member>
        <member name="P:Fluent.KeyTipInformation.VisualTarget">
            <summary>
            Gets or sets the element which acts as the visual target.
            </summary>
        </member>
        <member name="P:Fluent.KeyTipInformation.DefaultVisibility">
            <summary>
            Gets the initial visibility.
            </summary>
        </member>
        <member name="P:Fluent.KeyTipInformation.KeyTip">
            <summary>
            Gets the <see cref="T:Fluent.KeyTip"/> for <see cref="P:Fluent.KeyTipInformation.AssociatedElement"/>.
            </summary>
        </member>
        <member name="P:Fluent.KeyTipInformation.Position">
            <summary>
            Gets or sets the position of <see cref="P:Fluent.KeyTipInformation.KeyTip"/>.
            </summary>
        </member>
        <member name="P:Fluent.KeyTipInformation.BackupVisibility">
            <summary>
            Gets or sets the backed up value of <see cref="T:System.Windows.Visibility"/> of <see cref="P:Fluent.KeyTipInformation.KeyTip"/>
            </summary>
        </member>
        <member name="P:Fluent.KeyTipInformation.IsVisible">
            <summary>
            Gets <see cref="P:System.Windows.UIElement.IsVisible" /> from <see cref="P:Fluent.KeyTipInformation.KeyTip"/>.
            </summary>
        </member>
        <member name="P:Fluent.KeyTipInformation.Visibility">
            <summary>
            Gets or sets <see cref="P:System.Windows.UIElement.Visibility" /> from <see cref="P:Fluent.KeyTipInformation.KeyTip"/>.
            </summary>
        </member>
        <member name="P:Fluent.KeyTipInformation.IsEnabled">
            <summary>
            Gets <see cref="P:System.Windows.UIElement.IsEnabled" /> from <see cref="P:Fluent.KeyTipInformation.KeyTip"/>
            </summary>
        </member>
        <member name="T:Fluent.KeyTipPressedResult">
            <summary>
            Represents the result of <see cref="M:Fluent.IKeyTipedControl.OnKeyTipPressed"/>.
            </summary>
        </member>
        <member name="F:Fluent.KeyTipPressedResult.Empty">
            <summary>
            An empty default instance.
            </summary>
        </member>
        <member name="M:Fluent.KeyTipPressedResult.#ctor(System.Boolean,System.Boolean)">
            <summary>
            Creates a new instance.
            </summary>
            <param name="pressedElementAquiredFocus">Defines if the pressed element aquired focus or not.</param>
            <param name="pressedElementOpenedPopup">Defines if the pressed element opened a popup or not.</param>
        </member>
        <member name="P:Fluent.KeyTipPressedResult.PressedElementAquiredFocus">
            <summary>
            Defines if the pressed element aquired focus or not.
            </summary>
        </member>
        <member name="P:Fluent.KeyTipPressedResult.PressedElementOpenedPopup">
            <summary>
            Defines if the pressed element opened a popup or not.
            </summary>
        </member>
        <member name="T:Fluent.RibbonControlSizeDefinition">
            <summary>
            Class to map from <see cref="T:Fluent.RibbonGroupBoxState"/> to <see cref="T:Fluent.RibbonControlSize"/>
            </summary>
        </member>
        <member name="M:Fluent.RibbonControlSizeDefinition.#ctor(Fluent.RibbonControlSize,Fluent.RibbonControlSize,Fluent.RibbonControlSize)">
            <summary>
            Creates a new instance
            </summary>
        </member>
        <member name="M:Fluent.RibbonControlSizeDefinition.#ctor(System.String)">
            <summary>
            Creates a new instance
            </summary>
        </member>
        <member name="P:Fluent.RibbonControlSizeDefinition.Large">
            <summary>
            Gets or sets the value for large group sizes
            </summary>
        </member>
        <member name="P:Fluent.RibbonControlSizeDefinition.Middle">
            <summary>
            Gets or sets the value for middle group sizes
            </summary>
        </member>
        <member name="P:Fluent.RibbonControlSizeDefinition.Small">
            <summary>
            Gets or sets the value for small group sizes
            </summary>
        </member>
        <member name="M:Fluent.RibbonControlSizeDefinition.FromString(System.String)">
            <summary>
            Converts from <see cref="T:System.String"/> to <see cref="T:Fluent.RibbonControlSizeDefinition"/>
            </summary>
        </member>
        <member name="M:Fluent.RibbonControlSizeDefinition.op_Implicit(System.String)~Fluent.RibbonControlSizeDefinition">
            <summary>
            Converts from <see cref="T:System.String"/> to <see cref="T:Fluent.RibbonControlSizeDefinition"/>
            </summary>
        </member>
        <member name="M:Fluent.RibbonControlSizeDefinition.op_Implicit(Fluent.RibbonControlSizeDefinition)~System.String">
            <summary>
            Converts from <see cref="T:Fluent.RibbonControlSizeDefinition"/> to <see cref="T:System.String"/>
            </summary>
        </member>
        <member name="M:Fluent.RibbonControlSizeDefinition.ToRibbonControlSize(System.String)">
            <summary>
            Converts from <see cref="T:System.String"/> to <see cref="T:Fluent.RibbonControlSize"/>
            </summary>
        </member>
        <member name="M:Fluent.RibbonControlSizeDefinition.GetSize(Fluent.RibbonGroupBoxState)">
            <summary>
            Gets the appropriate <see cref="T:Fluent.RibbonControlSize"/> from <see cref="P:Fluent.RibbonControlSizeDefinition.Large"/>, <see cref="P:Fluent.RibbonControlSizeDefinition.Middle"/> or <see cref="P:Fluent.RibbonControlSizeDefinition.Small"/> depending on <paramref name="ribbonGroupBoxState"/>
            </summary>
        </member>
        <member name="M:Fluent.RibbonControlSizeDefinition.GetSize(Fluent.RibbonControlSize)">
            <summary>
            Gets the appropriate <see cref="T:Fluent.RibbonControlSize"/> from <see cref="P:Fluent.RibbonControlSizeDefinition.Large"/>, <see cref="P:Fluent.RibbonControlSizeDefinition.Middle"/> or <see cref="P:Fluent.RibbonControlSizeDefinition.Small"/> depending on <paramref name="ribbonControlSize"/>
            </summary>
        </member>
        <member name="M:Fluent.RibbonControlSizeDefinition.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:Fluent.RibbonControlSizeDefinition.Equals(Fluent.RibbonControlSizeDefinition)">
            <inheritdoc />
        </member>
        <member name="M:Fluent.RibbonControlSizeDefinition.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:Fluent.RibbonControlSizeDefinition.op_Equality(Fluent.RibbonControlSizeDefinition,Fluent.RibbonControlSizeDefinition)">
            <summary>Determines whether the specified object instances are considered equal.</summary>
            <param name="left">The first object to compare. </param>
            <param name="right">The second object to compare. </param>
            <returns>true if the objects are considered equal; otherwise, false. If both <paramref name="left" /> and <paramref name="right" /> are null, the method returns true.</returns>
        </member>
        <member name="M:Fluent.RibbonControlSizeDefinition.op_Inequality(Fluent.RibbonControlSizeDefinition,Fluent.RibbonControlSizeDefinition)">
            <summary>Determines whether the specified object instances are not considered equal.</summary>
            <param name="left">The first object to compare.</param>
            <param name="right">The second object to compare.</param>
            <returns>true if the objects are not considered equal; otherwise, false. If both <paramref name="left" /> and <paramref name="right" /> are null, the method returns false.</returns>
        </member>
        <member name="M:Fluent.RibbonControlSizeDefinition.ToString">
            <summary>
            Returns a string that represents the current object.
            </summary>
            <returns>
            A string that represents the current object.
            </returns>
        </member>
        <member name="T:Fluent.RibbonGroupBoxStateDefinition">
            <summary>
            This class holds the Holds transitionable states when the <see cref="T:Fluent.RibbonGroupsContainer"/> automatically resizes the <see cref="T:Fluent.RibbonGroupBox"/>.
            </summary>
        </member>
        <member name="M:Fluent.RibbonGroupBoxStateDefinition.#ctor(System.String)">
            <summary>
            Creates a new instance
            </summary>
        </member>
        <member name="P:Fluent.RibbonGroupBoxStateDefinition.States">
            <summary>
            Gets or sets the transitionable states
            </summary>
        </member>
        <member name="M:Fluent.RibbonGroupBoxStateDefinition.FromString(System.String)">
            <summary>
            Converts from <see cref="T:System.String"/> to <see cref="T:Fluent.RibbonGroupBoxStateDefinition"/>
            </summary>
        </member>
        <member name="M:Fluent.RibbonGroupBoxStateDefinition.op_Implicit(System.String)~Fluent.RibbonGroupBoxStateDefinition">
            <summary>
            Converts from <see cref="T:System.String"/> to <see cref="T:Fluent.RibbonGroupBoxStateDefinition"/>
            </summary>
        </member>
        <member name="M:Fluent.RibbonGroupBoxStateDefinition.op_Implicit(Fluent.RibbonGroupBoxStateDefinition)~System.String">
            <summary>
            Converts from <see cref="T:Fluent.RibbonGroupBoxStateDefinition"/> to <see cref="T:System.String"/>
            </summary>
        </member>
        <member name="M:Fluent.RibbonGroupBoxStateDefinition.ToRibbonGroupBoxState(System.String)">
            <summary>
            Converts from <see cref="T:System.String"/> to <see cref="T:Fluent.RibbonGroupBoxState"/>
            </summary>
        </member>
        <member name="M:Fluent.RibbonGroupBoxStateDefinition.EnlargeState(Fluent.RibbonGroupBoxState)">
            <summary>
            Gets the appropriate enlarged <see cref="T:Fluent.RibbonGroupBoxState"/> depending on StateDefinition />
            </summary>
        </member>
        <member name="M:Fluent.RibbonGroupBoxStateDefinition.ReduceState(Fluent.RibbonGroupBoxState)">
            <summary>
            Gets the appropriate reduced <see cref="T:Fluent.RibbonGroupBoxState"/> depending on StateDefinition />
            </summary>
        </member>
        <member name="M:Fluent.RibbonGroupBoxStateDefinition.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:Fluent.RibbonGroupBoxStateDefinition.Equals(Fluent.RibbonGroupBoxStateDefinition)">
            <inheritdoc />
        </member>
        <member name="M:Fluent.RibbonGroupBoxStateDefinition.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:Fluent.RibbonGroupBoxStateDefinition.op_Equality(Fluent.RibbonGroupBoxStateDefinition,Fluent.RibbonGroupBoxStateDefinition)">
            <summary>Determines whether the specified object instances are considered equal.</summary>
            <param name="left">The first object to compare. </param>
            <param name="right">The second object to compare. </param>
            <returns>true if the objects are considered equal; otherwise, false. If both <paramref name="left" /> and <paramref name="right" /> are null, the method returns true.</returns>
        </member>
        <member name="M:Fluent.RibbonGroupBoxStateDefinition.op_Inequality(Fluent.RibbonGroupBoxStateDefinition,Fluent.RibbonGroupBoxStateDefinition)">
            <summary>Determines whether the specified object instances are not considered equal.</summary>
            <param name="left">The first object to compare.</param>
            <param name="right">The second object to compare.</param>
            <returns>true if the objects are not considered equal; otherwise, false. If both <paramref name="left" /> and <paramref name="right" /> are null, the method returns false.</returns>
        </member>
        <member name="M:Fluent.RibbonGroupBoxStateDefinition.ToString">
            <summary>
            Returns a string that represents the current object.
            </summary>
            <returns>
            A string that represents the current object.
            </returns>
        </member>
        <member name="T:Fluent.RibbonStateStorage">
            <summary>
            Handles loading and saving the state of a <see cref="T:Fluent.Ribbon"/> from/to a <see cref="T:System.IO.MemoryStream"/>, for temporary storage, and from/to <see cref="T:System.IO.IsolatedStorage.IsolatedStorage"/>, for persistent storage.
            </summary>
        </member>
        <member name="M:Fluent.RibbonStateStorage.#ctor(Fluent.Ribbon)">
            <summary>
            Creates a new instance.
            </summary>
            <param name="ribbon">The <see cref="T:Fluent.Ribbon"/> of which the state should be stored.</param>
        </member>
        <member name="M:Fluent.RibbonStateStorage.Finalize">
            <summary>
            Finalizes an instance of the <see cref="T:Fluent.RibbonStateStorage"/> class.
            </summary>
        </member>
        <member name="P:Fluent.RibbonStateStorage.Disposed">
            <summary>
            Gets whether this object already got disposed.
            </summary>
        </member>
        <member name="P:Fluent.RibbonStateStorage.IsLoading">
            <inheritdoc />
        </member>
        <member name="P:Fluent.RibbonStateStorage.IsLoaded">
            <inheritdoc />
        </member>
        <member name="P:Fluent.RibbonStateStorage.IsolatedStorageFileName">
            <summary>
                Gets name of the isolated storage file
            </summary>
        </member>
        <member name="M:Fluent.RibbonStateStorage.SaveTemporary">
            <inheritdoc />
        </member>
        <member name="M:Fluent.RibbonStateStorage.Save">
            <inheritdoc />
        </member>
        <member name="M:Fluent.RibbonStateStorage.Save(System.IO.Stream)">
            <summary>
            Saves state to <paramref name="stream"/>.
            </summary>
            <param name="stream">Stream</param>
        </member>
        <member name="M:Fluent.RibbonStateStorage.CreateStateData">
            <summary>
            Create the serialized state data which should be saved later.
            </summary>
            <returns><see cref="T:System.Text.StringBuilder"/> which contains the serialized state data.</returns>
        </member>
        <member name="M:Fluent.RibbonStateStorage.LoadTemporary">
            <inheritdoc />
        </member>
        <member name="M:Fluent.RibbonStateStorage.Load">
            <inheritdoc />
        </member>
        <member name="M:Fluent.RibbonStateStorage.Load(System.IO.Stream)">
            <summary>
            Loads state from <paramref name="stream"/>.
            </summary>
            <param name="stream">The <see cref="T:System.IO.Stream"/> to load the state from.</param>
        </member>
        <member name="M:Fluent.RibbonStateStorage.LoadStateCore(System.IO.Stream)">
            <summary>
            Loads state from <paramref name="stream"/>.
            </summary>
            <param name="stream">The <see cref="T:System.IO.Stream"/> to load the state from.</param>
        </member>
        <member name="M:Fluent.RibbonStateStorage.LoadState(System.String)">
            <summary>
            Loads state from <paramref name="data"/>.
            </summary>
            <param name="data">The <see cref="T:System.String"/> to load the state from.</param>
        </member>
        <member name="M:Fluent.RibbonStateStorage.IsolatedStorageFileExists(System.IO.IsolatedStorage.IsolatedStorageFile,System.String)">
            <summary>
            Determines whether the given file exists in the given storage
            </summary>
        </member>
        <member name="M:Fluent.RibbonStateStorage.GetIsolatedStorageFile">
            <summary>
            Get this <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFile"/> which should be used to store the current state.
            </summary>
            <returns><see cref="M:System.IO.IsolatedStorage.IsolatedStorageFile.GetUserStoreForDomain"/> or <see cref="M:System.IO.IsolatedStorage.IsolatedStorageFile.GetUserStoreForAssembly"/> if <see cref="M:System.IO.IsolatedStorage.IsolatedStorageFile.GetUserStoreForDomain"/> threw an exception.</returns>
        </member>
        <member name="M:Fluent.RibbonStateStorage.Reset">
            <summary>
            Resets saved state.
            </summary>
        </member>
        <member name="M:Fluent.RibbonStateStorage.Dispose">
            <inheritdoc />
        </member>
        <member name="M:Fluent.RibbonStateStorage.Dispose(System.Boolean)">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
            <param name="disposing">Defines whether managed resources should also be freed.</param>
        </member>
        <member name="T:Fluent.GrayscaleEffect">
            <summary>
            An effect that turns the input into shades of a single color.
            </summary>
        </member>
        <member name="F:Fluent.GrayscaleEffect.InputProperty">
            <summary>
            Dependency property for Input
            </summary>
        </member>
        <member name="F:Fluent.GrayscaleEffect.FilterColorProperty">
            <summary>Identifies the <see cref="P:Fluent.GrayscaleEffect.FilterColor"/> dependency property.</summary>
        </member>
        <member name="M:Fluent.GrayscaleEffect.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="P:Fluent.GrayscaleEffect.Input">
            <summary>
            Implicit input
            </summary>
        </member>
        <member name="P:Fluent.GrayscaleEffect.FilterColor">
            <summary>
            The color used to tint the input.
            </summary>
        </member>
        <member name="T:Fluent.IconSize">
            <summary>
            Defines the size of an icon/image.
            </summary>
        </member>
        <member name="F:Fluent.IconSize.Small">
            <summary>
            Small icon size. Usually 16x16.
            </summary>
        </member>
        <member name="F:Fluent.IconSize.Medium">
            <summary>
            Medium icon size. Usually 24x24.
            </summary>
        </member>
        <member name="F:Fluent.IconSize.Large">
            <summary>
            Large icon size. Usually 32x32.
            </summary>
        </member>
        <member name="F:Fluent.IconSize.Custom">
            <summary>
            Custom icon size.
            </summary>
        </member>
        <member name="T:Fluent.RibbonControlSize">
            <summary>
            Represents logical sizes of a ribbon control
            </summary>
        </member>
        <member name="F:Fluent.RibbonControlSize.Large">
            <summary>
            Large size of a control
            </summary>
        </member>
        <member name="F:Fluent.RibbonControlSize.Middle">
            <summary>
            Middle size of a control
            </summary>
        </member>
        <member name="F:Fluent.RibbonControlSize.Small">
            <summary>
            Small size of a control
            </summary>
        </member>
        <member name="T:Fluent.RibbonGroupBoxState">
            <summary>
            Represents states of ribbon group
            </summary>
        </member>
        <member name="F:Fluent.RibbonGroupBoxState.Large">
            <summary>
            Large. All controls in the group will try to be large size
            </summary>
        </member>
        <member name="F:Fluent.RibbonGroupBoxState.Middle">
            <summary>
            Middle. All controls in the group will try to be middle size
            </summary>
        </member>
        <member name="F:Fluent.RibbonGroupBoxState.Small">
            <summary>
            Small. All controls in the group will try to be small size
            </summary>
        </member>
        <member name="F:Fluent.RibbonGroupBoxState.Collapsed">
            <summary>
            Collapsed. Group will collapse its content in a single button
            </summary>
        </member>
        <member name="F:Fluent.RibbonGroupBoxState.QuickAccess">
            <summary>
            QuickAccess. Group will collapse its content in a single button in quick access toolbar
            </summary>
        </member>
        <member name="T:Fluent.Extensibility.IKeyTipInformationProvider">
            <summary>
            Interface which allows extension of the KeyTip system.
            </summary>
        </member>
        <member name="M:Fluent.Extensibility.IKeyTipInformationProvider.GetKeyTipInformations(System.Boolean)">
            <summary>
            Gets a list of <see cref="T:Fluent.KeyTipInformation"/> which belong to the current instance.
            </summary>
            <param name="hide">Defines if the created <see cref="T:Fluent.KeyTip"/> should be hidden or not.</param>
            <returns>A list of <see cref="T:Fluent.KeyTipInformation"/> which belong to the current instance.</returns>
        </member>
        <member name="T:Fluent.Extensibility.IRibbonSizeChangedSink">
            <summary>
            Interface which is used to signal size changes
            </summary>
        </member>
        <member name="M:Fluent.Extensibility.IRibbonSizeChangedSink.OnSizePropertyChanged(Fluent.RibbonControlSize,Fluent.RibbonControlSize)">
            <summary>
            Called when the size is changed
            </summary>
            <param name="previous">Size before change</param>
            <param name="current">Size after change</param>
        </member>
        <member name="T:Fluent.Extensions.AutomationPeerExtensions">
            <summary>
            Extension methods for <see cref="T:System.Windows.Automation.Peers.AutomationPeer"/>.
            </summary>
        </member>
        <member name="T:Fluent.Extensions.DispatcherExtensions">
            <summary>
            Class with extension methods for <see cref="T:System.Windows.Threading.Dispatcher"/> and <see cref="T:System.Windows.Threading.DispatcherObject"/>.
            </summary>
        </member>
        <member name="T:Fluent.Extensions.FrameworkElementExtensions">
            <summary>
            Class with extension methods for <see cref="T:System.Windows.FrameworkElement"/>.
            </summary>
        </member>
        <member name="T:Fluent.Extensions.ICommandSourceExtensions">
            <summary>
            Extensions for <see cref="T:System.Windows.Input.ICommandSource"/>.
            </summary>
        </member>
        <member name="M:Fluent.Extensions.ICommandSourceExtensions.ExecuteCommand(System.Windows.Input.ICommandSource)">
            <summary>
            Execute <see cref="P:System.Windows.Input.ICommandSource.Command"/> using <see cref="P:System.Windows.Input.ICommandSource.CommandParameter"/> and <see cref="P:System.Windows.Input.ICommandSource.CommandTarget"/>.
            </summary>
        </member>
        <member name="M:Fluent.Extensions.ICommandSourceExtensions.CanExecuteCommand(System.Windows.Input.ICommandSource)">
            <summary>
            Determines whether the <see cref="P:System.Windows.Input.ICommandSource.Command"/> can be executed using <see cref="P:System.Windows.Input.ICommandSource.CommandParameter"/> and <see cref="P:System.Windows.Input.ICommandSource.CommandTarget"/>.
            </summary>
            <returns>Returns the commands result of CanExecute.</returns>
        </member>
        <member name="T:Fluent.Extensions.ItemContainerGeneratorExtensions">
            <summary>
            Extension-Methods for <see cref="T:System.Windows.Controls.ItemContainerGenerator" />.
            </summary>
        </member>
        <member name="M:Fluent.Extensions.ItemContainerGeneratorExtensions.ContainerOrContainerContentFromItem``1(System.Windows.Controls.ItemContainerGenerator,System.Object)">
            <summary>
            Returns the container or the content of the container.
            </summary>
            <returns>
            The container for <paramref name="item" /> if the container is of type <typeparamref name="TContainerOrContent" />.
            The container content for <paramref name="item" /> if the container content is of type <typeparamref name="TContainerOrContent" />, but the container itself is not of type <typeparamref name="TContainerOrContent" />.
            </returns>
        </member>
        <member name="M:Fluent.Extensions.ItemContainerGeneratorExtensions.ContainerOrContainerContentFromIndex``1(System.Windows.Controls.ItemContainerGenerator,System.Int32)">
            <summary>
            Returns the container or the content of the container.
            </summary>
            <returns>
            The container for <paramref name="index" /> if the container is of type <typeparamref name="TContainerOrContent" />.
            The container content for <paramref name="index" /> if the container content is of type <typeparamref name="TContainerOrContent" />, but the container itself is not of type <typeparamref name="TContainerOrContent" />.
            </returns>
        </member>
        <member name="M:Fluent.Extensions.ItemContainerGeneratorExtensions.ItemFromContainerOrContainerContent(System.Windows.Controls.ItemContainerGenerator,System.Windows.DependencyObject)">
            <summary>
            asdf
            </summary>
            <returns></returns>
        </member>
        <member name="T:Fluent.Extensions.SelectorAutomationPeerExtensions">
            <summary>
            Extensions for <see cref="T:System.Windows.Automation.Peers.SelectorAutomationPeer"/>.
            </summary>
        </member>
        <member name="M:Fluent.Extensions.SelectorAutomationPeerExtensions.RaiseSelectionEvents(System.Windows.Automation.Peers.SelectorAutomationPeer,System.Windows.Controls.SelectionChangedEventArgs)">
            <summary>
            Calls the internal method "RaiseSelectionEvents" on <paramref name="peer"/> and passes <paramref name="e"/> to it.
            </summary>
        </member>
        <member name="T:Fluent.Helpers.ColorHelpers.NormalizedRGB">
            <summary>
            Valid values for each channel are ∈ [0.0,1.0]
            But sometimes it is useful to allow values outside that range during calculations as long as they are clamped eventually 
            </summary>
        </member>
        <member name="T:Fluent.Helpers.DropDownHelper">
            <summary>
            Helper class for drop downs.
            </summary>
        </member>
        <member name="M:Fluent.Helpers.DropDownHelper.CoerceMaxDropDownHeight(System.Windows.DependencyObject,System.Object)">
            <summary>
            Coerces the maximum drop down height.
            </summary>
        </member>
        <member name="M:Fluent.Helpers.DropDownHelper.GetMaxDropDownHeight(System.Windows.DependencyObject,System.Double)">
            <summary>
            Gets the maximum drop down height.
            </summary>
        </member>
        <member name="T:Fluent.Helpers.LogicalChildSupportHelper">
            <summary>
            Helper functions for classes implementing <see cref="T:Fluent.ILogicalChildSupport"/>.
            </summary>
        </member>
        <member name="M:Fluent.Helpers.LogicalChildSupportHelper.OnLogicalChildPropertyChanged(System.Windows.DependencyObject,System.Windows.DependencyPropertyChangedEventArgs)">
            <summary>
            Called when <see cref="F:Fluent.RibbonControl.IconProperty"/> changes.
            </summary>
        </member>
        <member name="T:Fluent.Helpers.PopupHelper">
            <summary>
            Helper class to position <see cref="T:System.Windows.Controls.Primitives.Popup"/>.
            </summary>
        </member>
        <member name="P:Fluent.Helpers.PopupHelper.SimplePlacementCallback">
            <summary>
            Positions <see cref="T:System.Windows.Controls.Primitives.Popup"/> like <see cref="F:System.Windows.Controls.Primitives.PlacementMode.Relative"/> would but ignores the value of <see cref="P:System.Windows.SystemParameters.MenuDropAlignment"/>.
            </summary>
        </member>
        <member name="M:Fluent.Helpers.PopupHelper.GetSimplePlacement(System.Windows.Size,System.Windows.Size,System.Windows.Point)">
            <summary>
            Gets the <see cref="T:System.Windows.Controls.Primitives.CustomPopupPlacement"/> values for a <see cref="T:System.Windows.Controls.Primitives.Popup"/> like <see cref="F:System.Windows.Controls.Primitives.PlacementMode.Relative"/> would but ignores the value of <see cref="P:System.Windows.SystemParameters.MenuDropAlignment"/>.
            </summary>
        </member>
        <member name="T:Fluent.Helpers.WindowSteeringHelper">
            <summary>
            Class which offers helper methods for steering the window
            </summary>
        </member>
        <member name="M:Fluent.Helpers.WindowSteeringHelper.HandleMouseLeftButtonDown(System.Windows.Input.MouseButtonEventArgs,System.Boolean,System.Boolean)">
            <summary>
            Shows the system menu at the current mouse position.
            </summary>
            <param name="e">The mouse event args.</param>
            <param name="handleDragMove">Defines if window dragging should be handled.</param>
            <param name="handleStateChange">Defines if window state changes should be handled.</param>
        </member>
        <member name="M:Fluent.Helpers.WindowSteeringHelper.HandleMouseLeftButtonDown(System.Windows.DependencyObject,System.Windows.Input.MouseButtonEventArgs,System.Boolean,System.Boolean)">
            <summary>
            Shows the system menu at the current mouse position.
            </summary>
            <param name="dependencyObject">The object which was the source of the mouse event.</param>
            <param name="e">The mouse event args.</param>
            <param name="handleDragMove">Defines if window dragging should be handled.</param>
            <param name="handleStateChange">Defines if window state changes should be handled.</param>
        </member>
        <member name="M:Fluent.Helpers.WindowSteeringHelper.ShowSystemMenu(System.Windows.DependencyObject,System.Windows.Input.MouseButtonEventArgs)">
            <summary>
            Shows the system menu at the current mouse position.
            </summary>
            <param name="dependencyObject">The object which was the source of the mouse event.</param>
            <param name="e">The mouse event args.</param>
        </member>
        <member name="M:Fluent.Helpers.WindowSteeringHelper.ShowSystemMenu(System.Windows.Window,System.Windows.Input.MouseButtonEventArgs)">
            <summary>
            Shows the system menu at the current mouse position.
            </summary>
            <param name="window">The window for which the system menu should be shown.</param>
            <param name="e">The mouse event args.</param>
        </member>
        <member name="M:Fluent.Helpers.WindowSteeringHelper.ShowSystemMenu(System.Windows.Window,System.Windows.Point)">
            <summary>
            Shows the system menu at <paramref name="screenLocation"/>.
            </summary>
            <param name="window">The window for which the system menu should be shown.</param>
            <param name="screenLocation">The location at which the system menu should be shown.</param>
        </member>
        <member name="T:Fluent.FrameworkHelper">
            <summary>
            Represents class to determine .NET Framework version difference
            </summary>
        </member>
        <member name="F:Fluent.FrameworkHelper.PresentationFrameworkVersion">
            <summary>
            Version of WPF
            </summary>
        </member>
        <member name="M:Fluent.FrameworkHelper.GetUseLayoutRounding(System.Windows.DependencyObject)">
            <summary>
            Gets UseLayoutRounding attached property value
            </summary>
            <returns></returns>
        </member>
        <member name="M:Fluent.FrameworkHelper.SetUseLayoutRounding(System.Windows.DependencyObject,System.Boolean)">
            <summary>
            Gets UseLayoutRounding attached property value
            </summary>
        </member>
        <member name="F:Fluent.FrameworkHelper.UseLayoutRoundingProperty">
            <summary>
             Using a DependencyProperty as the backing store for UseLayoutRounding.  This enables animation, styling, binding, etc...
            </summary>
        </member>
        <member name="T:Fluent.ToggleButtonHelper">
            <summary>
                Helper-Class for switching states in ToggleButton-Groups
            </summary>
        </member>
        <member name="M:Fluent.ToggleButtonHelper.OnGroupNameChanged(System.Windows.DependencyObject,System.Windows.DependencyPropertyChangedEventArgs)">
            <summary>
                Handles changes to <see cref="P:Fluent.IToggleButton.GroupName" />
            </summary>
        </member>
        <member name="M:Fluent.ToggleButtonHelper.UpdateButtonGroup(Fluent.IToggleButton)">
            <summary>
                Updates the states of all buttons inside the group which <paramref name="toggleButton" /> belongs to.
            </summary>
        </member>
        <member name="M:Fluent.ToggleButtonHelper.OnIsCheckedChanged(System.Windows.DependencyObject,System.Windows.DependencyPropertyChangedEventArgs)">
            <summary>
                Handles changes to <see cref="P:Fluent.IToggleButton.IsChecked" />
            </summary>
        </member>
        <member name="T:Fluent.IDropDownControl">
            <summary>
            Represents control that have drop down popup
            </summary>
        </member>
        <member name="P:Fluent.IDropDownControl.DropDownPopup">
            <summary>
            Gets drop down popup
            </summary>
        </member>
        <member name="P:Fluent.IDropDownControl.IsContextMenuOpened">
            <summary>
            Gets a value indicating whether control context menu is opened
            </summary>
        </member>
        <member name="P:Fluent.IDropDownControl.IsDropDownOpen">
            <summary>
            Gets or sets a value indicating whether drop down is opened
            </summary>
        </member>
        <member name="E:Fluent.IDropDownControl.DropDownOpened">
            <summary>
            Occurs when drop down is opened.
            </summary>
        </member>
        <member name="E:Fluent.IDropDownControl.DropDownClosed">
            <summary>
            Occurs when drop down menu is closed.
            </summary>
        </member>
        <member name="T:Fluent.IHeaderedControl">
            <summary>
            Represents a control that has a header.
            </summary>
        </member>
        <member name="P:Fluent.IHeaderedControl.Header">
            <summary>
            Gets or sets the header.
            </summary>
        </member>
        <member name="P:Fluent.IHeaderedControl.HeaderTemplate">
            <summary>
                HeaderTemplate is the template used to display the header.
            </summary>
        </member>
        <member name="P:Fluent.IHeaderedControl.HeaderTemplateSelector">
            <summary>
                HeaderTemplateSelector allows the application writer to provide custom logic
                for choosing the template used to display the header of each item.
            </summary>
            <remarks>
                This property is ignored if <seealso cref="P:Fluent.IHeaderedControl.HeaderTemplate"/> is set.
            </remarks>
        </member>
        <member name="T:Fluent.IKeyTipedControl">
            <summary>
            Base interface for controls supports key tips
            </summary>
        </member>
        <member name="P:Fluent.IKeyTipedControl.KeyTip">
            <summary>
            Gets and sets KeyTip for element.
            </summary>
        </member>
        <member name="M:Fluent.IKeyTipedControl.OnKeyTipPressed">
            <summary>
            Handles key tip pressed
            </summary>
        </member>
        <member name="M:Fluent.IKeyTipedControl.OnKeyTipBack">
            <summary>
            Handles back navigation with KeyTips
            </summary>
        </member>
        <member name="T:Fluent.ILargeIconProvider">
            <summary>
            Inferface for controls which provide a large icon.
            </summary>
        </member>
        <member name="P:Fluent.ILargeIconProvider.LargeIcon">
            <summary>
            Gets or sets the large icon.
            </summary>
        </member>
        <member name="T:Fluent.LargeIconProviderProperties">
            <summary>
            Provides some <see cref="T:System.Windows.DependencyProperty"/> for <see cref="T:Fluent.ILargeIconProvider"/>.
            </summary>
        </member>
        <member name="F:Fluent.LargeIconProviderProperties.LargeIconProperty">
            <summary>
            <see cref="T:System.Windows.DependencyProperty"/> for <see cref="P:Fluent.ILargeIconProvider.LargeIcon"/>.
            </summary>
        </member>
        <member name="T:Fluent.ILogicalChildSupport">
            <summary>
            Adds support for forwarding AddLogicalChild and RemoveLogicalChild.
            </summary>
        </member>
        <member name="M:Fluent.ILogicalChildSupport.AddLogicalChild(System.Object)">
            <summary>Adds the provided object to the logical tree of this element. </summary>
            <param name="child">Child element to be added.</param>
        </member>
        <member name="M:Fluent.ILogicalChildSupport.RemoveLogicalChild(System.Object)">
            <summary>
                Removes the provided object from this element's logical tree. <see cref="T:System.Windows.FrameworkElement" />
                updates the affected logical tree parent pointers to keep in sync with this deletion.
            </summary>
            <param name="child">The element to remove.</param>
        </member>
        <member name="T:Fluent.IMediumIconProvider">
            <summary>
            Inferface for controls which provide a medium icon.
            </summary>
        </member>
        <member name="P:Fluent.IMediumIconProvider.MediumIcon">
            <summary>
            Gets or sets the medium icon.
            </summary>
        </member>
        <member name="T:Fluent.MediumIconProviderProperties">
            <summary>
            Provides some <see cref="T:System.Windows.DependencyProperty"/> for <see cref="T:Fluent.IMediumIconProvider"/>.
            </summary>
        </member>
        <member name="F:Fluent.MediumIconProviderProperties.MediumIconProperty">
            <summary>
            <see cref="T:System.Windows.DependencyProperty"/> for <see cref="P:Fluent.IMediumIconProvider.MediumIcon"/>.
            </summary>
        </member>
        <member name="T:Fluent.Internal.CommandHelper">
            <summary>
            Helper class for <see cref="T:System.Windows.Input.ICommand"/>
            </summary>
        </member>
        <member name="M:Fluent.Internal.CommandHelper.CanExecute(System.Windows.Input.ICommand,System.Object,System.Windows.IInputElement)">
            <summary>
            Checks if <paramref name="command"/> can be executed.
            This method is <c>null</c> safe.
            </summary>
            <returns><c>true</c> if the command can be executed, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:Fluent.Internal.CommandHelper.Execute(System.Windows.Input.ICommand,System.Object,System.Windows.IInputElement)">
            <summary>
            Executes <paramref name="command"/>.
            This method is <c>null</c> safe.
            </summary>
        </member>
        <member name="M:Fluent.Internal.DoubleUtil.AreClose(System.Double,System.Double)">
            <summary>
            AreClose - Returns whether or not two doubles are "close".  That is, whether or
            not they are within epsilon of each other.  Note that this epsilon is proportional
            to the numbers themselves to that AreClose survives scalar multiplication.
            There are plenty of ways for this to return false even for numbers which
            are theoretically identical, so no code calling this should fail to work if this
            returns false.  This is important enough to repeat:
            NB: NO CODE CALLING THIS FUNCTION SHOULD DEPEND ON ACCURATE RESULTS - this should be
            used for optimizations *only*.
            </summary>
            <returns>
            bool - the result of the AreClose comparision.
            </returns>
            <param name="value1"> The first double to compare. </param>
            <param name="value2"> The second double to compare. </param>
        </member>
        <member name="M:Fluent.Internal.DoubleUtil.GreaterThan(System.Double,System.Double)">
            <summary>
            GreaterThan - Returns whether or not the first double is greater than the second double.
            That is, whether or not the first is strictly greater than *and* not within epsilon of
            the other number.  Note that this epsilon is proportional to the numbers themselves
            to that AreClose survives scalar multiplication.  Note,
            There are plenty of ways for this to return false even for numbers which
            are theoretically identical, so no code calling this should fail to work if this
            returns false.  This is important enough to repeat:
            NB: NO CODE CALLING THIS FUNCTION SHOULD DEPEND ON ACCURATE RESULTS - this should be
            used for optimizations *only*.
            </summary>
            <returns>
            bool - the result of the GreaterThan comparision.
            </returns>
            <param name="value1"> The first double to compare. </param>
            <param name="value2"> The second double to compare. </param>
        </member>
        <member name="T:Fluent.Internal.ItemContainerGeneratorAction">
            <summary>
            Helper class used to queue action for completion or items changes of <see cref="T:System.Windows.Controls.ItemContainerGenerator"/>
            </summary>
        </member>
        <member name="M:Fluent.Internal.ItemContainerGeneratorAction.#ctor(System.Windows.Controls.ItemContainerGenerator,System.Action)">
            <summary>
            Creates a new instance used to queue action for completion or items changes of <see cref="T:System.Windows.Controls.ItemContainerGenerator"/>
            </summary>
            <param name="generator">The <see cref="T:System.Windows.Controls.ItemContainerGenerator"/> to be used.</param>
            <param name="action">The <see cref="T:System.Action"/> that should be invoked.</param>
        </member>
        <member name="P:Fluent.Internal.ItemContainerGeneratorAction.Generator">
            <summary>
            Gets the <see cref="T:System.Windows.Controls.ItemContainerGenerator"/> to be used.
            </summary>
        </member>
        <member name="P:Fluent.Internal.ItemContainerGeneratorAction.Action">
            <summary>
            Gets the <see cref="T:System.Action"/> that should be invoked.
            </summary>
        </member>
        <member name="P:Fluent.Internal.ItemContainerGeneratorAction.IsWaitingForGenerator">
            <summary>
            Gets the current wait state. <c>true</c> in case <see cref="M:Fluent.Internal.ItemContainerGeneratorAction.QueueAction"/> was called and we are waiting for the <see cref="P:Fluent.Internal.ItemContainerGeneratorAction.Generator"/> to finish.
            </summary>
        </member>
        <member name="M:Fluent.Internal.ItemContainerGeneratorAction.QueueAction">
            <summary>
            Queues <see cref="P:Fluent.Internal.ItemContainerGeneratorAction.Action"/> for invocation.
            </summary>
        </member>
        <member name="T:Fluent.Internal.KnownBoxes.BooleanBoxes">
            <summary>
            Class containing boxed values for <see cref="T:System.Boolean"/>.
            </summary>
        </member>
        <member name="F:Fluent.Internal.KnownBoxes.BooleanBoxes.TrueBox">
            <summary>
            Gets a boxed value for <c>true</c>.
            </summary>
        </member>
        <member name="F:Fluent.Internal.KnownBoxes.BooleanBoxes.FalseBox">
            <summary>
            Gets a boxed value for <c>true</c>.
            </summary>
        </member>
        <member name="M:Fluent.Internal.KnownBoxes.BooleanBoxes.Box(System.Boolean)">
            <summary>
            Gets a boxed value for <paramref name="value"/>.
            </summary>
            <returns>A boxed <see cref="T:System.Boolean"/> value.</returns>
        </member>
        <member name="M:Fluent.Internal.KnownBoxes.BooleanBoxes.Box(System.Nullable{System.Boolean})">
            <summary>
            Gets a boxed value for <paramref name="value"/>.
            </summary>
            <returns>A boxed nullable <see cref="T:System.Boolean"/> value.</returns>
        </member>
        <member name="T:Fluent.Internal.KnownBoxes.DoubleBoxes">
            <summary>
            Class containing boxed values for <see cref="T:System.Double"/>.
            </summary>
        </member>
        <member name="F:Fluent.Internal.KnownBoxes.DoubleBoxes.Zero">
            <summary>
            Gets a boxed value for <c>0D</c>.
            </summary>
        </member>
        <member name="F:Fluent.Internal.KnownBoxes.DoubleBoxes.NaN">
            <summary>
            Gets a boxed value for <see cref="F:System.Double.NaN"/>.
            </summary>
        </member>
        <member name="F:Fluent.Internal.KnownBoxes.DoubleBoxes.MaxValue">
            <summary>
            Gets a boxed value for <see cref="F:System.Double.MaxValue"/>.
            </summary>
        </member>
        <member name="F:Fluent.Internal.KnownBoxes.DoubleBoxes.One">
            <summary>
            Gets a boxed value for <c>1D</c>.
            </summary>
        </member>
        <member name="T:Fluent.Internal.KnownBoxes.IconSizeBoxes">
            <summary>
            Class containing boxed values for <see cref="T:Fluent.IconSize"/>.
            </summary>
        </member>
        <member name="F:Fluent.Internal.KnownBoxes.IconSizeBoxes.Small">
            <summary>
            Gets a boxed value for <see cref="F:Fluent.IconSize.Small"/>.
            </summary>
        </member>
        <member name="F:Fluent.Internal.KnownBoxes.IconSizeBoxes.Medium">
            <summary>
            Gets a boxed value for <see cref="F:Fluent.IconSize.Medium"/>.
            </summary>
        </member>
        <member name="F:Fluent.Internal.KnownBoxes.IconSizeBoxes.Large">
            <summary>
            Gets a boxed value for <see cref="F:Fluent.IconSize.Large"/>.
            </summary>
        </member>
        <member name="F:Fluent.Internal.KnownBoxes.IconSizeBoxes.Custom">
            <summary>
            Gets a boxed value for <see cref="F:Fluent.IconSize.Custom"/>.
            </summary>
        </member>
        <member name="M:Fluent.Internal.KnownBoxes.IconSizeBoxes.Box(Fluent.IconSize)">
            <summary>
            Gets a boxed value for <see cref="T:Fluent.IconSize"/>.
            </summary>
        </member>
        <member name="T:Fluent.Internal.KnownBoxes.IntBoxes">
            <summary>
            Class containing boxed values for <see cref="T:System.Int32"/>.
            </summary>
        </member>
        <member name="F:Fluent.Internal.KnownBoxes.IntBoxes.Zero">
            <summary>
            Gets a boxed value for <c>0</c>.
            </summary>
        </member>
        <member name="F:Fluent.Internal.KnownBoxes.IntBoxes.One">
            <summary>
            Gets a boxed value for <c>1</c>.
            </summary>
        </member>
        <member name="F:Fluent.Internal.KnownBoxes.IntBoxes.MaxValue">
            <summary>
            Gets a boxed value for <see cref="F:System.Int32.MaxValue"/>.
            </summary>
        </member>
        <member name="T:Fluent.Internal.KnownBoxes.StringBoxes">
            <summary>
            Class containing boxed values for <see cref="T:System.String"/>.
            </summary>
        </member>
        <member name="F:Fluent.Internal.KnownBoxes.StringBoxes.Empty">
            <summary>
            Gets a boxed value for <see cref="F:System.String.Empty"/>.
            </summary>
        </member>
        <member name="T:Fluent.Internal.KnownBoxes.VisibilityBoxes">
            <summary>
            Class containing boxed values for <see cref="T:System.Windows.Visibility"/>.
            </summary>
        </member>
        <member name="F:Fluent.Internal.KnownBoxes.VisibilityBoxes.Visible">
            <summary>
            Gets a boxed value for <see cref="F:System.Windows.Visibility.Visible"/>.
            </summary>
        </member>
        <member name="F:Fluent.Internal.KnownBoxes.VisibilityBoxes.Hidden">
            <summary>
            Gets a boxed value for <see cref="F:System.Windows.Visibility.Hidden"/>.
            </summary>
        </member>
        <member name="F:Fluent.Internal.KnownBoxes.VisibilityBoxes.Collapsed">
            <summary>
            Gets a boxed value for <see cref="F:System.Windows.Visibility.Collapsed"/>.
            </summary>
        </member>
        <member name="M:Fluent.Internal.KnownBoxes.VisibilityBoxes.Box(System.Windows.Visibility)">
            <summary>
            Gets a boxed value for <paramref name="value"/>.
            </summary>
            <returns>A boxed <see cref="T:System.Windows.Visibility"/> value.</returns>
        </member>
        <member name="T:Fluent.Internal.ScopeGuard">
            <summary>
            Scope guard to prevent reentrancy.
            </summary>
        </member>
        <member name="M:Fluent.Internal.ScopeGuard.#ctor">
            <summary>
            Creates a new instance.
            </summary>
        </member>
        <member name="M:Fluent.Internal.ScopeGuard.#ctor(System.Action,System.Action)">
            <summary>
            Creates a new instance.
            </summary>
            <param name="onEntry">Action being called on entry.</param>
            <param name="onDispose">Action being called on dispose.</param>
        </member>
        <member name="P:Fluent.Internal.ScopeGuard.IsActive">
            <summary>
            Gets whether this instance is still active (not disposed) or not.
            </summary>
        </member>
        <member name="M:Fluent.Internal.ScopeGuard.Start">
            <summary>
            Starts the scope guard.
            </summary>
            <returns>The current instance for fluent usage.</returns>
        </member>
        <member name="M:Fluent.Internal.ScopeGuard.Dispose">
            <inheritdoc />
        </member>
        <member name="T:Fluent.Internal.UIHelper">
            <summary>
            Class with helper functions for UI related stuff
            </summary>
        </member>
        <member name="M:Fluent.Internal.UIHelper.GetFirstVisualChild(System.Windows.DependencyObject)">
            <summary>
            Gets the first visual child of <paramref name="parent"/>.
            If there are no visual children <c>null</c> is returned.
            </summary>
            <returns>The first visual child of <paramref name="parent"/> or <c>null</c> if there are no children.</returns>
        </member>
        <member name="M:Fluent.Internal.UIHelper.FindImmediateVisualChild``1(System.Windows.DependencyObject,System.Predicate{``0})">
            <summary>
            Tries to find immediate visual child of type <typeparamref name="T"/> which matches <paramref name="predicate"/>
            </summary>
            <returns>
            The visual child of type <typeparamref name="T"/> that matches <paramref name="predicate"/>.
            Returns <c>null</c> if no child matches.
            </returns>
        </member>
        <member name="M:Fluent.Internal.UIHelper.FindVisualChild``1(System.Windows.DependencyObject)">
            <summary>
            Gets the first visual child of type TChildItem by walking down the visual tree.
            </summary>
            <typeparam name="TChildItem">The type of visual child to find.</typeparam>
            <param name="parent">The parent element whose visual tree shall be walked down.</param>
            <returns>The first element of type TChildItem found in the visual tree is returned. If none is found, null is returned.</returns>
        </member>
        <member name="M:Fluent.Internal.UIHelper.GetVisualChildren(System.Windows.DependencyObject)">
            <summary>
            Gets all visual children of <paramref name="parent"/>.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Fluent.Internal.UIHelper.GetParent``1(System.Windows.DependencyObject,System.Predicate{``0})">
            <summary>
            Finds the parent control of type <typeparamref name="T"/>.
            First looks at the visual tree and then at the logical tree to find the parent.
            </summary>
            <returns>The found visual/logical parent or null.</returns>
            <remarks>This method searches further up the parent chain instead of just using the immediate parent.</remarks>
        </member>
        <member name="M:Fluent.Internal.UIHelper.GetVisualOrLogicalParent(System.Windows.DependencyObject)">
            <summary>
            Returns either the visual or logical parent of <paramref name="element"/>.
            This also works for <see cref="T:System.Windows.ContentElement"/> and <see cref="T:System.Windows.FrameworkContentElement"/>.
            </summary>
        </member>
        <member name="M:Fluent.Internal.UIHelper.GetVisualParent(System.Windows.DependencyObject)">
            <summary>
            Returns the visual parent of <paramref name="element"/>.
            This also works for <see cref="T:System.Windows.ContentElement"/> and <see cref="T:System.Windows.FrameworkContentElement"/>.
            </summary>
        </member>
        <member name="M:Fluent.Internal.UIHelper.GetAdornerLayer(System.Windows.Media.Visual)">
            <summary>
            First checks if <paramref name="visual"/> is either a <see cref="T:System.Windows.Documents.AdornerDecorator"/> or <see cref="T:System.Windows.Controls.ScrollContentPresenter"/> and if it is returns it's <see cref="T:System.Windows.Documents.AdornerLayer"/>.
            If those checks yield no result <see cref="M:System.Windows.Documents.AdornerLayer.GetAdornerLayer(System.Windows.Media.Visual)"/> is called.
            </summary>
            <param name="visual">The visual element for which to find an adorner layer.</param>
            <returns>An adorner layer for the specified visual, or null if no adorner layer can be found.</returns>
            <exception cref="T:System.ArgumentNullException">Raised when visual is null.</exception>
        </member>
        <member name="M:Fluent.Internal.UIHelper.GetAllItemContainers``1(System.Windows.Controls.ItemsControl)">
            <summary>
            Gets all containers from the <see cref="T:System.Windows.Controls.ItemContainerGenerator"/> of <paramref name="itemsControl"/>.
            </summary>
            <typeparam name="T">The desired container type.</typeparam>
        </member>
        <member name="M:Fluent.Internal.UIHelper.GetAllItemContainers``1(System.Windows.Controls.ItemContainerGenerator)">
            <summary>
            Gets all containers from <paramref name="itemContainerGenerator"/>.
            </summary>
            <typeparam name="T">The desired container type.</typeparam>
        </member>
        <member name="T:Fluent.Internal.WhenLoaded">
            <summary>
            Executes action on framework element when it's loaded.
            </summary>
            <remarks>
            Action is execued only once, no matter how many times Loaded event is fired.
            </remarks>
        </member>
        <member name="T:Fluent.Internal.WhenLoadedExtension">
            <summary>
            <see cref="M:Fluent.Internal.WhenLoadedExtension.WhenLoaded(System.Windows.FrameworkElement,System.Action{System.Windows.FrameworkElement})"/> class wrapper to add clarity to the code.
            </summary>
        </member>
        <member name="M:Fluent.Internal.WhenLoadedExtension.WhenLoaded(System.Windows.FrameworkElement,System.Action{System.Windows.FrameworkElement})">
            <summary>
            Executes given action only if framework element is loaded. Otherwise waits until framework element
            is loaded and executes the action.
            </summary>
            <param name="frameworkElement">Target framework element which we want to be loaded.</param>
            <param name="loadedAction">Action to be executed when framework element is loaded.</param>
            <remarks>Action is executed only once.</remarks>
        </member>
        <member name="T:Fluent.IRibbonControl">
            <summary>
            Base interface for Fluent controls
            </summary>
        </member>
        <member name="P:Fluent.IRibbonControl.Size">
            <summary>
            Gets or sets Size for the element
            </summary>
        </member>
        <member name="P:Fluent.IRibbonControl.SizeDefinition">
            <summary>
            Gets or sets SizeDefinition for element
            </summary>
        </member>
        <member name="P:Fluent.IRibbonControl.Icon">
            <summary>
            Gets or sets Icon for the element
            </summary>
        </member>
        <member name="T:Fluent.IRibbonStateStorage">
            <summary>
            Interface for handling loading and saving the state of a <see cref="T:Fluent.Ribbon"/>.
            </summary>
        </member>
        <member name="P:Fluent.IRibbonStateStorage.IsLoading">
            <summary>
            Gets whether state is currently loading.
            </summary>
        </member>
        <member name="P:Fluent.IRibbonStateStorage.IsLoaded">
            <summary>
            Gets or sets whether state is loaded.
            </summary>
        </member>
        <member name="M:Fluent.IRibbonStateStorage.SaveTemporary">
            <summary>
            Save current state to a temporary storage.
            </summary>
        </member>
        <member name="M:Fluent.IRibbonStateStorage.Save">
            <summary>
            Save current state to a persistent storage.
            </summary>
        </member>
        <member name="M:Fluent.IRibbonStateStorage.LoadTemporary">
            <summary>
            Load state from a temporary storage.
            </summary>
        </member>
        <member name="M:Fluent.IRibbonStateStorage.Load">
            <summary>
            Loads the state from a persistent storage.
            </summary>
            <remarks>
            Sets <see cref="P:Fluent.RibbonStateStorage.IsLoaded" /> after it's finished to prevent a race condition with saving the state to the temporary storage.
            </remarks>
        </member>
        <member name="M:Fluent.IRibbonStateStorage.Reset">
            <summary>
            Resets saved state.
            </summary>
        </member>
        <member name="T:Fluent.IRibbonWindow">
            <summary>
            Meant to support interop scenarios
            </summary>
        </member>
        <member name="P:Fluent.IRibbonWindow.TitleBar">
            <summary>
            Gets the titlebar
            </summary>
        </member>
        <member name="T:Fluent.IScalableRibbonControl">
            <summary>
            Repesents scalable ribbon contol
            </summary>
        </member>
        <member name="M:Fluent.IScalableRibbonControl.ResetScale">
            <summary>
            Resets the scale.
            </summary>
        </member>
        <member name="M:Fluent.IScalableRibbonControl.Enlarge">
            <summary>
            Enlarge control size.
            </summary>
        </member>
        <member name="M:Fluent.IScalableRibbonControl.Reduce">
            <summary>
            Reduce control size.
            </summary>
        </member>
        <member name="E:Fluent.IScalableRibbonControl.Scaled">
            <summary>
            Occurs when contol is scaled.
            </summary>
        </member>
        <member name="T:Fluent.ISimplifiedRibbonControl">
            <summary>
            Base interface for controls supports simplified state
            </summary>
        </member>
        <member name="P:Fluent.ISimplifiedRibbonControl.SimplifiedSizeDefinition">
            <summary>
            Gets or sets SimplifiedSizeDefinition for element on Simplified mode
            </summary>
        </member>
        <member name="P:Fluent.ISimplifiedRibbonControl.IsSimplified">
            <summary>
            Gets or sets whether or not the ribbon is in Simplified mode
            </summary>
        </member>
        <member name="T:Fluent.ISimplifiedStateControl">
            <summary>
            Base interface for controls requiring simplified state
            </summary>
        </member>
        <member name="M:Fluent.ISimplifiedStateControl.UpdateSimplifiedState(System.Boolean)">
            <summary>
            Update simplified state.
            </summary>
        </member>
        <member name="T:Fluent.IToggleButton">
            <summary>
            Interface for controls that support <see cref="T:Fluent.ToggleButton"/>-Behavior
            </summary>
        </member>
        <member name="P:Fluent.IToggleButton.GroupName">
            <summary>
            Gets or sets the name of the group that the toggle button belongs to.
            Use the GroupName property to specify a grouping of toggle buttons to
            create a mutually exclusive set of controls. You can use the GroupName
            property when only one selection is possible from a list of available
            options. When this property is set, only one ToggleButton in the specified
            group can be selected at a time.
            </summary>
        </member>
        <member name="P:Fluent.IToggleButton.IsChecked">
            <summary>
            Gets or sets a value indicating whether SplitButton is checked
            </summary>
        </member>
        <member name="P:Fluent.IToggleButton.IsLoaded">
            <summary>
            Gets a value indicating whether the ToggleButton is fully loaded
            </summary>
        </member>
        <member name="P:Fluent.IToggleButton.Parent">
            <summary>Gets the logical parent  element of this element. </summary>
            <returns>This element's logical parent.</returns>
        </member>
        <member name="T:Fluent.Localization.RibbonLocalizationAttribute">
            <summary>
            Attribute class providing informations about a localization
            </summary>
        </member>
        <member name="M:Fluent.Localization.RibbonLocalizationAttribute.#ctor(System.String,System.String)">
            <summary>
            Creates a new instance.
            </summary>
            <param name="displayName">Specifies the display name.</param>
            <param name="cultureName">Specifies the culture name.</param>
        </member>
        <member name="P:Fluent.Localization.RibbonLocalizationAttribute.DisplayName">
            <summary>
            Gets the display name.
            </summary>
        </member>
        <member name="P:Fluent.Localization.RibbonLocalizationAttribute.CultureName">
            <summary>
            Gets the culture name.
            </summary>
        </member>
        <member name="T:Fluent.Localization.RibbonLocalizationBase">
            <summary>
            Base class for localizations.
            </summary>
        </member>
        <member name="M:Fluent.Localization.RibbonLocalizationBase.#ctor">
            <summary>
            Creates a new instance and initializes <see cref="P:Fluent.Localization.RibbonLocalizationBase.CultureName"/> and <see cref="P:Fluent.Localization.RibbonLocalizationBase.DisplayName"/> from <see cref="T:Fluent.Localization.RibbonLocalizationAttribute"/>.
            </summary>
        </member>
        <member name="M:Fluent.Localization.RibbonLocalizationBase.#ctor(System.String,System.String)">
            <summary>
            Creates a new instance.
            </summary>
        </member>
        <member name="P:Fluent.Localization.RibbonLocalizationBase.CultureName">
            <summary>
            Gets or sets the culture name.
            </summary>
        </member>
        <member name="P:Fluent.Localization.RibbonLocalizationBase.DisplayName">
            <summary>
            Gets or sets the display name.
            </summary>
        </member>
        <member name="F:Fluent.Localization.RibbonLocalizationBase.FallbackLocalization">
            <summary>
            Fallback instance of <see cref="T:Fluent.Localization.Languages.English"/> for localization.
            </summary>
        </member>
        <member name="P:Fluent.Localization.RibbonLocalizationBase.Automatic">
            <summary>
            Gets text for representing "Automatic"
            </summary>
        </member>
        <member name="P:Fluent.Localization.RibbonLocalizationBase.BackstageBackButtonUid">
            <summary>
            Gets the Uid of the backstage back button
            </summary>
        </member>
        <member name="P:Fluent.Localization.RibbonLocalizationBase.BackstageButtonKeyTip">
            <summary>
            Gets KeyTip of backstage button
            </summary>
        </member>
        <member name="P:Fluent.Localization.RibbonLocalizationBase.BackstageButtonText">
            <summary>
            Gets text of backstage button
            </summary>
        </member>
        <member name="P:Fluent.Localization.RibbonLocalizationBase.CustomizeStatusBar">
            <summary>
            Gets customize Status Bar
            </summary>
        </member>
        <member name="P:Fluent.Localization.RibbonLocalizationBase.MoreColors">
            <summary>
            Gets text for representing "More colors..."
            </summary>
        </member>
        <member name="P:Fluent.Localization.RibbonLocalizationBase.NoColor">
            <summary>
            Gets text for representing "No color"
            </summary>
        </member>
        <member name="P:Fluent.Localization.RibbonLocalizationBase.QuickAccessToolBarDropDownButtonTooltip">
            <summary>
            Quick Access ToolBar DropDown Button ToolTip
            </summary>
        </member>
        <member name="P:Fluent.Localization.RibbonLocalizationBase.QuickAccessToolBarMenuHeader">
            <summary>
            Quick Access ToolBar  Menu Header
            </summary>
        </member>
        <member name="P:Fluent.Localization.RibbonLocalizationBase.QuickAccessToolBarMenuShowAbove">
            <summary>
            Quick Access ToolBar Menu Minimize Quick Access Toolbar
            </summary>
        </member>
        <member name="P:Fluent.Localization.RibbonLocalizationBase.QuickAccessToolBarMenuShowBelow">
            <summary>
            Quick Access ToolBar Minimize Quick Access Toolbar
            </summary>
        </member>
        <member name="P:Fluent.Localization.RibbonLocalizationBase.QuickAccessToolBarMoreControlsButtonTooltip">
            <summary>
            Quick Access ToolBar MoreControls Button ToolTip
            </summary>
        </member>
        <member name="P:Fluent.Localization.RibbonLocalizationBase.RibbonContextMenuAddGallery">
            <summary>
            Quick Access ToolBar Menu Add Gallery
            </summary>
        </member>
        <member name="P:Fluent.Localization.RibbonLocalizationBase.RibbonContextMenuAddGroup">
            <summary>
            Quick Access ToolBar Menu Add Group
            </summary>
        </member>
        <member name="P:Fluent.Localization.RibbonLocalizationBase.RibbonContextMenuAddItem">
            <summary>
            Quick Access ToolBar Menu Add Item
            </summary>
        </member>
        <member name="P:Fluent.Localization.RibbonLocalizationBase.RibbonContextMenuAddMenu">
            <summary>
            Quick Access ToolBar Menu Add Menu
            </summary>
        </member>
        <member name="P:Fluent.Localization.RibbonLocalizationBase.RibbonContextMenuCustomizeQuickAccessToolBar">
            <summary>
            Ribbon Context Menu Customize Quick Access Toolbar
            </summary>
        </member>
        <member name="P:Fluent.Localization.RibbonLocalizationBase.RibbonContextMenuCustomizeRibbon">
            <summary>
            Ribbon Context Menu Customize the ribbon
            </summary>
        </member>
        <member name="P:Fluent.Localization.RibbonLocalizationBase.RibbonContextMenuMinimizeRibbon">
            <summary>
            Ribbon Context Menu Minimize the ribbon
            </summary>
        </member>
        <member name="P:Fluent.Localization.RibbonLocalizationBase.RibbonContextMenuRemoveItem">
            <summary>
            Quick Access ToolBar Menu Remove Item
            </summary>
        </member>
        <member name="P:Fluent.Localization.RibbonLocalizationBase.RibbonContextMenuShowAbove">
            <summary>
            Ribbon Context Menu Minimize Quick Access Toolbar
            </summary>
        </member>
        <member name="P:Fluent.Localization.RibbonLocalizationBase.RibbonContextMenuShowBelow">
            <summary>
            Ribbon Context Menu Minimize Quick Access Toolbar
            </summary>
        </member>
        <member name="P:Fluent.Localization.RibbonLocalizationBase.ShowRibbon">
            <summary>
            Show Ribbon
            </summary>
        </member>
        <member name="P:Fluent.Localization.RibbonLocalizationBase.ExpandRibbon">
            <summary>
            Expand Ribbon
            </summary>
        </member>
        <member name="P:Fluent.Localization.RibbonLocalizationBase.MinimizeRibbon">
            <summary>
            Minimize Ribbon
            </summary>
        </member>
        <member name="P:Fluent.Localization.RibbonLocalizationBase.RibbonLayout">
            <summary>
            Ribbon Layout
            </summary>
        </member>
        <member name="P:Fluent.Localization.RibbonLocalizationBase.UseClassicRibbon">
            <summary>
            Use classic Ribbon
            </summary>
        </member>
        <member name="P:Fluent.Localization.RibbonLocalizationBase.UseSimplifiedRibbon">
            <summary>
            Use simplified Ribbon
            </summary>
        </member>
        <member name="P:Fluent.Localization.RibbonLocalizationBase.DisplayOptionsButtonScreenTipTitle">
            <summary>
            DisplayOptions Button ScreenTip Title
            </summary>
        </member>
        <member name="P:Fluent.Localization.RibbonLocalizationBase.DisplayOptionsButtonScreenTipText">
            <summary>
            DisplayOptions Button ScreenTip Text
            </summary>
        </member>
        <member name="P:Fluent.Localization.RibbonLocalizationBase.ScreenTipDisableReasonHeader">
            <summary>
            Gets ScreenTip's disable reason header
            </summary>
        </member>
        <member name="P:Fluent.Localization.RibbonLocalizationBase.ScreenTipF1LabelHeader">
            <summary>
            Gets ScreenTip's disable reason header
            </summary>
        </member>
        <member name="E:Fluent.Localization.RibbonLocalizationBase.PropertyChanged">
            <summary>
            Change notifications are not implemented.
            This class only implements <see cref="T:System.ComponentModel.INotifyPropertyChanged"/> to prevent WPF from trying to listen to changes by using other ways than listening for this event.
            </summary>
        </member>
        <member name="M:Fluent.Localization.RibbonLocalizationBase.Equals(Fluent.Localization.RibbonLocalizationBase)">
            <inheritdoc />
        </member>
        <member name="M:Fluent.Localization.RibbonLocalizationBase.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:Fluent.Localization.RibbonLocalizationBase.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:Fluent.Localization.RibbonLocalizationBase.op_Equality(Fluent.Localization.RibbonLocalizationBase,Fluent.Localization.RibbonLocalizationBase)">
            <summary>
            
            </summary>
        </member>
        <member name="M:Fluent.Localization.RibbonLocalizationBase.op_Inequality(Fluent.Localization.RibbonLocalizationBase,Fluent.Localization.RibbonLocalizationBase)">
            <summary>
            
            </summary>
        </member>
        <member name="T:Fluent.RibbonLocalization">
            <summary>
            Contains localizable Ribbon's properties.
            Set Culture property to change current Ribbon localization or
            set properties independently to use your localization
            </summary>
        </member>
        <member name="E:Fluent.RibbonLocalization.PropertyChanged">
            <inheritdoc />
        </member>
        <member name="M:Fluent.RibbonLocalization.RaisePropertyChanged(System.String)">
            <summary>
            Raises the <see cref="E:Fluent.RibbonLocalization.PropertyChanged"/> event.
            </summary>
        </member>
        <member name="P:Fluent.RibbonLocalization.Current">
            <summary>
            Static instance of <see cref="T:Fluent.RibbonLocalization"/> to ease it's usage in XAML.
            </summary>
        </member>
        <member name="P:Fluent.RibbonLocalization.LocalizationMap">
            <summary>
            Gets a map of all registered localization classes.
            </summary>
            <remarks>
            The key of items in this dictionary should be the CultureName.
            </remarks>
        </member>
        <member name="P:Fluent.RibbonLocalization.Culture">
            <summary>
            Gets or sets current culture used for localization.
            </summary>
        </member>
        <member name="P:Fluent.RibbonLocalization.Localization">
            <summary>
            Gets or sets the current localization.
            </summary>
        </member>
        <member name="M:Fluent.RibbonLocalization.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="T:Fluent.Metro.Behaviours.StylizedBehaviors">
            <summary>
            Enables the use of behaviors in styles
            </summary>
        </member>
        <member name="F:Fluent.Metro.Behaviours.StylizedBehaviors.BehaviorsProperty">
            <summary>
            <see cref="T:System.Windows.DependencyProperty"/> for behaviors.
            </summary>
        </member>
        <member name="M:Fluent.Metro.Behaviours.StylizedBehaviors.GetBehaviors(System.Windows.DependencyObject)">
            <summary>
            Gets the behaviors associated with <paramref name="dpo"/>
            </summary>
        </member>
        <member name="M:Fluent.Metro.Behaviours.StylizedBehaviors.SetBehaviors(System.Windows.DependencyObject,Fluent.Metro.Behaviours.StylizedBehaviorCollection)">
            <summary>
            Sets the behaviors associated with <paramref name="dpo"/>
            </summary>
        </member>
        <member name="T:Fluent.Metro.Behaviours.StylizedBehaviorCollection">
            <summary>
            Just a <see cref="T:System.Windows.FreezableCollection`1"/> for <see cref="T:Microsoft.Xaml.Behaviors.Behavior"/>
            </summary>
        </member>
        <member name="M:Fluent.Metro.Behaviours.StylizedBehaviorCollection.CreateInstanceCore">
            <inheritdoc />
        </member>
        <member name="T:Fluent.WindowCommands">
            <summary>
            Contains commands for <see cref="T:Fluent.RibbonWindow"/>
            </summary>
        </member>
        <member name="M:Fluent.WindowCommands.Finalize">
            <summary>
            Finalizes an instance of the <see cref="T:Fluent.WindowCommands"/> class.
            </summary>
        </member>
        <member name="M:Fluent.WindowCommands.Dispose">
            <inheritdoc />
        </member>
        <member name="M:Fluent.WindowCommands.Dispose(System.Boolean)">
            <summary>
            Dispose(bool disposing) executes in two distinct scenarios.
            If disposing equals true, the method has been called directly
            or indirectly by a user's code. Managed and unmanaged resources
            can be disposed.
            If disposing equals false, the method has been called by the
            runtime from inside the finalizer and you should not reference
            other objects. Only unmanaged resources can be disposed.
            </summary>
        </member>
        <member name="P:Fluent.WindowCommands.Minimize">
            <summary>
            Retrieves the translated string for Minimize
            </summary>
        </member>
        <member name="P:Fluent.WindowCommands.Maximize">
            <summary>
            Retrieves the translated string for Maximize
            </summary>
        </member>
        <member name="P:Fluent.WindowCommands.Restore">
            <summary>
            Retrieves the translated string for Restore
            </summary>
        </member>
        <member name="P:Fluent.WindowCommands.Close">
            <summary>
            Retrieves the translated string for Close
            </summary>
        </member>
        <member name="P:Fluent.WindowCommands.ItemsControl">
            <summary>
            Gets the <see cref="T:System.Windows.Controls.ItemsControl"/> responsible for showing <see cref="P:System.Windows.Controls.ItemsControl.Items"/>.
            </summary>
        </member>
        <member name="F:Fluent.WindowCommands.ItemsPanelVisibilityProperty">
            <summary>Identifies the <see cref="P:Fluent.WindowCommands.ItemsPanelVisibility"/> dependency property.</summary>
        </member>
        <member name="P:Fluent.WindowCommands.ItemsPanelVisibility">
            <summary>
            Gets or sets the <see cref="T:System.Windows.Visibility"/> of the panel which contains <see cref="P:System.Windows.Controls.ItemsControl.Items"/>.
            </summary>
        </member>
        <member name="P:Fluent.WindowCommands.ButtonBrush">
            <summary>
            Gets or sets the button brush
            </summary>
        </member>
        <member name="F:Fluent.WindowCommands.ButtonBrushProperty">
            <summary>Identifies the <see cref="P:Fluent.WindowCommands.ButtonBrush"/> dependency property.</summary>
        </member>
        <member name="M:Fluent.WindowCommands.OnApplyTemplate">
            <inheritdoc />
        </member>
        <member name="M:Fluent.WindowCommands.OnMouseRightButtonDown(System.Windows.Input.MouseButtonEventArgs)">
            <inheritdoc />
        </member>
        <member name="T:Fluent.RibbonCommands">
            <summary>
            Class for several commands belonging to the Ribbon
            </summary>
        </member>
        <member name="F:Fluent.RibbonCommands.OpenBackstage">
            <summary>
            Gets the value that represents the Open Backstage command
            </summary>
        </member>
        <member name="T:Fluent.ContextMenuService">
            <summary>
            Represents additional context menu service
            </summary>
        </member>
        <member name="M:Fluent.ContextMenuService.Attach(System.Type)">
            <summary>
            Attach needed parameters to control
            </summary>
        </member>
        <member name="M:Fluent.ContextMenuService.CoerceContextMenu(System.Windows.DependencyObject,System.Object)">
            <summary>
            Coerces the ContextMenu for <paramref name="d"/>.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Fluent.ContextMenuService.Coerce(System.Windows.DependencyObject)">
            <summary>
            Coerce control context menu
            </summary>
        </member>
        <member name="T:Fluent.KeyTipService">
            <summary>
            Handles Alt, F10 and so on
            </summary>
        </member>
        <member name="P:Fluent.KeyTipService.AreAnyKeyTipsVisible">
            <summary>
            Checks if any keytips are visible.
            </summary>
        </member>
        <member name="P:Fluent.KeyTipService.DefaultKeyTipKeys">
            <summary>
            The default keys used to activate key tips.
            </summary>
        </member>
        <member name="P:Fluent.KeyTipService.KeyTipKeys">
            <summary>
            List of key tip activation keys.
            </summary>
        </member>
        <member name="M:Fluent.KeyTipService.#ctor(Fluent.Ribbon)">
            <summary>
            Default constrctor
            </summary>
            <param name="ribbon">Host element</param>
        </member>
        <member name="M:Fluent.KeyTipService.Attach">
            <summary>
            Attaches self
            </summary>
        </member>
        <member name="M:Fluent.KeyTipService.Detach">
            <summary>
            Detachs self
            </summary>
        </member>
        <member name="T:Fluent.DismissPopupMode">
            <summary>
            Dismiss popup mode.
            </summary>
        </member>
        <member name="F:Fluent.DismissPopupMode.Always">
            <summary>
            Always dismiss popup.
            </summary>
        </member>
        <member name="F:Fluent.DismissPopupMode.MouseNotOver">
            <summary>
            Dismiss only if mouse is not over popup.
            </summary>
        </member>
        <member name="T:Fluent.DismissPopupReason">
            <summary>
            Reason for dismiss popup event.
            </summary>
        </member>
        <member name="F:Fluent.DismissPopupReason.Undefined">
            <summary>
            No reason given.
            </summary>
        </member>
        <member name="F:Fluent.DismissPopupReason.ApplicationLostFocus">
            <summary>
            Application lost focus.
            </summary>
        </member>
        <member name="F:Fluent.DismissPopupReason.ShowingKeyTips">
            <summary>
            Showing key tips.
            </summary>
        </member>
        <member name="T:Fluent.DismissPopupEventArgs">
            <summary>
            Dismiss popup arguments.
            </summary>
        </member>
        <member name="M:Fluent.DismissPopupEventArgs.#ctor">
            <summary>
            Standard constructor.
            </summary>
        </member>
        <member name="M:Fluent.DismissPopupEventArgs.#ctor(Fluent.DismissPopupMode)">
            <summary>
            Constructor.
            </summary>
            <param name="dismissMode">Dismiss mode.</param>
        </member>
        <member name="M:Fluent.DismissPopupEventArgs.#ctor(Fluent.DismissPopupMode,Fluent.DismissPopupReason)">
            <summary>
            Constructor.
            </summary>
            <param name="dismissMode">Dismiss mode.</param>
            <param name="reason">Dismiss reason.</param>
        </member>
        <member name="P:Fluent.DismissPopupEventArgs.DismissMode">
            <summary>
            Popup dismiss mode.
            </summary>
        </member>
        <member name="P:Fluent.DismissPopupEventArgs.DismissReason">
            <summary>
            Popup dismiss reason.
            </summary>
        </member>
        <member name="M:Fluent.DismissPopupEventArgs.InvokeEventHandler(System.Delegate,System.Object)">
            <inheritdoc />
        </member>
        <member name="T:Fluent.PopupService">
            <summary>
            Represent additional popup functionality
            </summary>
        </member>
        <member name="F:Fluent.PopupService.DismissPopupEvent">
            <summary>
            Occurs then popup is dismissed
            </summary>
        </member>
        <member name="M:Fluent.PopupService.RaiseDismissPopupEventAsync(System.Object,Fluent.DismissPopupMode,Fluent.DismissPopupReason)">
            <summary>
            Raises DismissPopup event (Async)
            </summary>
        </member>
        <member name="M:Fluent.PopupService.RaiseDismissPopupEvent(System.Object,Fluent.DismissPopupMode,Fluent.DismissPopupReason)">
            <summary>
            Raises DismissPopup event
            </summary>
        </member>
        <member name="M:Fluent.PopupService.Attach(System.Type)">
            <summary>
            Set needed parameters to control
            </summary>
            <param name="classType">Control type</param>
        </member>
        <member name="M:Fluent.PopupService.OnClickThroughThunk(System.Object,System.Windows.Input.MouseButtonEventArgs)">
            <summary>
            Handles PreviewMouseDownOutsideCapturedElementEvent event
            </summary>
        </member>
        <member name="M:Fluent.PopupService.OnLostMouseCapture(System.Object,System.Windows.Input.MouseEventArgs)">
            <summary>
            Handles lost mouse capture event
            </summary>
        </member>
        <member name="M:Fluent.PopupService.IsAncestorOf(System.Windows.DependencyObject,System.Windows.DependencyObject)">
            <summary>
            Returns true whether parent is ancestor of element
            </summary>
            <param name="parent">Parent</param>
            <param name="element">Element</param>
            <returns>Returns true whether parent is ancestor of element</returns>
        </member>
        <member name="M:Fluent.PopupService.OnDismissPopup(System.Object,Fluent.DismissPopupEventArgs)">
            <summary>
            Handles dismiss popup event
            </summary>
        </member>
        <member name="M:Fluent.PopupService.IsMousePhysicallyOver(System.Windows.Controls.Primitives.Popup)">
            <summary>
            Returns true whether mouse is physically over the popup
            </summary>
            <param name="popup">Element</param>
            <returns>Returns true whether mouse is physically over the popup</returns>
        </member>
        <member name="M:Fluent.PopupService.IsMousePhysicallyOver(System.Windows.UIElement)">
            <summary>
            Returns true whether mouse is physically over the element
            </summary>
            <param name="element">Element</param>
            <returns>Returns true whether mouse is physically over the element</returns>
        </member>
        <member name="M:Fluent.PopupService.OnContextMenuOpening(System.Object,System.Windows.Controls.ContextMenuEventArgs)">
            <summary>
            Handles context menu opening event
            </summary>
        </member>
        <member name="M:Fluent.PopupService.OnContextMenuClosing(System.Object,System.Windows.Controls.ContextMenuEventArgs)">
            <summary>
            Handles context menu closing event
            </summary>
        </member>
        <member name="T:Fluent.ToolTipService">
            <summary>
            Provides additional tooltip functionality.
            </summary>
        </member>
        <member name="M:Fluent.ToolTipService.Attach(System.Type)">
            <summary>
            Attach ooltip properties to control.
            </summary>
            <param name="type">Control type.</param>
        </member>
        <member name="T:Fluent.StyleSelectors.ApplicationMenuItemContainerStyleSelector">
            <summary>
            <see cref="T:System.Windows.Controls.StyleSelector"/> for <see cref="P:System.Windows.Controls.ItemsControl.ItemContainerStyle"/> in <see cref="T:Fluent.ApplicationMenu"/>.
            </summary>
        </member>
        <member name="P:Fluent.StyleSelectors.ApplicationMenuItemContainerStyleSelector.Instance">
            <summary>
                A singleton instance for <see cref="T:Fluent.StyleSelectors.ApplicationMenuItemContainerStyleSelector" />.
            </summary>
        </member>
        <member name="M:Fluent.StyleSelectors.ApplicationMenuItemContainerStyleSelector.SelectStyle(System.Object,System.Windows.DependencyObject)">
            <inheritdoc />
        </member>
        <member name="T:Fluent.StyleSelectors.BackstageTabControlItemContainerStyleSelector">
            <summary>
            <see cref="T:System.Windows.Controls.StyleSelector"/> for <see cref="P:System.Windows.Controls.ItemsControl.ItemContainerStyle"/> in <see cref="T:Fluent.BackstageTabControl"/>.
            </summary>
        </member>
        <member name="P:Fluent.StyleSelectors.BackstageTabControlItemContainerStyleSelector.Instance">
            <summary>
                A singleton instance for <see cref="T:Fluent.StyleSelectors.BackstageTabControlItemContainerStyleSelector" />.
            </summary>
        </member>
        <member name="M:Fluent.StyleSelectors.BackstageTabControlItemContainerStyleSelector.SelectStyle(System.Object,System.Windows.DependencyObject)">
            <inheritdoc />
        </member>
        <member name="T:Fluent.StyleSelectors.HeaderApplicationMenuItemItemContainerStyleSelector">
            <summary>
            <see cref="T:System.Windows.Controls.StyleSelector"/> for <see cref="P:System.Windows.Controls.ItemsControl.ItemContainerStyle"/> in <see cref="T:Fluent.MenuItem"/> with style HeaderApplicationMenuItemTemplate.
            </summary>
        </member>
        <member name="P:Fluent.StyleSelectors.HeaderApplicationMenuItemItemContainerStyleSelector.Instance">
            <summary>
                A singleton instance for <see cref="T:Fluent.StyleSelectors.HeaderApplicationMenuItemItemContainerStyleSelector" />.
            </summary>
        </member>
        <member name="M:Fluent.StyleSelectors.HeaderApplicationMenuItemItemContainerStyleSelector.SelectStyle(System.Object,System.Windows.DependencyObject)">
            <inheritdoc />
        </member>
        <member name="T:Fluent.StyleSelectors.SplitApplicationMenuItemItemContainerStyleSelector">
            <summary>
            <see cref="T:System.Windows.Controls.StyleSelector"/> for <see cref="P:System.Windows.Controls.ItemsControl.ItemContainerStyle"/> in <see cref="T:Fluent.MenuItem"/> with style SplitedApplicationMenuItem.
            </summary>
        </member>
        <member name="P:Fluent.StyleSelectors.SplitApplicationMenuItemItemContainerStyleSelector.Instance">
            <summary>
                A singleton instance for <see cref="T:Fluent.StyleSelectors.SplitApplicationMenuItemItemContainerStyleSelector" />.
            </summary>
        </member>
        <member name="M:Fluent.StyleSelectors.SplitApplicationMenuItemItemContainerStyleSelector.SelectStyle(System.Object,System.Windows.DependencyObject)">
            <inheritdoc />
        </member>
        <member name="T:Fluent.TemplateSelectors.RibbonGroupBoxHeaderTemplateSelector">
            <summary>
            <see cref="T:System.Windows.Controls.DataTemplateSelector"/> for the header of <see cref="T:Fluent.RibbonGroupBox"/>.
            </summary>
        </member>
        <member name="F:Fluent.TemplateSelectors.RibbonGroupBoxHeaderTemplateSelector.Instance">
            <summary>
            Gets a static instance of <see cref="T:Fluent.TemplateSelectors.RibbonGroupBoxHeaderTemplateSelector"/>.
            </summary>
        </member>
        <member name="M:Fluent.TemplateSelectors.RibbonGroupBoxHeaderTemplateSelector.SelectTemplate(System.Object,System.Windows.DependencyObject)">
            <inheritdoc />
        </member>
        <member name="T:Fluent.Theming.RibbonLibraryThemeProvider">
            <summary>
            Provides theme resources from Fluent.Ribbon.
            </summary>
        </member>
        <member name="F:Fluent.Theming.RibbonLibraryThemeProvider.DefaultInstance">
            <summary>
            Gets the default instance of this class.
            </summary>
        </member>
        <member name="M:Fluent.Theming.RibbonLibraryThemeProvider.#ctor">
            <inheritdoc cref="T:ControlzEx.Theming.LibraryThemeProvider" />
        </member>
        <member name="M:Fluent.Theming.RibbonLibraryThemeProvider.FillColorSchemeValues(System.Collections.Generic.Dictionary{System.String,System.String},ControlzEx.Theming.RuntimeThemeColorValues)">
            <inheritdoc />
        </member>
        <member name="T:Windows.Win32.PInvoke">
            <content>
            Contains extern methods from "KERNEL32.dll".
            </content>
            <content>
            Contains extern methods from "USER32.dll".
            </content>
        </member>
        <member name="M:Windows.Win32.PInvoke.ChooseColor(Windows.Win32.PInvoke.CHOOSECOLOR)">
            <summary>
            Creates a Color dialog box that enables the user to select a color.
            </summary>
            <param name="lpcc">A pointer to a CHOOSECOLOR structure that contains information used to initialize the dialog box. When ChooseColor returns, this structure contains information about the user's color selection.</param>
            <returns>If the user clicks the OK button of the dialog box, the return value is nonzero. The rgbResult member of the CHOOSECOLOR structure contains the RGB color value of the color selected by the user.If the user cancels or closes the Color dialog box or an error occurs, the return value is zero. </returns>
        </member>
        <member name="T:Windows.Win32.PInvoke.CHOOSECOLOR">
            <summary>
            Contains information the ChooseColor function uses to initialize the Color dialog box. After the user closes the dialog box, the system returns information about the user's selection in this structure. 
            </summary>
        </member>
        <member name="F:Windows.Win32.PInvoke.CHOOSECOLOR.lStructSize">
            <summary>
            The length, in bytes, of the structure. 
            </summary>
        </member>
        <member name="F:Windows.Win32.PInvoke.CHOOSECOLOR.hwndOwner">
            <summary>
            A handle to the window that owns the dialog box. This member can be any valid window handle, or it can be NULL if the dialog box has no owner. 
            </summary>
        </member>
        <member name="F:Windows.Win32.PInvoke.CHOOSECOLOR.hInstance">
            <summary>
            If the CC_ENABLETEMPLATEHANDLE flag is set in the Flags member, hInstance is a handle to a memory object containing a dialog box template. If the CC_ENABLETEMPLATE flag is set, hInstance is a handle to a module that contains a dialog box template named by the lpTemplateName member. If neither CC_ENABLETEMPLATEHANDLE nor CC_ENABLETEMPLATE is set, this member is ignored. 
            </summary>
        </member>
        <member name="F:Windows.Win32.PInvoke.CHOOSECOLOR.rgbResult">
            <summary>
            If the CC_RGBINIT flag is set, rgbResult specifies the color initially selected when the dialog box is created. If the specified color value is not among the available colors, the system selects the nearest solid color available. If rgbResult is zero or CC_RGBINIT is not set, the initially selected color is black. If the user clicks the OK button, rgbResult specifies the user's color selection. To create a COLORREF color value, use the RGB macro. 
            </summary>
        </member>
        <member name="F:Windows.Win32.PInvoke.CHOOSECOLOR.lpCustColors">
            <summary>
            A pointer to an array of 16 values that contain red, green, blue (RGB) values for the custom color boxes in the dialog box. If the user modifies these colors, the system updates the array with the new RGB values. To preserve new custom colors between calls to the ChooseColor function, you should allocate static memory for the array. To create a COLORREF color value, use the RGB macro. 
            </summary>
        </member>
        <member name="F:Windows.Win32.PInvoke.CHOOSECOLOR.Flags">
            <summary>
            A set of bit flags that you can use to initialize the Color dialog box. When the dialog box returns, it sets these flags to indicate the user's input. 
            </summary>
        </member>
        <member name="F:Windows.Win32.PInvoke.CHOOSECOLOR.lCustData">
            <summary>
            Application-defined data that the system passes to the hook procedure identified by the lpfnHook member. When the system sends the WM_INITDIALOG message to the hook procedure, the message's lParam parameter is a pointer to the CHOOSECOLOR structure specified when the dialog was created. The hook procedure can use this pointer to get the lCustData value. 
            </summary>
        </member>
        <member name="F:Windows.Win32.PInvoke.CHOOSECOLOR.lpfnHook">
            <summary>
            A pointer to a CCHookProc hook procedure that can process messages intended for the dialog box. This member is ignored unless the CC_ENABLEHOOK flag is set in the Flags member. 
            </summary>
        </member>
        <member name="F:Windows.Win32.PInvoke.CHOOSECOLOR.lpTemplateName">
            <summary>
            The name of the dialog box template resource in the module identified by the hInstance member. This template is substituted for the standard dialog box template. For numbered dialog box resources, lpTemplateName can be a value returned by the MAKEINTRESOURCE macro. This member is ignored unless the CC_ENABLETEMPLATE flag is set in the Flags member. 
            </summary>
        </member>
        <member name="F:Windows.Win32.PInvoke.CC_ANYCOLOR">
            <summary>
            Causes the dialog box to display all available colors in the set of basic colors.
            </summary>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_DDE_INITIATE">
            <summary>A Dynamic Data Exchange (DDE) client application sends a WM\_DDE\_INITIATE message to initiate a conversation with a server application responding to the specified application and topic names.</summary>
            <remarks>If the low-order word of *lParam* is **NULL**, any server application can respond. If the high-order word of *lParam* is **NULL**, any topic is valid. Upon receiving a **WM\_DDE\_INITIATE** request with the high-order word of the *lParam* parameter set to **NULL**, a server must send a [**WM\_DDE\_ACK**](wm-dde-ack.md) message for each of the topics it supports.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_DDE_TERMINATE">
            <summary>A Dynamic Data Exchange (DDE) application (client or server) posts a WM\_DDE\_TERMINATE message to terminate a conversation. To post this message, call the PostMessage function with the following parameters.</summary>
            <remarks></remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_DDE_ADVISE">
            <summary>A Dynamic Data Exchange (DDE) client application posts the WM\_DDE\_ADVISE message to a DDE server application to request the server to supply an update for a data item whenever the item changes.</summary>
            <remarks>If a client application supports more than one clipboard format for a single topic and item, it can post multiple **WM\_DDE\_ADVISE** messages for the topic and item, specifying a different clipboard format with each message. Note that a server can support multiple formats only for hot data links, not warm data links.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_DDE_UNADVISE">
            <summary>A Dynamic Data Exchange (DDE) client application posts a WM\_DDE\_UNADVISE message to inform a DDE server application that the specified item or a particular clipboard format for the item should no longer be updated.</summary>
            <remarks>
            <para>The client application allocates the high-order word of *lParam* by calling the [**GlobalAddAtom**](/windows/desktop/api/Winbase/nf-winbase-globaladdatoma) function. The server application posts the [**WM\_DDE\_ACK**](wm-dde-ack.md) message to respond positively or negatively. When posting **WM\_DDE\_ACK**, the server can either reuse the atom, or it can delete the atom and create a new one.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/dataxchg/wm-dde-unadvise#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_DDE_ACK">
            <summary>The WM\_DDE\_ACK message notifies a Dynamic Data Exchange (DDE) application of the receipt and processing of the following messages WM\_DDE\_POKE, WM\_DDE\_EXECUTE, WM\_DDE\_DATA, WM\_DDE\_ADVISE, WM\_DDE\_UNADVISE, WM\_DDE\_INITIATE, or WM\_DDE\_REQUEST (in some cases). To post this message, call the PostMessage function with the following parameters.</summary>
            <remarks></remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_DDE_DATA">
            <summary>A Dynamic Data Exchange (DDE) server application posts a WM\_DDE\_DATA message to a DDE client application to pass a data item to the client or to notify the client of the availability of a data item.</summary>
            <remarks></remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_DDE_REQUEST">
            <summary>A Dynamic Data Exchange (DDE) client application posts a WM\_DDE\_REQUEST message to a DDE server application to request the value of a data item. To post this message, call the PostMessage function with the following parameters.</summary>
            <remarks></remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_DDE_POKE">
            <summary>A Dynamic Data Exchange (DDE) client application posts a WM\_DDE\_POKE message to a DDE server application.</summary>
            <remarks></remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_DDE_EXECUTE">
            <summary>A Dynamic Data Exchange (DDE) client application posts a WM\_DDE\_EXECUTE message to a DDE server application to send a string to the server to be processed as a series of commands.</summary>
            <remarks>
            <para>The command string is a null-terminated string consisting of one or more opcode strings enclosed in single brackets (\[ \]). Each opcode string has the following syntax, where the *parameters* list is optional: *opcode parameters* The *opcode* is any application-defined single token. It cannot include spaces, commas, parentheses, brackets, or quotation marks. The *parameters* list can contain any application-defined value or values. Multiple parameters are separated by commas, and the entire parameter list is enclosed in parentheses. Parameters cannot include commas or parentheses except inside a quoted string. If a bracket or parenthesis character is to appear in a quoted string, it need not be doubled, as was the case under the old rules. The following are valid command strings:</para>
            <para></para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/dataxchg/wm-dde-execute#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_CTLCOLOR">
            <summary>The WM\_CTLCOLOR message is used in 16-bit versions of Windows to change the color scheme of list boxes, the list boxes of combo boxes, message boxes, button controls, edit controls, static controls, and dialog boxes.Note  For information related to this message and 32-bit versions of Windows, see Remarks.</summary>
            <returns>If an application processes this message, it returns a handle to a brush. The system uses the brush to paint the background of the control.</returns>
            <remarks>
            <para>The **WM\_CTLCOLOR** message from 16-bit Windows has been replaced by more specific notifications. These replacements include the following: -   [**WM\_CTLCOLORBTN**](../controls/wm-ctlcolorbtn.md) -   [**WM\_CTLCOLOREDIT**](../controls/wm-ctlcoloredit.md) -   [**WM\_CTLCOLORDLG**](../dlgbox/wm-ctlcolordlg.md) -   [**WM\_CTLCOLORLISTBOX**](../controls/wm-ctlcolorlistbox.md) -   [**WM\_CTLCOLORSCROLLBAR**](../controls/wm-ctlcolorscrollbar.md) -   [**WM\_CTLCOLORSTATIC**](../controls/wm-ctlcolorstatic.md)</para>
            <para><see href="https://learn.microsoft.com/windows/win32/DevNotes/wm-ctlcolor-#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_MOUSEHOVER">
            <summary>Posted to a window when the cursor hovers over the client area of the window for the period of time specified in a prior call to TrackMouseEvent.</summary>
            <returns>If an application processes this message, it should return zero.</returns>
            <remarks>
            <para>Hover tracking stops when **WM\_MOUSEHOVER** is generated. The application must call [**TrackMouseEvent**](/windows/win32/api/winuser/nf-winuser-trackmouseevent) again if it requires further tracking of mouse hover behavior. Use the following code to obtain the horizontal and vertical position:</para>
            <para></para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/inputdev/wm-mousehover#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_MOUSELEAVE">
            <summary>Posted to a window when the cursor leaves the client area of the window specified in a prior call to TrackMouseEvent.</summary>
            <returns>If an application processes this message, it should return zero.</returns>
            <remarks>All tracking requested by [**TrackMouseEvent**](/windows/win32/api/winuser/nf-winuser-trackmouseevent) is canceled when this message is generated. The application must call **TrackMouseEvent** when the mouse reenters its window if it requires further tracking of mouse hover behavior.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_CHOOSEFONT_GETLOGFONT">
            <summary>An application sends the WM\_CHOOSEFONT\_GETLOGFONT message to a Font dialog box to retrieve information about the user's current font selections.</summary>
            <returns>This message does not return a value.</returns>
            <remarks>
            <para>The [**ChooseFont**](/windows/win32/api/commdlg/ns-commdlg-choosefonta) function creates a **Font** dialog box. When the user closes the **Font** dialog box, the **ChooseFont** function returns information about the user's font selections in the [**CHOOSEFONT**](/windows/win32/api/commdlg/ns-commdlg-choosefonta) structure. The **lpLogFont** member of the **CHOOSEFONT** structure is a pointer to a [**LOGFONT**](/windows/win32/api/wingdi/ns-wingdi-logfonta) structure. Use the **WM\_CHOOSEFONT\_GETLOGFONT** message to get information about the user's current font selections while the **Font** dialog box is open. For example, if you enable the **Apply** button in the **Font** dialog box, send the message to get the font information to apply to the current text selection. Typically, you enable a [*CFHookProc*](/windows/win32/api/commdlg/nc-commdlg-lpcfhookproc) hook procedure to process [**WM\_COMMAND**](/windows/desktop/menurc/wm-command) messages for the **Apply** button. When the user clicks the **Apply** button, the hook procedure sends the **WM\_CHOOSEFONT\_GETLOGFONT** message to the dialog box.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/dlgbox/wm-choosefont-getlogfont#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_CHOOSEFONT_SETLOGFONT">
            <summary>An application sends the WM\_CHOOSEFONT\_SETLOGFONT message to a Font dialog box to set the current logical font information.</summary>
            <returns>This message has no return value.</returns>
            <remarks>
            <para>When you call the [**ChooseFont**](/windows/win32/api/commdlg/ns-commdlg-choosefonta) function to create a **Font** dialog box, you can use the **lpLogFont** member of the [**CHOOSEFONT**](/windows/win32/api/commdlg/ns-commdlg-choosefonta) structure to specify a [**LOGFONT**](/windows/win32/api/wingdi/ns-wingdi-logfonta) structure containing initial values for the dialog box. Use the **WM\_CHOOSEFONT\_SETLOGFONT** message to specify a **LOGFONT** structure with different values while the **Font** dialog box is open. Typically, you would send the **WM\_CHOOSEFONT\_SETLOGFONT** message from a [**CFHookProc**](/windows/win32/api/commdlg/nc-commdlg-lpcfhookproc) hook procedure. The hook procedure can also send the [**WM\_CHOOSEFONT\_GETLOGFONT**](wm-choosefont-getlogfont.md) and [**WM\_CHOOSEFONT\_SETFLAGS**](wm-choosefont-setflags.md) messages.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/dlgbox/wm-choosefont-setlogfont#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_CHOOSEFONT_SETFLAGS">
            <summary>An application sends the WM\_CHOOSEFONT\_SETFLAGS message to a Font dialog box to set the display options for the dialog box.</summary>
            <returns>No return value.</returns>
            <remarks>
            <para>The [**ChooseFont**](/windows/win32/api/commdlg/ns-commdlg-choosefonta) function creates a **Font** dialog box and uses a [**CHOOSEFONT**](/windows/win32/api/commdlg/ns-commdlg-choosefonta) structure to specify the initial values for the **Flags** member. Use the **WM\_CHOOSEFONT\_SETFLAGS** message to specify different values for the **Flags** member while the **Font** dialog box is open. Typically, you should send the **WM\_CHOOSEFONT\_SETFLAGS** message from a [**CFHookProc**](/windows/win32/api/commdlg/nc-commdlg-lpcfhookproc) hook procedure.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/dlgbox/wm-choosefont-setflags#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_PSD_FULLPAGERECT">
            <summary>Notifies a PagePaintHook hook procedure of the coordinates of the sample page rectangle in the Page Setup dialog box. The dialog box sends this message when it is about to draw the contents of the sample page.</summary>
            <returns>
            <para>If the hook procedure returns **TRUE**, the dialog box sends no more messages and does not draw in the sample page until the next time the system needs to redraw the sample page. If the hook procedure returns **FALSE**, the dialog box sends the remaining messages of the drawing sequence.</para>
            </returns>
            <remarks>The **Page Setup** dialog box includes an image of a sample page that shows how the user's selections affect the appearance of the printed output. When you call the [**PageSetupDlg**](/previous-versions/windows/desktop/legacy/ms646937(v=vs.85)) function, you can provide a [*PagePaintHook*](/windows/win32/api/commdlg/nc-commdlg-lppagepainthook) hook procedure to customize the appearance of the sample page. Whenever the dialog box is about to draw the contents of the sample page, the dialog box sends a sequence of messages to the hook procedure.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_PSD_MINMARGINRECT">
            <summary>Notifies a PagePaintHook hook procedure of the coordinates of the margin rectangle in the sample page. A Page Setup dialog box sends this message when it is about to draw the contents of the sample page.</summary>
            <returns>
            <para>If the hook procedure returns **TRUE**, the dialog box sends no more messages and does not draw in the sample page until the next time the system needs to redraw the sample page. If the hook procedure returns **FALSE**, the dialog box sends the remaining messages of the drawing sequence.</para>
            </returns>
            <remarks>The **Page Setup** dialog box includes an image of a sample page that shows how the user's selections affect the appearance of the printed output. When you call the [**PageSetupDlg**](/previous-versions/windows/desktop/legacy/ms646937(v=vs.85)) function, you can provide a [*PagePaintHook*](/windows/win32/api/commdlg/nc-commdlg-lppagepainthook) hook procedure to customize the appearance of the sample page. Whenever the dialog box is about to draw the contents of the sample page, the dialog box sends a sequence of messages to the hook procedure.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_PSD_MARGINRECT">
            <summary>Notifies the hook procedure of a Page Setup dialog box, PagePaintHook, that the dialog box is about to draw the margin rectangle of the sample page.</summary>
            <returns>
            <para>If the hook procedure returns **TRUE**, the dialog box does not draw the margin rectangle in the sample page. If the hook procedure returns **FALSE**, the dialog box draws the margin rectangle in the sample page.</para>
            </returns>
            <remarks>The **Page Setup** dialog box includes an image of a sample page that shows how the user's selections affect the appearance of the printed output. When you call the [**PageSetupDlg**](/previous-versions/windows/desktop/legacy/ms646937(v=vs.85)) function, you can provide a [*PagePaintHook*](/windows/win32/api/commdlg/nc-commdlg-lppagepainthook) hook procedure to customize the appearance of the sample page. Whenever the dialog box is about to draw the contents of the sample page, the dialog box sends a sequence of messages to the hook procedure.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_PSD_GREEKTEXTRECT">
            <summary>Notifies the hook procedure of a Page Setup dialog box, PagePaintHook, that the dialog box is about to draw Greek text inside the margin rectangle of the sample page.</summary>
            <returns>
            <para>If the hook procedure returns **TRUE**, the dialog box does not draw the Greek text portion of the sample page. If the hook procedure returns **FALSE**, the dialog box draws the Greek text portion of the sample page.</para>
            </returns>
            <remarks>The **Page Setup** dialog box includes an image of a sample page that shows how the user's selections affect the appearance of the printed output. When you call the [**PageSetupDlg**](/previous-versions/windows/desktop/legacy/ms646937(v=vs.85)) function, you can provide a [*PagePaintHook*](/windows/win32/api/commdlg/nc-commdlg-lppagepainthook) hook procedure to customize the appearance of the sample page. Whenever the dialog box is about to draw the contents of the sample page, the dialog box sends a sequence of messages to the hook procedure.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_PSD_ENVSTAMPRECT">
            <summary>Notifies the hook procedure of a Page Setup dialog box, PagePaintHook, that the dialog box is about to draw the envelope-stamp rectangle of the sample page.</summary>
            <returns>
            <para>If the hook procedure returns **TRUE**, the dialog box does not draw the envelope-stamp portion of the sample page. If the hook procedure returns **FALSE**, the dialog box draws the envelope-stamp portion of the sample page.</para>
            </returns>
            <remarks>
            <para>The **Page Setup** dialog box includes an image of a sample page that shows how the user's selections affect the appearance of the printed output. When you call the [**PageSetupDlg**](/previous-versions/windows/desktop/legacy/ms646937(v=vs.85)) function, you can provide a [*PagePaintHook*](/windows/win32/api/commdlg/nc-commdlg-lppagepainthook) hook procedure to customize the appearance of the sample page. Whenever the dialog box is about to draw the contents of the sample page, the dialog box sends a sequence of messages to the hook procedure. A hook procedure receives this message only if the selected paper type is an envelope.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/dlgbox/wm-psd-envstamprect#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_PSD_YAFULLPAGERECT">
            <summary>Notifies the hook procedure of a Page Setup dialog box, PagePaintHook, that the dialog box is about to draw the return address portion of an envelope sample page.</summary>
            <returns>
            <para>If the hook procedure returns **TRUE**, the dialog box does not draw the return address portion of an envelope sample page. If the hook procedure returns **FALSE**, the dialog box draws the return address portion of an envelope sample page. If the paper type is not an envelope, the return value has no effect.</para>
            </returns>
            <remarks>The **Page Setup** dialog box includes an image of a sample page that shows how the user's selections affect the appearance of the printed output. When you call the [**PageSetupDlg**](/previous-versions/windows/desktop/legacy/ms646937(v=vs.85)) function, you can provide a [*PagePaintHook*](/windows/win32/api/commdlg/nc-commdlg-lppagepainthook) hook procedure to customize the appearance of the sample page. Whenever the dialog box is about to draw the contents of the sample page, the dialog box sends a sequence of messages to the hook procedure.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_CPL_LAUNCH">
            <summary>WM_CPL_LAUNCH message - This message is not supported.</summary>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/shell/wm-cpl-launch">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_CPL_LAUNCHED">
            <summary>WM_CPL_LAUNCHED message - This message is not supported.</summary>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/shell/wm-cpl-launched">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_TABLET_ADDED">
            <summary>The WM\_TABLET\_ADDED message is posted when a tablet device is added to Windows.</summary>
            <remarks>
            <para>This message is sent to all top-level windows in the system, including disabled or invisible unowned windows, overlapped windows, and pop-up windows; but the message is not sent to child windows. The indexes passed in *wParam* are related to the index used by the [**ITabletManager::GetTablet**](/previous-versions/windows/desktop/legacy/aa373683(v=vs.85)) method.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/tablet/wm-tablet-added#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_TABLET_DELETED">
            <summary>The WM\_TABLET\_DELETED message is posted when a tablet device is removed from Windows.</summary>
            <remarks>
            <para>This message is sent to all top-level windows in the system, including disabled or invisible unowned windows, overlapped windows, and pop-up windows; but the message is not sent to child windows. The indexes passed in *wParam* are related to the index used by the [**ITabletManager::GetTablet**](/previous-versions/windows/desktop/legacy/aa373683(v=vs.85)) method.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/tablet/wm-tablet-deleted#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_TABLET_FLICK">
            <summary>Sent when a user performs a pen flick. A window receives this message through its WindowProc function.</summary>
            <remarks>
            <para>A pen flick is a unidirectional pen gesture that requires the user to contact the digitizer in a quick, straight flicking motion. A flick is characterized by high speed and a high degree of straightness. A flick is identified by its direction. Flicks can be made in eight directions corresponding to the cardinal and secondary compass directions. When a pen flick occurs, Windows first notifies an application by sending a **WM\_TABLET\_FLICK** message, which a window receives through its [*WindowProc*](/previous-versions/windows/desktop/legacy/ms633573(v=vs.85)) function. Return the **FLICK\_WM\_HANDLED\_MASK** constant, described in [Flicks Constants](flicks-constants.md), to indicate that the application responded to the **WM\_TABLET\_FLICK** message. If the application does not return **FLICK\_WM\_HANDLED\_MASK**, Windows performs the default action specified in the flicks control panel by sending a follow-up notification, such as [**WM\_APPCOMMAND**](../inputdev/wm-appcommand.md), [**WM\_VSCROLL**](../controls/wm-vscroll.md), or [**WM\_KEYDOWN**](../inputdev/wm-keydown.md), depending on which action is associated with the pen flick. Use caution when handling the **WM\_TABLET\_FLICK** message. **WM\_TABLET\_FLICK** is passed via the [**SendMessageTimeout**](/windows/win32/api/winuser/nf-winuser-sendmessagetimeouta) function. If you call methods on a COM interface, that object must be within the same process. If not, COM throws an exception.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/tablet/wm-tablet-flick-message#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_TABLET_QUERYSYSTEMGESTURESTATUS">
            <summary>Sent when the system asks a window which system gestures it would like to receive.</summary>
            <remarks>
            <para>By handling this message, you can dynamically disable flicks for regions of a window. > [!Note] > The *lParam* can be converted to x-coordinates and y-coordinates by using the `GET_X_LPARAM` and `GET_Y_LPARAM` macros.</para>
            <para>By default, your window will receive all system gesture events. You can choose which events you would like your window to receive and which events you would like disabled by responding to the **WM\_TABLET\_QUERYSYSTEMGESTURESTATUS** message in your **WndProc**. The **WM\_TABLET\_QUERYSYSTEMGESTURESTATUS** message is defined in tpcshrd.h. The values to enable and disable system tablet system gestures are also defined in tpcshrd.h as follows: </para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/tablet/wm-tablet-querysystemgesturestatus-message#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_CONTEXTMENU">
            <summary>Notifies a window that the user clicked the right mouse button (right-clicked) in the window.</summary>
            <returns>No return value.</returns>
            <remarks>
            <para>A window can process this message by displaying a shortcut menu using the [**TrackPopupMenu**](/windows/desktop/api/Winuser/nf-winuser-trackpopupmenu) or [**TrackPopupMenuEx**](/windows/desktop/api/Winuser/nf-winuser-trackpopupmenuex) functions. To obtain the horizontal and vertical positions, use the following code.</para>
            <para></para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/menurc/wm-contextmenu#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_UNICHAR">
            <summary>The WM\_UNICHAR message can be used by an application to post input to other windows.</summary>
            <returns>An application should return zero if it processes this message.</returns>
            <remarks>
            <para>The **WM\_UNICHAR** message is similar to [**WM\_CHAR**](wm-char.md), but it uses Unicode Transformation Format (UTF)-32, whereas **WM\_CHAR** uses UTF-16. This message is designed to send or post Unicode characters to ANSI windows and can handle Unicode Supplementary Plane characters. Because there is not necessarily a one-to-one correspondence between keys pressed and character messages generated, the information in the high-order word of the *lParam* parameter is generally not useful to applications. The information in the high-order word applies only to the most recent [**WM\_KEYDOWN**](wm-keydown.md) message that precedes the posting of the **WM\_UNICHAR** message. For enhanced 101- and 102-key keyboards, extended keys are the right ALT and the right CTRL keys on the main section of the keyboard; the INS, DEL, HOME, END, PAGE UP, PAGE DOWN and arrow keys in the clusters to the left of the numeric keypad; and the divide (/) and ENTER keys in the numeric keypad. Some other keyboards may support the extended-key bit in the *lParam* parameter.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/inputdev/wm-unichar#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_PRINTCLIENT">
            <summary>The WM\_PRINTCLIENT message is sent to a window to request that it draw its client area in the specified device context, most commonly in a printer device context.</summary>
            <remarks>
            <para>A window can process this message in much the same manner as [**WM\_PAINT**](./wm-paint.md), except that [**BeginPaint**](/windows/desktop/api/Winuser/nf-winuser-beginpaint) and [**EndPaint**](/windows/desktop/api/Winuser/nf-winuser-endpaint) need not be called (a device context is provided), and the window should draw its entire client area rather than just the invalid region. Windows that can be used anywhere in the system, such as controls, should process this message. It is probably worthwhile for other windows to process this message as well because it is relatively easy to implement. The [AnimateWindow](/windows/desktop/api/winuser/nf-winuser-animatewindow) function requires that the window being animated implements the **WM\_PRINTCLIENT** message.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/gdi/wm-printclient#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_NOTIFY">
            <summary>Sent by a common control to its parent window when an event has occurred or the control requires some information.</summary>
            <returns>The return value is ignored except for notification messages that specify otherwise.</returns>
            <remarks>
            <para>The destination of the message must be the **HWND** of the parent of the control. This value can be obtained by using [**GetParent**](/windows/desktop/api/winuser/nf-winuser-getparent), as shown in the following example, where *m\_controlHwnd* is the **HWND** of the control itself.</para>
            <para></para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/Controls/wm-notify#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_DEVICECHANGE">
            <summary>Notifies an application of a change to the hardware configuration of a device or the computer.</summary>
            <returns>
            <para>Return **TRUE** to grant the request. Return **BROADCAST\_QUERY\_DENY** to deny the request.</para>
            </returns>
            <remarks>For devices that offer software-controllable features, such as ejection and locking, the system typically sends a [DBT\_DEVICEREMOVEPENDING](dbt-deviceremovepending.md) message to let applications and device drivers end their use of the device gracefully. If the system forcibly removes a device, it may not send a [DBT\_DEVICEQUERYREMOVE](dbt-devicequeryremove.md) message before doing so.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_NULL">
            <summary>Performs no operation. An application sends the WM\_NULL message if it wants to post a message that the recipient window will ignore.</summary>
            <returns>
            <para>Type: **LRESULT** An application returns zero if it processes this message.</para>
            </returns>
            <remarks>
            <para>For example, if an application has installed a **WH\_GETMESSAGE** hook and wants to prevent a message from being processed, the [**GetMsgProc**](/previous-versions/windows/desktop/legacy/ms644981(v=vs.85)) callback function can change the message number to **WM\_NULL** so the recipient will ignore it. As another example, an application can check if a window is responding to messages by sending the **WM\_NULL** message with the [**SendMessageTimeout**](/windows/win32/api/winuser/nf-winuser-sendmessagetimeouta) function.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/winmsg/wm-null#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_CREATE">
            <summary>Sent when an application requests that a window be created by calling the CreateWindowEx or CreateWindow function.</summary>
            <returns>
            <para>Type: **LRESULT** If an application processes this message, it should return zero to continue creation of the window. If the application returns –1, the window is destroyed and the [**CreateWindowEx**](/windows/win32/api/winuser/nf-winuser-createwindowexa) or [**CreateWindow**](/windows/win32/api/winuser/nf-winuser-createwindowa) function returns a **NULL** handle.</para>
            </returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/winmsg/wm-create">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_DESTROY">
            <summary>Sent when a window is being destroyed. It is sent to the window procedure of the window being destroyed after the window is removed from the screen.</summary>
            <returns>
            <para>Type: **LRESULT** If an application processes this message, it should return zero.</para>
            </returns>
            <remarks>If the window being destroyed is part of the clipboard viewer chain (set by calling the [**SetClipboardViewer**](/windows/win32/api/winuser/nf-winuser-setclipboardviewer) function), the window must remove itself from the chain by processing the [**ChangeClipboardChain**](/windows/win32/api/winuser/nf-winuser-changeclipboardchain) function before returning from the **WM\_DESTROY** message.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_MOVE">
            <summary>Sent after a window has been moved.</summary>
            <returns>
            <para>Type: **LRESULT** If an application processes this message, it should return zero.</para>
            </returns>
            <remarks>
            <para>The parameters are given in screen coordinates for overlapped and pop-up windows and in parent-client coordinates for child windows. The following example demonstrates how to obtain the position from the *lParam* parameter.</para>
            <para></para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/winmsg/wm-move#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_SIZE">
            <summary>Sent to a window after its size has changed.</summary>
            <returns>
            <para>Type: **LRESULT** If an application processes this message, it should return zero.</para>
            </returns>
            <remarks>
            <para>If the [**SetScrollPos**](https://msdn.microsoft.com/library/Cc411085(v=MSDN.10).aspx) or [**MoveWindow**](/windows/win32/api/winuser/nf-winuser-movewindow) function is called for a child window as a result of the **WM\_SIZE** message, the *bRedraw* or *bRepaint* parameter should be nonzero to cause the window to be repainted. Although the width and height of a window are 32-bit values, the *lParam* parameter contains only the low-order 16 bits of each. The [**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowproca) function sends the **WM\_SIZE** and **WM\_MOVE** messages when it processes the [**WM\_WINDOWPOSCHANGED**](wm-windowposchanged.md) message. The **WM\_SIZE** and **WM\_MOVE** messages are not sent if an application handles the **WM\_WINDOWPOSCHANGED** message without calling **DefWindowProc**.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/winmsg/wm-size#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_ACTIVATE">
            <summary>Sent to both the window being activated and the window being deactivated.</summary>
            <returns>If an application processes this message, it should return zero.</returns>
            <remarks>If the window is being activated and is not minimized, the [**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowproca) function sets the keyboard focus to the window. If the window is activated by a mouse click, it also receives a [**WM\_MOUSEACTIVATE**](wm-mouseactivate.md) message.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_SETFOCUS">
            <summary>Sent to a window after it has gained the keyboard focus.</summary>
            <returns>An application should return zero if it processes this message.</returns>
            <remarks>To display a caret, an application should call the appropriate caret functions when it receives the **WM\_SETFOCUS** message.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_KILLFOCUS">
            <summary>Sent to a window immediately before it loses the keyboard focus.</summary>
            <returns>An application should return zero if it processes this message.</returns>
            <remarks>
            <para>If an application is displaying a caret, the caret should be destroyed at this point. While processing this message, do not make any function calls that display or activate a window. This causes the thread to yield control and can cause the application to stop responding to messages. For more information, see [Message Deadlocks](/windows/desktop/winmsg/about-messages-and-message-queues).</para>
            <para><see href="https://learn.microsoft.com/windows/win32/inputdev/wm-killfocus#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_ENABLE">
            <summary>Sent when an application changes the enabled state of a window.</summary>
            <returns>
            <para>Type: **LRESULT** If an application processes this message, it should return zero.</para>
            </returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/winmsg/wm-enable">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_SETREDRAW">
            <summary>You send the **WM_SETREDRAW** message to a window to allow changes in that window to be redrawn, or to prevent changes in that window from being redrawn.</summary>
            <returns>Your application should return 0 if it processes this message.</returns>
            <remarks>
            <para>This message can be useful if your application must add several items to a list box. Your application can call this message with *wParam* set to **FALSE**, add the items, and then call the message again with *wParam* set to **TRUE**. Finally, your application can call [**RedrawWindow**](/windows/win32/api/Winuser/nf-winuser-redrawwindow)(*hWnd*, **NULL**, **NULL**, RDW\_ERASE \| RDW\_FRAME \| RDW\_INVALIDATE \| RDW\_ALLCHILDREN) to cause the list box to be repainted. > [!NOTE] > You should use [**RedrawWindow**](/windows/win32/api/Winuser/nf-winuser-redrawwindow) with the specified flags, instead of [**InvalidateRect**](/windows/win32/api/Winuser/nf-winuser-invalidaterect), because the former is necessary for some controls that have nonclient area of their own, or have window styles that cause them to be given a nonclient area (such as **WS_THICKFRAME**, **WS_BORDER**, or **WS_EX_CLIENTEDGE**). If the control does not have a nonclient area, then **RedrawWindow** with these flags will do only as much invalidation as **InvalidateRect** would. Passing a **WM_SETREDRAW** message to the **DefWindowProc** function removes the **WS_VISIBLE** style from the window when *wParam* is set to **FALSE**. Although the window content remains visible on screen, the [**IsWindowVisible**](/windows/win32/api/winuser/nf-winuser-iswindowvisible) function returns **FALSE** when called on a window in this state. Passing a **WM_SETREDRAW** message to the **DefWindowProc** function adds the **WS_VISIBLE** style to the window, if not set, when *wParam* is set to **TRUE**. If your application sends the **WM_SETREDRAW** message with *wParam* set to **TRUE** to a hidden window, then the window becomes visible. **Windows 10 and later; Windows Server 2016 and later**. The system sets a property named *SysSetRedraw* on a window whose window procedure passes **WM_SETREDRAW** messages to **DefWindowProc**. You can use the [**GetProp**](/windows/win32/api/Winuser/nf-winuser-getpropa) function to get the property value when it's available. **GetProp** returns a non-zero value when redraw is disabled. **GetProp** will return zero when redraw is enabled, or when the window property doesn't exist.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/gdi/wm-setredraw#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_SETTEXT">
            <summary>Sets the text of a window.</summary>
            <returns>
            <para>Type: **LRESULT** The return value is **TRUE** if the text is set. It is **FALSE** (for an edit control), **LB\_ERRSPACE** (for a list box), or **CB\_ERRSPACE** (for a combo box) if insufficient space is available to set the text in the edit control. It is **CB\_ERR** if this message is sent to a combo box without an edit control.</para>
            </returns>
            <remarks>
            <para>The [**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowproca) function sets and displays the window text. For an edit control, the text is the contents of the edit control. For a combo box, the text is the contents of the edit-control portion of the combo box. For a button, the text is the button name. For other windows, the text is the window title. This message does not change the current selection in the list box of a combo box. An application should use the [**CB\_SELECTSTRING**](../controls/cb-selectstring.md) message to select the item in a list box that matches the text in the edit control.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/winmsg/wm-settext#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_GETTEXT">
            <summary>Copies the text that corresponds to a window into a buffer provided by the caller.</summary>
            <returns>
            <para>Type: **LRESULT** The return value is the number of characters copied, not including the terminating null character.</para>
            </returns>
            <remarks>
            <para>The [**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowproca) function copies the text associated with the window into the specified buffer and returns the number of characters copied. Note, for non-text static controls this gives you the text with which the control was originally created, that is, the ID number. However, it gives you the ID of the non-text static control as originally created. That is, if you subsequently used a **STM\_SETIMAGE** to change it the original ID would still be returned. For an edit control, the text to be copied is the content of the edit control. For a combo box, the text is the content of the edit control (or static-text) portion of the combo box. For a button, the text is the button name. For other windows, the text is the window title. To copy the text of an item in a list box, an application can use the [**LB\_GETTEXT**](../controls/lb-gettext.md) message. When the **WM\_GETTEXT** message is sent to a static control with the **SS\_ICON** style, a handle to the icon will be returned in the first four bytes of the buffer pointed to by *lParam*. This is true only if the [**WM\_SETTEXT**](wm-settext.md) message has been used to set the icon. **Rich Edit:** If the text to be copied exceeds 64K, use either the [**EM\_STREAMOUT**](../controls/em-streamout.md) or [**EM\_GETSELTEXT**](../controls/em-getseltext.md) message. Sending a **WM\_GETTEXT** message to a non-text static control, such as a static bitmap or static icon control, does not return a string value. Instead, it returns zero. In addition, in early versions of Windows, applications could send a **WM\_GETTEXT** message to a non-text static control to retrieve the control's ID. To retrieve a control's ID, applications can use [**GetWindowLong**](/windows/win32/api/winuser/nf-winuser-getwindowlonga) passing **GWL\_ID** as the index value or [**GetWindowLongPtr**](/windows/win32/api/winuser/nf-winuser-getwindowlongptra) using **GWLP\_ID**.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/winmsg/wm-gettext#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_GETTEXTLENGTH">
            <summary>Determines the length, in characters, of the text associated with a window.</summary>
            <returns>
            <para>Type: **LRESULT** The return value is the length of the text in characters, not including the terminating null character.</para>
            </returns>
            <remarks>
            <para>For an edit control, the text to be copied is the content of the edit control. For a combo box, the text is the content of the edit control (or static-text) portion of the combo box. For a button, the text is the button name. For other windows, the text is the window title. To determine the length of an item in a list box, an application can use the [**LB\_GETTEXTLEN**](../controls/lb-gettextlen.md) message. When the **WM\_GETTEXTLENGTH** message is sent, the [**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowproca) function returns the length, in characters, of the text. Under certain conditions, the **DefWindowProc** function returns a value that is larger than the actual length of the text. This occurs with certain mixtures of ANSI and Unicode, and is due to the system allowing for the possible existence of double-byte character set (DBCS) characters within the text. The return value, however, will always be at least as large as the actual length of the text; you can thus always use it to guide buffer allocation. This behavior can occur when an application uses both ANSI functions and common dialogs, which use Unicode. To obtain the exact length of the text, use the [**WM\_GETTEXT**](wm-gettext.md), [**LB\_GETTEXT**](../controls/lb-gettext.md), or [**CB\_GETLBTEXT**](../controls/cb-getlbtext.md) messages, or the [**GetWindowText**](/windows/win32/api/winuser/nf-winuser-getwindowtexta) function. Sending a **WM\_GETTEXTLENGTH** message to a non-text static control, such as a static bitmap or static icon controlc, does not return a string value. Instead, it returns zero.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/winmsg/wm-gettextlength#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_PAINT">
            <summary>The WM\_PAINT message is sent when the system or another application makes a request to paint a portion of an application's window.</summary>
            <returns>An application returns zero if it processes this message.</returns>
            <remarks>
            <para>The **WM\_PAINT** message is generated by the system and should not be sent by an application. To force a window to draw into a specific device context, use the [**WM\_PRINT**](wm-print.md) or [**WM\_PRINTCLIENT**](wm-printclient.md) message. Note that this requires the target window to support the **WM\_PRINTCLIENT** message. Most common controls support the **WM\_PRINTCLIENT** message. The [**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowproca)  function validates the update region. The function may also send the [**WM\_NCPAINT**](wm-ncpaint.md) message to the window procedure if the window frame must be painted and send the [**WM\_ERASEBKGND**](../winmsg/wm-erasebkgnd.md) message if the window background must be erased. The system sends this message when there are no other messages in the application's message queue. [**DispatchMessage**](/windows/win32/api/winuser/nf-winuser-dispatchmessage) determines where to send the message; [**GetMessage**](/windows/win32/api/winuser/nf-winuser-getmessage) determines which message to dispatch. **GetMessage** returns the **WM\_PAINT** message when there are no other messages in the application's message queue, and **DispatchMessage** sends the message to the appropriate window procedure. A window may receive internal paint messages as a result of calling [**RedrawWindow**](/windows/desktop/api/Winuser/nf-winuser-redrawwindow) with the RDW\_INTERNALPAINT flag set. In this case, the window may not have an update region. An application may call the [**GetUpdateRect**](/windows/desktop/api/Winuser/nf-winuser-getupdaterect) function to determine whether the window has an update region. If **GetUpdateRect** returns zero, the application need not call the [**BeginPaint**](/windows/desktop/api/Winuser/nf-winuser-beginpaint) and [**EndPaint**](/windows/desktop/api/Winuser/nf-winuser-endpaint) functions. An application must check for any necessary internal painting by looking at its internal data structures for each **WM\_PAINT** message, because a **WM\_PAINT** message may have been caused by both a non-NULL update region and a call to [**RedrawWindow**](/windows/desktop/api/Winuser/nf-winuser-redrawwindow) with the RDW\_INTERNALPAINT flag set. The system sends an internal **WM\_PAINT** message only once. After an internal **WM\_PAINT** message is returned from [**GetMessage**](/windows/win32/api/winuser/nf-winuser-getmessage) or [**PeekMessage**](/windows/win32/api/winuser/nf-winuser-peekmessagea) or is sent to a window by [**UpdateWindow**](/windows/desktop/api/Winuser/nf-winuser-updatewindow), the system does not post or send further **WM\_PAINT** messages until the window is invalidated or until [**RedrawWindow**](/windows/desktop/api/Winuser/nf-winuser-redrawwindow) is called again with the RDW\_INTERNALPAINT flag set. For some common controls, the default **WM\_PAINT** message processing checks the *wParam* parameter. If *wParam* is non-NULL, the control assumes that the value is an HDC and paints using that device context.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/gdi/wm-paint#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_CLOSE">
            <summary>Sent as a signal that a window or an application should terminate.</summary>
            <returns>
            <para>Type: **LRESULT** If an application processes this message, it should return zero.</para>
            </returns>
            <remarks>
            <para>An application can prompt the user for confirmation, prior to destroying a window, by processing the **WM\_CLOSE** message and calling the [**DestroyWindow**](/windows/win32/api/winuser/nf-winuser-destroywindow) function only if the user confirms the choice. By default, the [**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowproca) function calls the [**DestroyWindow**](/windows/win32/api/winuser/nf-winuser-destroywindow) function to destroy the window.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/winmsg/wm-close#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_QUERYENDSESSION">
            <summary>The WM\_QUERYENDSESSION message is sent when the user chooses to end the session or when an application calls one of the system shutdown functions.</summary>
            <returns>
            <para>Applications should respect the user's intentions and return **TRUE**. By default, the [**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowproca) function returns **TRUE** for this message. If shutting down would corrupt the system or media that is being burned, the application can return **FALSE**. However, it is good practice to respect the user's actions.</para>
            </returns>
            <remarks>
            <para>When an application returns **TRUE** for this message, it receives the [**WM\_ENDSESSION**](wm-endsession.md) message, regardless of how the other applications respond to the **WM\_QUERYENDSESSION** message. Each application should return **TRUE** or **FALSE** immediately upon receiving this message, and defer any cleanup operations until it receives the **WM\_ENDSESSION** message. Applications can display a user interface prompting the user for information at shutdown, however it is not recommended. After five seconds, the system displays information about the applications that are preventing shutdown and allows the user to terminate them. For example, Windows XP displays a dialog box, while Windows Vista displays a full screen with additional information about the applications blocking shutdown. If your application must block or postpone system shutdown, use the [**ShutdownBlockReasonCreate**](/windows/desktop/api/Winuser/nf-winuser-shutdownblockreasoncreate) function. For more information, see [Shutdown Changes for Windows Vista](shutdown-changes-for-windows-vista.md). Console applications can use the [**SetConsoleCtrlHandler**](/windows/console/setconsolectrlhandler) function to receive shutdown notification. Service applications can use the [**RegisterServiceCtrlHandlerEx**](/windows/win32/api/winsvc/nf-winsvc-registerservicectrlhandlerexa) function to receive shutdown notifications in a handler routine.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/Shutdown/wm-queryendsession#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_QUERYOPEN">
            <summary>Sent to an icon when the user requests that the window be restored to its previous size and position.</summary>
            <returns>
            <para>Type: **LRESULT** If the icon can be opened, an application that processes this message should return **TRUE**; otherwise, it should return **FALSE** to prevent the icon from being opened.</para>
            </returns>
            <remarks>
            <para>By default, the [**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowproca) function returns **TRUE**. While processing this message, the application should not perform any action that would cause an activation or focus change (for example, creating a dialog box).</para>
            <para><see href="https://learn.microsoft.com/windows/win32/winmsg/wm-queryopen#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_ENDSESSION">
            <summary>The WM\_ENDSESSION message is sent to an application after the system processes the results of the WM\_QUERYENDSESSION message. The WM\_ENDSESSION message informs the application whether the session is ending.</summary>
            <returns>If an application processes this message, it should return zero.</returns>
            <remarks>
            <para>Applications that have unsaved data could save the data to a temporary location and restore it the next time the application starts. It is recommended that applications save their data and state frequently; for example, automatically save data between save operations initiated by the user to reduce the amount of data to be saved at shutdown. The application need not call the [**DestroyWindow**](/windows/win32/api/winuser/nf-winuser-destroywindow) or [**PostQuitMessage**](/windows/win32/api/winuser/nf-winuser-postquitmessage) function when the session is ending.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/Shutdown/wm-endsession#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_QUIT">
            <summary>Indicates a request to terminate an application, and is generated when the application calls the PostQuitMessage function. This message causes the GetMessage function to return zero.</summary>
            <returns>
            <para>Type: **LRESULT** This message does not have a return value because it causes the message loop to terminate before the message is sent to the application's window procedure.</para>
            </returns>
            <remarks>
            <para>The **WM\_QUIT** message is not associated with a window and therefore will never be received through a window's window procedure. It is retrieved only by the [**GetMessage**](/windows/win32/api/winuser/nf-winuser-getmessage) or [**PeekMessage**](/windows/win32/api/winuser/nf-winuser-peekmessagea) functions. Do not post the **WM\_QUIT** message using the [**PostMessage**](/windows/win32/api/winuser/nf-winuser-postmessagea) function; use [**PostQuitMessage**](/windows/win32/api/winuser/nf-winuser-postquitmessage).</para>
            <para><see href="https://learn.microsoft.com/windows/win32/winmsg/wm-quit#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_ERASEBKGND">
            <summary>Sent when the window background must be erased (for example, when a window is resized). The message is sent to prepare an invalidated portion of a window for painting.</summary>
            <returns>
            <para>Type: **LRESULT** An application should return nonzero if it erases the background; otherwise, it should return zero.</para>
            </returns>
            <remarks>
            <para>The [**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowproca) function erases the background by using the class background brush specified by the **hbrBackground** member of the [**WNDCLASS**](/windows/win32/api/winuser/ns-winuser-wndclassa) structure. If **hbrBackground** is **NULL**, the application should process the **WM\_ERASEBKGND** message and erase the background. An application should return nonzero in response to **WM\_ERASEBKGND** if it processes the message and erases the background; this indicates that no further erasing is required. If the application returns zero, the window will remain marked for erasing. (Typically, this indicates that the **fErase** member of the [**PAINTSTRUCT**](/windows/win32/api/winuser/ns-winuser-paintstruct) structure will be **TRUE**.)</para>
            <para><see href="https://learn.microsoft.com/windows/win32/winmsg/wm-erasebkgnd#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_SYSCOLORCHANGE">
            <summary>The WM\_SYSCOLORCHANGE message is sent to all top-level windows when a change is made to a system color setting.</summary>
            <remarks>
            <para>The system sends a [**WM\_PAINT**](wm-paint.md) message to any window that is affected by a system color change. Applications that have brushes using the existing system colors should delete those brushes and re-create them using the new system colors. Top level windows that use common controls must forward the **WM\_SYSCOLORCHANGE** message to the controls; otherwise, the controls will not be notified of the color change. This ensures that the colors used by your common controls are consistent with those used by other user interface objects. For example, a toolbar control uses the "3D Objects" color to draw its buttons. If the user changes the 3D Objects color but the **WM\_SYSCOLORCHANGE** message is not forwarded to the toolbar, the toolbar buttons will remain in their original color while the color of other buttons in the system changes.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/gdi/wm-syscolorchange#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_SHOWWINDOW">
            <summary>Sent to a window when the window is about to be hidden or shown.</summary>
            <returns>
            <para>Type: **LRESULT** If an application processes this message, it should return zero.</para>
            </returns>
            <remarks>
            <para>The [**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowproca) function hides or shows the window, as specified by the message. If a window has the [**WS\_VISIBLE**](window-styles.md) style when it is created, the window receives this message after it is created, but before it is displayed. A window also receives this message when its visibility state is changed by the [**ShowWindow**](/windows/win32/api/winuser/nf-winuser-showwindow) or [**ShowOwnedPopups**](/windows/win32/api/winuser/nf-winuser-showownedpopups) function. The **WM\_SHOWWINDOW** message is not sent under the following circumstances: -   When a top-level, overlapped window is created with the [**WS\_MAXIMIZE**](window-styles.md) or **WS\_MINIMIZE** style. -   When the **SW\_SHOWNORMAL** flag is specified in the call to the [**ShowWindow**](/windows/win32/api/winuser/nf-winuser-showwindow) function.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/winmsg/wm-showwindow#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_WININICHANGE">
            <summary>An application sends the WM\_WININICHANGE message to all top-level windows after making a change to the WIN.INI file. The SystemParametersInfo function sends this message after an application uses the function to change a setting in WIN.INI.</summary>
            <returns>
            <para>Type: **LRESULT** If you process this message, return zero.</para>
            </returns>
            <remarks>
            <para>To send the **WM\_WININICHANGE** message to all top-level windows, use the [**SendMessage**](/windows/win32/api/winuser/nf-winuser-sendmessage) function with the *hWnd* parameter set to **HWND\_BROADCAST**. Calls to functions that change WIN.INI may be mapped to the registry instead. This mapping occurs when WIN.INI and the section being changed are specified in the registry under the following key: **HKEY\_LOCAL\_MACHINE\\Software\\Microsoft\\Windows NT\\CurrentVersion\\IniFileMapping** The change in the storage location has no effect on the behavior of this message.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/winmsg/wm-wininichange#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_SETTINGCHANGE">
            <summary>A message that is sent to all top-level windows when the SystemParametersInfo function changes a system-wide setting or when policy settings have changed.</summary>
            <returns>
            <para>Type: **LRESULT** If you process this message, return zero.</para>
            </returns>
            <remarks>The *lParam* parameter indicates which system metric has changed, for example, "ConvertibleSlateMode" if the CONVERTIBLESLATEMODE indicator was toggled or "SystemDockMode" if the DOCKED indicator was toggled.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_DEVMODECHANGE">
            <summary>The WM\_DEVMODECHANGE message is sent to all top-level windows whenever the user changes device-mode settings.</summary>
            <returns>An application should return zero if it processes this message.</returns>
            <remarks>This message cannot be sent directly to a window. To send the **WM\_DEVMODECHANGE** message to all top-level windows, use the [**SendMessageTimeout**](/windows/win32/api/winuser/nf-winuser-sendmessagetimeouta) function with the *hWnd* parameter set to HWND\_BROADCAST.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_ACTIVATEAPP">
            <summary>Sent when a window belonging to a different application than the active window is about to be activated. The message is sent to the application whose window is being activated and to the application whose window is being deactivated.</summary>
            <returns>
            <para>Type: **LRESULT** If an application processes this message, it should return zero.</para>
            </returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/winmsg/wm-activateapp">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_FONTCHANGE">
            <summary>An application sends the WM\_FONTCHANGE message to all top-level windows in the system after changing the pool of font resources.</summary>
            <remarks>
            <para>An application that adds or removes fonts from the system (for example, by using the [**AddFontResource**](/windows/desktop/api/Wingdi/nf-wingdi-addfontresourcea) or [**RemoveFontResource**](/windows/desktop/api/Wingdi/nf-wingdi-removefontresourcea) function) should send this message to all top-level windows. To send the **WM\_FONTCHANGE** message to all top-level windows, an application can call the **SendMessage** function with the *hwnd* parameter set to HWND\_BROADCAST.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/gdi/wm-fontchange#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_TIMECHANGE">
            <summary>A message that is sent whenever there is a change in the system time.</summary>
            <returns>An application should return zero if it processes this message.</returns>
            <remarks>An application should not broadcast this message, because the system will broadcast this message when the application changes the system time.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_CANCELMODE">
            <summary>Sent to cancel certain modes, such as mouse capture.</summary>
            <returns>
            <para>Type: **LRESULT** If an application processes this message, it should return zero.</para>
            </returns>
            <remarks>When the **WM\_CANCELMODE** message is sent, the [**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowproca) function cancels internal processing of standard scroll bar input, cancels internal menu processing, and releases the mouse capture.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_SETCURSOR">
            <summary>Sent to a window if the mouse causes the cursor to move within a window and mouse input is not captured.</summary>
            <returns>If an application processes this message, it should return **TRUE** to halt further processing or **FALSE** to continue.</returns>
            <remarks>The [**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowprocw) function passes the **WM\_SETCURSOR** message to a parent window before processing. If the parent window returns **TRUE**, further processing is halted. Passing the message to a window's parent window gives the parent window control over the cursor's setting in a child window. The **DefWindowProc** function also uses this message to set the cursor to an arrow if it is not in the client area, or to the registered class cursor if it is in the client area. If the low-order word of the *lParam* parameter is **HTERROR** and the high-order word of *lParam* specifies that one of the mouse buttons is pressed, **DefWindowProc** calls the [**MessageBeep**](/windows/desktop/api/winuser/nf-winuser-messagebeep) function.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_MOUSEACTIVATE">
            <summary>Sent when the cursor is in an inactive window and the user presses a mouse button. The parent window receives this message only if the child window passes it to the DefWindowProc function.</summary>
            <returns>
            <para>The return value specifies whether the window should be activated and whether the identifier of the mouse message should be discarded. It must be one of the following values.</para>
            <para>| Return code/value                                                                                                                                          | Description                                                                      | |------------------------------------------------------------------------------------------------------------------------------------------------------------|----------------------------------------------------------------------------------| | <dl> <dt>**MA\_ACTIVATE**</dt> <dt>1</dt> </dl>         | Activates the window, and does not discard the mouse message.<br/>         | | <dl> <dt>**MA\_ACTIVATEANDEAT**</dt> <dt>2</dt> </dl>   | Activates the window, and discards the mouse message.<br/>                 | | <dl> <dt>**MA\_NOACTIVATE**</dt> <dt>3</dt> </dl>       | Does not activate the window, and does not discard the mouse message.<br/> | | <dl> <dt>**MA\_NOACTIVATEANDEAT**</dt> <dt>4</dt> </dl> | Does not activate the window, but discards the mouse message.<br/>         |</para>
            </returns>
            <remarks>The [**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowproca) function passes the message to a child window's parent window before any processing occurs. The parent window determines whether to activate the child window. If it activates the child window, the parent window should return **MA\_NOACTIVATE** or **MA\_NOACTIVATEANDEAT** to prevent the system from processing the message further.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_CHILDACTIVATE">
            <summary>Sent to a child window when the user clicks the window's title bar or when the window is activated, moved, or sized.</summary>
            <returns>
            <para>Type: **LRESULT** If an application processes this message, it should return zero.</para>
            </returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/winmsg/wm-childactivate">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_QUEUESYNC">
            <summary>Sent by a computer-based training (CBT) application to separate user-input messages from other messages sent through the WH\_JOURNALPLAYBACK procedure.</summary>
            <returns>
            <para>Type: **void** A CBT application should return zero if it processes this message.</para>
            </returns>
            <remarks>
            <para>Whenever a CBT application uses the [**WH\_JOURNALPLAYBACK**](about-hooks.md) procedure, the first and last messages are **WM\_QUEUESYNC**. This allows the CBT application to intercept and examine user-initiated messages without doing so for events that it sends. If an application specifies a **NULL** window handle, the message is posted to the message queue of the active window.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/winmsg/wm-queuesync#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_GETMINMAXINFO">
            <summary>Sent to a window when the size or position of the window is about to change. An application can use this message to override the window's default maximized size and position, or its default minimum or maximum tracking size.</summary>
            <returns>
            <para>Type: **LRESULT** If an application processes this message, it should return zero.</para>
            </returns>
            <remarks>The maximum tracking size is the largest window size that can be produced by using the borders to size the window. The minimum tracking size is the smallest window size that can be produced by using the borders to size the window.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_NEXTDLGCTL">
            <summary>Sent to a dialog box procedure to set the keyboard focus to a different control in the dialog box.</summary>
            <returns>An application should return zero if it processes this message.</returns>
            <remarks>
            <para>This message performs additional dialog box management operations beyond those performed by the [**SetFocus**](/windows/desktop/api/winuser/nf-winuser-setfocus) function **WM\_NEXTDLGCTL** updates the default pushbutton border, sets the default control identifier, and automatically selects the text of an edit control (if the target window is an edit control). Do not use the [**SendMessage**](/windows/desktop/api/winuser/nf-winuser-sendmessage) function to send a **WM\_NEXTDLGCTL** message if your application will concurrently process other messages that set the focus. Use the [**PostMessage**](/windows/desktop/api/winuser/nf-winuser-postmessagea) function instead.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/dlgbox/wm-nextdlgctl#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_SPOOLERSTATUS">
            <summary>The WM\_SPOOLERSTATUS message is sent from Print Manager whenever a job is added to or removed from the Print Manager queue.</summary>
            <returns>An application should return zero if it processes this message.</returns>
            <remarks>
            <para>This message is for informational purposes only. This message is advisory and does not have guaranteed delivery semantics. Applications should not assume that they will receive a WM\_SPOOLERSTATUS message for every change in spooler status. The WM\_SPOOLERSTATUS message is not supported after Windows XP. To be notified of changes to the print queue status, you can use [**FindFirstPrinterChangeNotification**](findfirstprinterchangenotification.md) and [**FindNextPrinterChangeNotification**](findnextprinterchangenotification.md).</para>
            <para><see href="https://learn.microsoft.com/windows/win32/printdocs/wm-spoolerstatus#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_DRAWITEM">
            <summary>Sent to the parent window of an owner-drawn button, combo box, list box, or menu when a visual aspect of the button, combo box, list box, or menu has changed.</summary>
            <returns>If an application processes this message, it should return **TRUE**.</returns>
            <remarks>
            <para>By default, the [**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowproca) function draws the focus rectangle for an owner-drawn list box item. The *itemAction* member of the [**DRAWITEMSTRUCT**](/windows/win32/api/winuser/ns-winuser-drawitemstruct) structure specifies the drawing operation that an application should perform. Before returning from processing this message, an application should ensure that the device context identified by the *hDC* member of the [**DRAWITEMSTRUCT**](/windows/win32/api/winuser/ns-winuser-drawitemstruct) structure is in the default state.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/Controls/wm-drawitem#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_MEASUREITEM">
            <summary>Sent to the owner window of a combo box, list box, list-view control, or menu item when the control or menu is created.</summary>
            <returns>If an application processes this message, it should return **TRUE**.</returns>
            <remarks>
            <para>When the owner window receives the **WM\_MEASUREITEM** message, the owner fills in the [**MEASUREITEMSTRUCT**](/windows/win32/api/winuser/ns-winuser-measureitemstruct) structure pointed to by the *lParam* parameter of the message and returns; this informs the system of the dimensions of the control. If a list box or combo box is created with the [**LBS\_OWNERDRAWVARIABLE**](list-box-styles.md) or [**CBS\_OWNERDRAWVARIABLE**](combo-box-styles.md) style, this message is sent to the owner for each item in the control; otherwise, this message is sent once. The system sends the **WM\_MEASUREITEM** message to the owner window of combo boxes and list boxes created with the OWNERDRAWFIXED style before sending the [**WM\_INITDIALOG**](/windows/desktop/dlgbox/wm-initdialog) message. As a result, when the owner receives this message, the system has not yet determined the height and width of the font used in the control; function calls and calculations requiring these values should occur in the main function of the application or library.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/Controls/wm-measureitem#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_DELETEITEM">
            <summary>Sent to the owner of a list box or combo box when the list box or combo box is destroyed or when items are removed by the LB\_DELETESTRING, LB\_RESETCONTENT, CB\_DELETESTRING, or CB\_RESETCONTENT message.</summary>
            <returns>An application should return **TRUE** if it processes this message.</returns>
            <remarks>
            <para>Microsoft Windows NT and later: Windows sends a **WM\_DELETEITEM** message only for items deleted from an owner-drawn list box (with the [**LBS\_OWNERDRAWFIXED**](list-box-styles.md) or [**LBS\_OWNERDRAWVARIABLE**](list-box-styles.md) style) or owner-drawn combo box (with the [**CBS\_OWNERDRAWFIXED**](combo-box-styles.md) or [**CBS\_OWNERDRAWVARIABLE**](combo-box-styles.md) style). Windows 95: Windows sends the **WM\_DELETEITEM** message for any deleted list box or combo box item with nonzero item data.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/Controls/wm-deleteitem#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_VKEYTOITEM">
            <summary>Sent by a list box with the LBS\_WANTKEYBOARDINPUT style to its owner in response to a WM\_KEYDOWN message.</summary>
            <returns>The return value specifies the action that the application performed in response to the message. A return value of -2 indicates that the application handled all aspects of selecting the item and requires no further action by the list box. (See Remarks.) A return value of -1 indicates that the list box should perform the default action in response to the keystroke. A return value of 0 or greater specifies the index of an item in the list box and indicates that the list box should perform the default action for the keystroke on the specified item.</returns>
            <remarks>
            <para>A return value of -2 is valid only for keys that are not translated into characters by the list box control. If the [**WM\_KEYDOWN**](/windows/desktop/inputdev/wm-keydown) message translates to a [**WM\_CHAR**](/windows/desktop/inputdev/wm-char) message and the application processes the **WM\_VKEYTOITEM** message generated as a result of the key press, the list box ignores the return value and does the default processing for that character). **WM\_KEYDOWN** messages generated by keys such as VK\_UP, VK\_DOWN, VK\_NEXT, and VK\_PREVIOUS are not translated to **WM\_CHAR** messages. In such cases, trapping the **WM\_VKEYTOITEM** message and returning -2 prevents the list box from doing the default processing for that key. To trap keys that generate a char message and do special processing, the application must subclass the list box, trap both the [**WM\_KEYDOWN**](/windows/desktop/inputdev/wm-keydown) and [**WM\_CHAR**](/windows/desktop/inputdev/wm-char) messages, and process the messages appropriately in the subclass procedure. The preceding remarks apply to regular list boxes that are created with the [**LBS\_WANTKEYBOARDINPUT**](list-box-styles.md) style. If the list box is owner-drawn, the application must process the [**WM\_CHARTOITEM**](wm-chartoitem.md) message. The [**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowproca) function returns -1. If a dialog box procedure handles this message, it should cast the desired return value to a **BOOL** and return the value directly. The DWL\_MSGRESULT value set by the [**SetWindowLong**](/windows/desktop/api/winuser/nf-winuser-setwindowlonga) function is ignored.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/Controls/wm-vkeytoitem#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_CHARTOITEM">
            <summary>Sent by a list box with the LBS\_WANTKEYBOARDINPUT style to its owner in response to a WM\_CHAR message.</summary>
            <returns>The return value specifies the action that the application performed in response to the message. A return value of -1 or -2 indicates that the application handled all aspects of selecting the item and requires no further action by the list box. A return value of 0 or greater specifies the zero-based index of an item in the list box and indicates that the list box should perform the default action for the keystroke on the specified item.</returns>
            <remarks>
            <para>The [**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowproca) function returns -1. Only owner-drawn list boxes that do not have the [**LBS\_HASSTRINGS**](list-box-styles.md) style can receive this message. If a dialog box procedure handles this message, it should cast the desired return value to a **BOOL** and return the value directly. The *DWL\_MSGRESULT* value set by the [**SetWindowLong**](/windows/desktop/api/winuser/nf-winuser-setwindowlonga) function is ignored.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/Controls/wm-chartoitem#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_SETFONT">
            <summary>Sets the font that a control is to use when drawing text.</summary>
            <returns>
            <para>Type: **LRESULT** This message does not return a value.</para>
            </returns>
            <remarks>
            <para>The **WM\_SETFONT** message applies to all controls, not just those in dialog boxes. The best time for the owner of a dialog box control to set the font of the control is when it receives the [**WM\_INITDIALOG**](../dlgbox/wm-initdialog.md) message. The application should call the [**DeleteObject**](/windows/win32/api/wingdi/nf-wingdi-deleteobject) function to delete the font when it is no longer needed; for example, after it destroys the control. The size of the control does not change as a result of receiving this message. To avoid clipping text that does not fit within the boundaries of the control, the application should correct the size of the control window before it sets the font. When a dialog box uses the [DS\_SETFONT](../dlgbox/about-dialog-boxes.md) style to set the text in its controls, the system sends the **WM\_SETFONT** message to the dialog box procedure before it creates the controls. An application can create a dialog box that contains the DS\_SETFONT style by calling any of the following functions: -   [**CreateDialogIndirect**](/windows/win32/api/winuser/nf-winuser-createdialogindirecta) -   [**CreateDialogIndirectParam**](/windows/win32/api/winuser/nf-winuser-createdialogindirectparama) -   [**DialogBoxIndirect**](/windows/win32/api/winuser/nf-winuser-dialogboxindirecta) -   [**DialogBoxIndirectParam**](/windows/win32/api/winuser/nf-winuser-dialogboxindirectparama)</para>
            <para><see href="https://learn.microsoft.com/windows/win32/winmsg/wm-setfont#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_GETFONT">
            <summary>Retrieves the font with which the control is currently drawing its text.</summary>
            <returns>
            <para>Type: **HFONT** The return value is a handle to the font used by the control, or **NULL** if the control is using the system font.</para>
            </returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/winmsg/wm-getfont">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_SETHOTKEY">
            <summary>Sent to a window to associate a hot key with the window. When the user presses the hot key, the system activates the window.</summary>
            <returns>
            <para>The return value is one of the following.</para>
            <para>| Return value                                                                  | Description                                                                             | |-------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------| | <dl> <dt>-1</dt> </dl> | The function is unsuccessful; the hot key is invalid.<br/>                        | | <dl> <dt>0</dt> </dl>  | The function is unsuccessful; the window is invalid.<br/>                         | | <dl> <dt>1</dt> </dl>  | The function is successful, and no other window has the same hot key.<br/>        | | <dl> <dt>2</dt> </dl>  | The function is successful, but another window already has the same hot key.<br/> |</para>
            </returns>
            <remarks>
            <para>A hot key cannot be associated with a child window. **VK\_ESCAPE**, **VK\_SPACE**, and **VK\_TAB** are invalid hot keys. When the user presses the hot key, the system generates a [**WM\_SYSCOMMAND**](/windows/desktop/menurc/wm-syscommand) message with *wParam* equal to **SC\_HOTKEY** and *lParam* equal to the window's handle. If this message is passed on to [**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowproca), the system will bring the window's last active popup (if it exists) or the window itself (if there is no popup window) to the foreground. A window can only have one hot key. If the window already has a hot key associated with it, the new hot key replaces the old one. If more than one window has the same hot key, the window that is activated by the hot key is random. These hot keys are unrelated to the hot keys set by [**RegisterHotKey**](/windows/win32/api/winuser/nf-winuser-registerhotkey).</para>
            <para><see href="https://learn.microsoft.com/windows/win32/inputdev/wm-sethotkey#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_GETHOTKEY">
            <summary>Sent to determine the hot key associated with a window.</summary>
            <returns>
            <para>The return value is the virtual-key code and modifiers for the hot key, or **NULL** if no hot key is associated with the window. The virtual-key code is in the low byte of the return value and the modifiers are in the high byte. The modifiers can be a combination of the following flags from CommCtrl.h.</para>
            <para>| Return code/value                                                                                                                                         | Description             | |-----------------------------------------------------------------------------------------------------------------------------------------------------------|-------------------------| | <dl> <dt>**HOTKEYF\_ALT**</dt> <dt>0x04</dt> </dl>     | ALT key<br/>      | | <dl> <dt>**HOTKEYF\_CONTROL**</dt> <dt>0x02</dt> </dl> | CTRL key<br/>     | | <dl> <dt>**HOTKEYF\_EXT**</dt> <dt>0x08</dt> </dl>     | Extended key<br/> | | <dl> <dt>**HOTKEYF\_SHIFT**</dt> <dt>0x01</dt> </dl>   | SHIFT key<br/>    |</para>
            </returns>
            <remarks>These hot keys are unrelated to the hot keys set by the [**RegisterHotKey**](/windows/win32/api/winuser/nf-winuser-registerhotkey) function.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_QUERYDRAGICON">
            <summary>Sent to a minimized (iconic) window.</summary>
            <returns>
            <para>Type: **LRESULT** An application should return a handle to a cursor or icon that the system is to display while the user drags the icon. The cursor or icon must be compatible with the display driver's resolution. If the application returns **NULL**, the system displays the default cursor.</para>
            </returns>
            <remarks>
            <para>When the user drags the icon of a window without a class icon, the system replaces the icon with a default cursor. If the application requires a different cursor to be displayed during dragging, it must return a handle to the cursor or icon compatible with the display driver's resolution. If an application returns a handle to a color cursor or icon, the system converts the cursor or icon to black and white. The application can call the [**LoadCursor**](/windows/win32/api/winuser/nf-winuser-loadcursora) or [**LoadIcon**](/windows/win32/api/winuser/nf-winuser-loadicona) function to load a cursor or icon from the resources in its executable (.exe) file and to retrieve this handle. If a dialog box procedure handles this message, it should cast the desired return value to a **BOOL** and return the value directly. The **DWL\_MSGRESULT** value set by the [**SetWindowLong**](/windows/win32/api/winuser/nf-winuser-setwindowlonga) function is ignored.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/winmsg/wm-querydragicon#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_COMPAREITEM">
            <summary>Sent to determine the relative position of a new item in the sorted list of an owner-drawn combo box or list box.</summary>
            <returns>
            <para>The return value indicates the relative position of the two items. It may be any of the values shown in the following table.</para>
            <para>| Return code                                                                          | Description                                                  | |--------------------------------------------------------------------------------------|--------------------------------------------------------------| | <dl> <dt>**Value**</dt> </dl> | Meaning<br/>                                           | | <dl> <dt>**-1**</dt> </dl>    | Item 1 precedes item 2 in the sorted order.<br/>       | | <dl> <dt>**0**</dt> </dl>     | Items 1 and 2 are equivalent in the sorted order.<br/> | | <dl> <dt>**1**</dt> </dl>     | Item 1 follows item 2 in the sorted order.<br/>        |</para>
            </returns>
            <remarks>
            <para>When the owner of an owner-drawn combo box or list box receives this message, the owner returns a value indicating which of the items specified by the [**COMPAREITEMSTRUCT**](/windows/win32/api/winuser/ns-winuser-compareitemstruct) structure will appear before the other. Typically, the system sends this message several times until it determines the exact position for the new item. If a dialog box procedure handles this message, it should cast the desired return value to a **BOOL** and return the value directly. The DWL\_MSGRESULT value set by the [**SetWindowLong**](/windows/desktop/api/winuser/nf-winuser-setwindowlonga) function is ignored.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/Controls/wm-compareitem#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_GETOBJECT">
            <summary>Sent by both Microsoft Active Accessibility and Microsoft UI Automation to obtain information about an accessible object contained in a server application.</summary>
            <returns>
            <para>If the window or control does not need to respond to this message, it should pass the message to the [**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowproca) function; otherwise, the window or control should return a value that corresponds to the request specified by *dwObjId*: -   If the window or control implements UI Automation, the window or control should return the value obtained by a call to the [**UiaReturnRawElementProvider**](/windows/desktop/api/UIAutomationCoreApi/nf-uiautomationcoreapi-uiareturnrawelementprovider) function. -   If *dwObjId* is [**OBJID\_NATIVEOM**](object-identifiers.md) and the window exposes a native Object Model, the windows should return the value obtained by a call to the [**LresultFromObject**](/windows/desktop/api/Oleacc/nf-oleacc-lresultfromobject) function. -   If *dwObjId* is [**OBJID\_CLIENT**](object-identifiers.md) and the window implements [**IAccessible**](/windows/desktop/api/oleacc/nn-oleacc-iaccessible), the window should return the value obtained by a call to the [**LresultFromObject**](/windows/desktop/api/Oleacc/nf-oleacc-lresultfromobject) function.</para>
            </returns>
            <remarks>
            <para>When a client calls [**AccessibleObjectFromWindow**](/windows/desktop/api/Oleacc/nf-oleacc-accessibleobjectfromwindow) or any of the other **AccessibleObjectFrom***X* functions that retrieve an interface to an object, Microsoft Active Accessibility sends the **WM\_GETOBJECT** message to the appropriate window procedure within the appropriate server application. While processing **WM\_GETOBJECT**, server applications call [**LresultFromObject**](/windows/desktop/api/Oleacc/nf-oleacc-lresultfromobject) and use the return value of this function as the return value for the message. Microsoft Active Accessibility, in conjunction with the COM library, performs the appropriate marshaling and passes the interface pointer from the server back to the client. Servers do not respond to **WM\_GETOBJECT** before the object is fully initialized or after it begins to close down. When an application creates a new window, the system sends [**EVENT\_OBJECT\_CREATE**](event-constants.md) to notify clients before it sends the [WM\_CREATE](../winmsg/wm-create.md) message to the application's window procedure. Because many applications use WM\_CREATE to start their initialization process, servers do not respond to the **WM\_GETOBJECT** message until finished processing the **WM\_CREATE** message. A server uses **WM\_GETOBJECT** to perform the following tasks: -   [Create New Accessible Objects](create-new-accessible-objects.md) -   [Reuse Existing Pointers to Objects](reuse-existing-pointers-to-objects.md) -   [Create New Interfaces to the Same Object](create-new-interfaces-to-the-same-object.md) For clients, this means that they might receive distinct interface pointers for the same user interface element, depending on the server's action. To determine if two interface pointers point to the same user interface element, clients compare [**IAccessible**](/windows/desktop/api/oleacc/nn-oleacc-iaccessible) properties of the object. Comparing pointers does not work.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/WinAuto/wm-getobject#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_COMPACTING">
            <summary>Sent to all top-level windows when the system detects more than 12.5 percent of system time over a 30- to 60-second interval is being spent compacting memory. This indicates that system memory is low.</summary>
            <returns>
            <para>Type: **LRESULT** If an application processes this message, it should return zero.</para>
            </returns>
            <remarks>When an application receives this message, it should free as much memory as possible, taking into account the current level of activity of the application and the total number of applications running on the system.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_WINDOWPOSCHANGING">
            <summary>Sent to a window whose size, position, or place in the Z order is about to change as a result of a call to the SetWindowPos function or another window-management function.</summary>
            <returns>
            <para>Type: **LRESULT** If an application processes this message, it should return zero.</para>
            </returns>
            <remarks>
            <para>For a window with the [**WS\_OVERLAPPED**](window-styles.md) or **WS\_THICKFRAME** style, the [**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowproca) function sends the [**WM\_GETMINMAXINFO**](wm-getminmaxinfo.md) message to the window. This is done to validate the new size and position of the window and to enforce the [CS\_BYTEALIGNCLIENT](about-window-classes.md) and CS\_BYTEALIGNWINDOW client styles. By not passing the **WM\_WINDOWPOSCHANGING** message to the **DefWindowProc** function, an application can override these defaults. While this message is being processed, modifying any of the values in [**WINDOWPOS**](/windows/win32/api/winuser/ns-winuser-windowpos) affects the window's new size, position, or place in the Z order. An application can prevent changes to the window by setting or clearing the appropriate bits in the **flags** member of **WINDOWPOS**.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/winmsg/wm-windowposchanging#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_WINDOWPOSCHANGED">
            <summary>Sent to a window whose size, position, or place in the Z order has changed as a result of a call to the SetWindowPos function or another window-management function.</summary>
            <returns>
            <para>Type: **LRESULT** If an application processes this message, it should return zero.</para>
            </returns>
            <remarks>By default, the [**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowproca) function sends the [**WM\_SIZE**](wm-size.md) and [**WM\_MOVE**](wm-move.md) messages to the window. The **WM\_SIZE** and **WM\_MOVE** messages are not sent if an application handles the **WM\_WINDOWPOSCHANGED** message without calling **DefWindowProc**. It is more efficient to perform any move or size change processing during the **WM\_WINDOWPOSCHANGED** message without calling **DefWindowProc**.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_POWER">
            <summary>Notifies applications that the system, typically a battery-powered personal computer, is about to enter a suspended mode.</summary>
            <returns>The value an application returns depends on the value of the *wParam* parameter. If *wParam* is **PWR\_SUSPENDREQUEST**, the return value is **PWR\_FAIL** to prevent the system from entering the suspended state; otherwise, it is **PWR\_OK**. If *wParam* is **PWR\_SUSPENDRESUME** or **PWR\_CRITICALRESUME**, the return value is zero.</returns>
            <remarks>
            <para>This message is broadcast only to an application that is running on a system that conforms to the Advanced Power Management (APM) basic input/output system (BIOS) specification. The message is broadcast by the power-management driver to each window returned by the **EnumWindows** function. The suspended mode is the state in which the greatest amount of power savings occurs, but all operational data and parameters are preserved. Random-access memory (RAM) contents are preserved, but many devices are likely to be turned off.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/Power/wm-power#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_COPYDATA">
            <summary>An application sends the WM\_COPYDATA message to pass data to another application.</summary>
            <returns>If the receiving application processes this message, it should return **TRUE**; otherwise, it should return **FALSE**.</returns>
            <remarks>
            <para>The data being passed must not contain pointers or other references to objects not accessible to the application receiving the data. While this message is being sent, the referenced data must not be changed by another thread of the sending process. The receiving application should consider the data read-only. The *lParam* parameter is valid only during the processing of the message. The receiving application should not free the memory referenced by *lParam*. If the receiving application must access the data after [**SendMessage**](/windows/desktop/api/winuser/nf-winuser-sendmessage) returns, it must copy the data into a local buffer.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/dataxchg/wm-copydata#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_CANCELJOURNAL">
            <summary>Posted to an application when a user cancels the application's journaling activities. The message is posted with a NULL window handle.</summary>
            <returns>
            <para>Type: **void** This message does not return a value. It is meant to be processed from within an application's main loop or a [**GetMessage**](/windows/win32/api/winuser/nf-winuser-getmessage) hook procedure, not from a window procedure.</para>
            </returns>
            <remarks>
            <para>Journal record and playback modes are modes imposed on the system that let an application sequentially record or play back user input. The system enters these modes when an application installs a [*JournalRecordProc*](/previous-versions/windows/desktop/legacy/ms644983(v=vs.85)) or [*JournalPlaybackProc*](/previous-versions/windows/desktop/legacy/ms644982(v=vs.85)) hook procedure. When the system is in either of these journaling modes, applications must take turns reading input from the input queue. If any one application stops reading input while the system is in a journaling mode, other applications are forced to wait. To ensure a robust system, one that cannot be made unresponsive by any one application, the system automatically cancels any journaling activities when a user presses CTRL+ESC or CTRL+ALT+DEL. The system then unhooks any journaling hook procedures, and posts a **WM\_CANCELJOURNAL** message, with a **NULL** window handle, to the application that set the journaling hook. The **WM\_CANCELJOURNAL** message has a **NULL** window handle, therefore it cannot be dispatched to a window procedure. There are two ways for an application to see a **WM\_CANCELJOURNAL** message: If the application is running in its own main loop, it must catch the message between its call to [**GetMessage**](/windows/win32/api/winuser/nf-winuser-getmessage) or [**PeekMessage**](/windows/win32/api/winuser/nf-winuser-peekmessagea) and its call to [**DispatchMessage**](/windows/win32/api/winuser/nf-winuser-dispatchmessage). If the application is not running in its own main loop, it must set a [*GetMsgProc*](/previous-versions/windows/desktop/legacy/ms644981(v=vs.85)) hook procedure (through a call to [**SetWindowsHookEx**](/windows/win32/api/winuser/nf-winuser-setwindowshookexa) specifying the **WH\_GETMESSAGE** hook type) that watches for the message. When an application sees a **WM\_CANCELJOURNAL** message, it can assume two things: the user has intentionally canceled the journal record or playback mode, and the system has already unhooked any journal record or playback hook procedures. Note that the key combinations mentioned above (CTRL+ESC or CTRL+ALT+DEL) cause the system to cancel journaling. If any one application is made unresponsive, they give the user a means of recovery. The [**VK\_CANCEL**](../inputdev/virtual-key-codes.md) virtual key code (usually implemented as the CTRL+BREAK key combination) is what an application that is in journal record mode should watch for as a signal that the user wishes to cancel the journaling activity. The difference is that watching for **VK\_CANCEL** is a suggested behavior for journaling applications, whereas CTRL+ESC or CTRL+ALT+DEL cause the system to cancel journaling regardless of a journaling application's behavior.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/winmsg/wm-canceljournal#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_INPUTLANGCHANGEREQUEST">
            <summary>Posted to the window with the focus when the user chooses a new input language, either with the hotkey (specified in the Keyboard control panel application) or from the indicator on the system taskbar.</summary>
            <returns>
            <para>Type: **LRESULT** This message is posted, not sent, to the application, so the return value is ignored. To accept the change, the application should pass the message to [**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowproca). To reject the change, the application should return zero without calling **DefWindowProc**.</para>
            </returns>
            <remarks>
            <para>When the [**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowproca) function receives the **WM\_INPUTLANGCHANGEREQUEST** message, it activates the new input locale and notifies the application of the change by sending the [**WM\_INPUTLANGCHANGE**](wm-inputlangchange.md) message. The language indicator is present on the taskbar only if you have installed more than one keyboard layout and if you have enabled the indicator using the Keyboard control panel application.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/winmsg/wm-inputlangchangerequest#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_INPUTLANGCHANGE">
            <summary>Sent to the topmost affected window after an application's input language has been changed. You should make any application-specific settings and pass the message to the DefWindowProc function, which passes the message to all first-level child windows.</summary>
            <returns>
            <para>Type: **LRESULT** An application should return nonzero if it processes this message.</para>
            </returns>
            <remarks>
            <para>You can retrieve the [BCP 47](https://www.rfc-editor.org/info/bcp47) [locale name](../Intl/locale-names.md) from the language identifier by calling the [LCIDToLocaleName](/windows/win32/api/winnls/nf-winnls-lcidtolocalename) function. Once you have the locale name, you can then use [modern locale functions](/windows/win32/intl/calling-the--locale-name--functions) to extract additional locale information. </para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/winmsg/wm-inputlangchange#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_TCARD">
            <summary>Sent to an application that has initiated a training card with Windows Help.</summary>
            <returns>The return value is ignored; use zero.</returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/shell/wm-tcard">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_HELP">
            <summary>Indicates that the user pressed the F1 key.</summary>
            <returns>Returns **TRUE**.</returns>
            <remarks>The [**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowproca) function passes **WM\_HELP** to the parent window of a child window or to the owner of a top-level window.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_USERCHANGED">
            <summary>Sent to all windows after the user has logged on or off. When the user logs on or off, the system updates the user-specific settings. The system sends this message immediately after updating the settings.</summary>
            <returns>
            <para>Type: **LRESULT** An application should return zero if it processes this message.</para>
            </returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/winmsg/wm-userchanged">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_NOTIFYFORMAT">
            <summary>Determines if a window accepts ANSI or Unicode structures in the WM\_NOTIFY notification message. WM\_NOTIFYFORMAT messages are sent from a common control to its parent window and from the parent window to the common control.</summary>
            <returns>
            <para>Returns one of the following values.</para>
            <para>| Return code                                                                                 | Description                                                                                                    | |---------------------------------------------------------------------------------------------|----------------------------------------------------------------------------------------------------------------| | <dl> <dt>**NFR\_ANSI**</dt> </dl>    | ANSI structures should be used in [**WM\_NOTIFY**](wm-notify.md) messages sent by the control.<br/>     | | <dl> <dt>**NFR\_UNICODE**</dt> </dl> | Unicode structures should be used in [**WM\_NOTIFY**](wm-notify.md) messages sent by the control. <br/> | | <dl> <dt>**0**</dt> </dl>            | An error occurred.<br/>                                                                                  |</para>
            </returns>
            <remarks>
            <para>When a common control is created, the control sends a **WM\_NOTIFYFORMAT** message to its parent window to determine the type of structures to use in [**WM\_NOTIFY**](wm-notify.md) messages. If the parent window does not handle this message, the [**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowproca) function responds according to the type of the parent window. That is, if the parent window is a Unicode window, **DefWindowProc** returns NFR\_UNICODE, and if the parent window is an ANSI window, **DefWindowProc** returns NFR\_ANSI. If the parent window is a dialog box and does not handle this message, the [**DefDlgProc**](/windows/desktop/api/winuser/nf-winuser-defdlgprocw) function similarly responds according to the type of the dialog box (Unicode or ANSI). A parent window can change the type of structures a common control uses in [**WM\_NOTIFY**](wm-notify.md) messages by setting *lParam* to NF\_REQUERY and sending a **WM\_NOTIFYFORMAT** message to the control. This causes the control to send an NF\_QUERY form of the **WM\_NOTIFYFORMAT** message to the parent window. All common controls will send **WM\_NOTIFYFORMAT** messages. However, the standard Windows controls (edit controls, combo boxes, list boxes, buttons, scroll bars, and static controls) do not.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/Controls/wm-notifyformat#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_STYLECHANGING">
            <summary>Sent to a window when the SetWindowLong function is about to change one or more of the window's styles.</summary>
            <returns>
            <para>Type: **LRESULT** An application should return zero if it processes this message.</para>
            </returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/winmsg/wm-stylechanging">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_STYLECHANGED">
            <summary>Sent to a window after the SetWindowLong function has changed one or more of the window's styles.</summary>
            <returns>
            <para>Type: **LRESULT** An application should return zero if it processes this message.</para>
            </returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/winmsg/wm-stylechanged">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_DISPLAYCHANGE">
            <summary>The WM\_DISPLAYCHANGE message is sent to all windows when the display resolution has changed.</summary>
            <remarks>This message is only sent to top-level windows. For all other windows it is posted.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_GETICON">
            <summary>Sent to a window to retrieve a handle to the large or small icon associated with a window. The system displays the large icon in the ALT+TAB dialog, and the small icon in the window caption.</summary>
            <returns>
            <para>Type: **HICON** The return value is a handle to the large or small icon, depending on the value of *wParam*. When an application receives this message, it can return a handle to a large or small icon, or pass the message to the [**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowproca) function.</para>
            </returns>
            <remarks>
            <para>When an application receives this message, it can return a handle to a large or small icon, or pass the message to [**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowproca). [**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowproca) returns a handle to the large or small icon associated with the window, depending on the value of *wParam*. A window that has no icon explicitly set (with **WM\_SETICON**) uses the icon for the registered window class, and in this case [**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowproca) will return 0 for a **WM\_GETICON** message. If sending a **WM\_GETICON** message to a window returns 0, next try calling the [**GetClassLongPtr**](/windows/win32/api/winuser/nf-winuser-getclasslongptra) function for the window. If that returns 0 then try the [**LoadIcon**](/windows/win32/api/winuser/nf-winuser-loadicona) function.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/winmsg/wm-geticon#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_SETICON">
            <summary>Associates a new large or small icon with a window. The system displays the large icon in the ALT+TAB dialog box, and the small icon in the window caption.</summary>
            <returns>
            <para>Type: **LRESULT** The return value is a handle to the previous large or small icon, depending on the value of *wParam*. It is **NULL** if the window previously had no icon of the type indicated by *wParam*.</para>
            </returns>
            <remarks>The [**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowproca) function returns a handle to the previous large or small icon associated with the window, depending on the value of *wParam*.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_NCCREATE">
            <summary>Sent prior to the WM\_CREATE message when a window is first created.</summary>
            <returns>
            <para>Type: **LRESULT** If an application processes this message, it should return **TRUE** to continue creation of the window. If the application returns **FALSE**, the [**CreateWindow**](/windows/win32/api/winuser/nf-winuser-createwindowa) or [**CreateWindowEx**](/windows/win32/api/winuser/nf-winuser-createwindowexa) function will return a **NULL** handle.</para>
            </returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/winmsg/wm-nccreate">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_NCDESTROY">
            <summary>Notifies a window that its nonclient area is being destroyed. The DestroyWindow function sends the WM\_NCDESTROY message to the window following the WM\_DESTROY message.</summary>
            <returns>
            <para>Type: **LRESULT** If an application processes this message, it should return zero.</para>
            </returns>
            <remarks>This message frees any memory internally allocated for the window.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_NCCALCSIZE">
            <summary>Sent when the size and position of a window's client area must be calculated. By processing this message, an application can control the content of the window's client area when the size or position of the window changes.</summary>
            <returns>
            <para>Type: **LRESULT** If the *wParam* parameter is **FALSE**, the application should return zero. If *wParam* is **TRUE**, the application should return zero or a combination of the following values. If *wParam* is **TRUE** and an application returns zero, the old client area is preserved and is aligned with the upper-left corner of the new client area.</para>
            <para>| Return code/value                                                                                                                                           | Description                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             | |-------------------------------------------------------------------------------------------------------------------------------------------------------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------| | <dl> <dt>**WVR\_ALIGNTOP**</dt> <dt>0x0010</dt> </dl>    | Specifies that the client area of the window is to be preserved and aligned with the top of the new position of the window. For example, to align the client area to the upper-left corner, return the WVR\_ALIGNTOP and **WVR\_ALIGNLEFT** values.<br/>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          | | <dl> <dt>**WVR\_ALIGNRIGHT**</dt> <dt>0x0080</dt> </dl>  | Specifies that the client area of the window is to be preserved and aligned with the right side of the new position of the window. For example, to align the client area to the lower-right corner, return the **WVR\_ALIGNRIGHT** and WVR\_ALIGNBOTTOM values.<br/>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              | | <dl> <dt>**WVR\_ALIGNLEFT**</dt> <dt>0x0020</dt> </dl>   | Specifies that the client area of the window is to be preserved and aligned with the left side of the new position of the window. For example, to align the client area to the lower-left corner, return the **WVR\_ALIGNLEFT** and **WVR\_ALIGNBOTTOM** values.<br/>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             | | <dl> <dt>**WVR\_ALIGNBOTTOM**</dt> <dt>0x0040</dt> </dl> | Specifies that the client area of the window is to be preserved and aligned with the bottom of the new position of the window. For example, to align the client area to the top-left corner, return the WVR\_ALIGNTOP and **WVR\_ALIGNLEFT** values.<br/>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         | | <dl> <dt>**WVR\_HREDRAW**</dt> <dt>0x0100</dt> </dl>     | Used in combination with any other values, except **WVR\_VALIDRECTS**, causes the window to be completely redrawn if the client rectangle changes size horizontally. This value is similar to [CS\_HREDRAW](about-window-classes.md) class style<br/>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               | | <dl> <dt>**WVR\_VREDRAW**</dt> <dt>0x0200</dt> </dl>     | Used in combination with any other values, except **WVR\_VALIDRECTS**, causes the window to be completely redrawn if the client rectangle changes size vertically. This value is similar to [CS\_VREDRAW](about-window-classes.md) class style<br/>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 | | <dl> <dt>**WVR\_REDRAW**</dt> <dt>0x0300</dt> </dl>      | This value causes the entire window to be redrawn. It is a combination of **WVR\_HREDRAW** and **WVR\_VREDRAW** values.<br/>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      | | <dl> <dt>**WVR\_VALIDRECTS**</dt> <dt>0x0400</dt> </dl>  | This value indicates that, upon return from [**WM\_NCCALCSIZE**](wm-nccalcsize.md), the rectangles specified by the **rgrc**\[1\] and **rgrc**\[2\] members of the [**NCCALCSIZE\_PARAMS**](/windows/win32/api/winuser/ns-winuser-nccalcsize_params) structure contain valid destination and source area rectangles, respectively. The system combines these rectangles to calculate the area of the window to be preserved. The system copies any part of the window image that is within the source rectangle and clips the image to the destination rectangle. Both rectangles are in parent-relative or screen-relative coordinates. This flag cannot be combined with any other flags. <br/> This return value allows an application to implement more elaborate client-area preservation strategies, such as centering or preserving a subset of the client area.<br/> |</para>
            </returns>
            <remarks>
            <para>The window may be redrawn, depending on whether the [CS\_HREDRAW](about-window-classes.md) or CS\_VREDRAW class style is specified. This is the default, backward-compatible processing of this message by the [**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowproca) function (in addition to the usual client rectangle calculation described in the preceding table). When *wParam* is **TRUE**, simply returning 0 without processing the [**NCCALCSIZE\_PARAMS**](/windows/win32/api/winuser/ns-winuser-nccalcsize_params) rectangles will cause the client area to resize to the size of the window, including the window frame. This will remove the window frame and caption items from your window, leaving only the client area displayed. Starting with Windows Vista, removing the standard frame by simply returning 0 when the *wParam* is **TRUE** does not affect frames that are extended into the client area using the [**DwmExtendFrameIntoClientArea**](/windows/win32/api/dwmapi/nf-dwmapi-dwmextendframeintoclientarea) function. Only the standard frame will be removed.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/winmsg/wm-nccalcsize#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_NCHITTEST">
            <summary>Sent to a window in order to determine what part of the window corresponds to a particular screen coordinate.</summary>
            <returns>
            <para>The return value of the [**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowproca) function is one of the following values, indicating the position of the cursor hot spot.</para>
            <para>| Return code/value                                                                                                                                    | Description                                                                                                                                                                                                        | |------------------------------------------------------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------| | <dl> <dt>**HTBORDER**</dt> <dt>18</dt> </dl>      | In the border of a window that does not have a sizing border.<br/>                                                                                                                                           | | <dl> <dt>**HTBOTTOM**</dt> <dt>15</dt> </dl>      | In the lower-horizontal border of a resizable window (the user can click the mouse to resize the window vertically).<br/>                                                                                    | | <dl> <dt>**HTBOTTOMLEFT**</dt> <dt>16</dt> </dl>  | In the lower-left corner of a border of a resizable window (the user can click the mouse to resize the window diagonally).<br/>                                                                              | | <dl> <dt>**HTBOTTOMRIGHT**</dt> <dt>17</dt> </dl> | In the lower-right corner of a border of a resizable window (the user can click the mouse to resize the window diagonally).<br/>                                                                             | | <dl> <dt>**HTCAPTION**</dt> <dt>2</dt> </dl>      | In a title bar.<br/>                                                                                                                                                                                         | | <dl> <dt>**HTCLIENT**</dt> <dt>1</dt> </dl>       | In a client area.<br/>                                                                                                                                                                                       | | <dl> <dt>**HTCLOSE**</dt> <dt>20</dt> </dl>       | In a **Close** button.<br/>                                                                                                                                                                                  | | <dl> <dt>**HTERROR**</dt> <dt>-2</dt> </dl>       | On the screen background or on a dividing line between windows (same as **HTNOWHERE**, except that the [**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowproca) function produces a system beep to indicate an error).<br/> | | <dl> <dt>**HTGROWBOX**</dt> <dt>4</dt> </dl>      | In a size box (same as **HTSIZE**).<br/>                                                                                                                                                                     | | <dl> <dt>**HTHELP**</dt> <dt>21</dt> </dl>        | In a **Help** button.<br/>                                                                                                                                                                                   | | <dl> <dt>**HTHSCROLL**</dt> <dt>6</dt> </dl>      | In a horizontal scroll bar.<br/>                                                                                                                                                                             | | <dl> <dt>**HTLEFT**</dt> <dt>10</dt> </dl>        | In the left border of a resizable window (the user can click the mouse to resize the window horizontally).<br/>                                                                                              | | <dl> <dt>**HTMENU**</dt> <dt>5</dt> </dl>         | In a menu.<br/>                                                                                                                                                                                              | | <dl> <dt>**HTMAXBUTTON**</dt> <dt>9</dt> </dl>    | In a **Maximize** button.<br/>                                                                                                                                                                               | | <dl> <dt>**HTMINBUTTON**</dt> <dt>8</dt> </dl>    | In a **Minimize** button.<br/>                                                                                                                                                                               | | <dl> <dt>**HTNOWHERE**</dt> <dt>0</dt> </dl>      | On the screen background or on a dividing line between windows.<br/>                                                                                                                                         | | <dl> <dt>**HTREDUCE**</dt> <dt>8</dt> </dl>       | In a **Minimize** button.<br/>                                                                                                                                                                               | | <dl> <dt>**HTRIGHT**</dt> <dt>11</dt> </dl>       | In the right border of a resizable window (the user can click the mouse to resize the window horizontally).<br/>                                                                                             | | <dl> <dt>**HTSIZE**</dt> <dt>4</dt> </dl>         | In a size box (same as **HTGROWBOX**).<br/>                                                                                                                                                                  | | <dl> <dt>**HTSYSMENU**</dt> <dt>3</dt> </dl>      | In a window menu or in a **Close** button in a child window.<br/>                                                                                                                                            | | <dl> <dt>**HTTOP**</dt> <dt>12</dt> </dl>         | In the upper-horizontal border of a window.<br/>                                                                                                                                                             | | <dl> <dt>**HTTOPLEFT**</dt> <dt>13</dt> </dl>     | In the upper-left corner of a window border.<br/>                                                                                                                                                            | | <dl> <dt>**HTTOPRIGHT**</dt> <dt>14</dt> </dl>    | In the upper-right corner of a window border.<br/>                                                                                                                                                           | | <dl> <dt>**HTTRANSPARENT**</dt> <dt>-1</dt> </dl> | In a window currently covered by another window in the same thread (the message will be sent to underlying windows in the same thread until one of them returns a code that is not **HTTRANSPARENT**).<br/>  | | <dl> <dt>**HTVSCROLL**</dt> <dt>7</dt> </dl>      | In the vertical scroll bar.<br/>                                                                                                                                                                             | | <dl> <dt>**HTZOOM**</dt> <dt>9</dt> </dl>         | In a **Maximize** button.<br/>                                                                                                                                                                               |</para>
            </returns>
            <remarks>
            <para>Use the following code to obtain the horizontal and vertical position:</para>
            <para></para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/inputdev/wm-nchittest#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_NCPAINT">
            <summary>The WM\_NCPAINT message is sent to a window when its frame must be painted.</summary>
            <returns>An application returns zero if it processes this message.</returns>
            <remarks>
            <para>The [**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowproca) function paints the window frame. An application can intercept the **WM\_NCPAINT** message and paint its own custom window frame. The clipping region for a window is always rectangular, even if the shape of the frame is altered. The *wParam* value can be passed to [**GetDCEx**](/windows/desktop/api/Winuser/nf-winuser-getdcex) as in the following example.</para>
            <para></para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/gdi/wm-ncpaint#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_NCACTIVATE">
            <summary>Sent to a window when its nonclient area needs to be changed to indicate an active or inactive state.</summary>
            <returns>
            <para>Type: **LRESULT** When the *wParam* parameter is **FALSE**, an application should return **TRUE** to indicate that the system should proceed with the default processing, or it should return **FALSE** to prevent the change. When *wParam* is **TRUE**, the return value is ignored.</para>
            </returns>
            <remarks>
            <para>Processing messages related to the nonclient area of a standard window is not recommended, because the application must be able to draw all the required parts of the nonclient area for the window. If an application does process this message, it must return **TRUE** to direct the system to complete the change of active window. If the window is minimized when this message is received, the application should pass the message to the [**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowproca) function. The [**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowproca) function draws the title bar or icon title in its active colors when the *wParam* parameter is **TRUE** and in its inactive colors when *wParam* is **FALSE**.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/winmsg/wm-ncactivate#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_GETDLGCODE">
            <summary>Sent to the window procedure associated with a control.</summary>
            <returns>
            <para>The return value is one or more of the following values, indicating which type of input the application processes.</para>
            <para>| Return code/value                                                                                                                                                | Description                                                                                                                | |------------------------------------------------------------------------------------------------------------------------------------------------------------------|----------------------------------------------------------------------------------------------------------------------------| | <dl> <dt>**DLGC\_BUTTON**</dt> <dt>0x2000</dt> </dl>          | Button.<br/>                                                                                                         | | <dl> <dt>**DLGC\_DEFPUSHBUTTON**</dt> <dt>0x0010</dt> </dl>   | Default push button.<br/>                                                                                            | | <dl> <dt>**DLGC\_HASSETSEL**</dt> <dt>0x0008</dt> </dl>       | [**EM\_SETSEL**](/windows/desktop/Controls/em-setsel) messages.<br/>                                                           | | <dl> <dt>**DLGC\_RADIOBUTTON**</dt> <dt>0x0040</dt> </dl>     | Radio button.<br/>                                                                                                   | | <dl> <dt>**DLGC\_STATIC**</dt> <dt>0x0100</dt> </dl>          | Static control.<br/>                                                                                                 | | <dl> <dt>**DLGC\_UNDEFPUSHBUTTON**</dt> <dt>0x0020</dt> </dl> | Non-default push button.<br/>                                                                                        | | <dl> <dt>**DLGC\_WANTALLKEYS**</dt> <dt>0x0004</dt> </dl>     | All keyboard input.<br/>                                                                                             | | <dl> <dt>**DLGC\_WANTARROWS**</dt> <dt>0x0001</dt> </dl>      | Direction keys.<br/>                                                                                                 | | <dl> <dt>**DLGC\_WANTCHARS**</dt> <dt>0x0080</dt> </dl>       | [**WM\_CHAR**](/windows/desktop/inputdev/wm-char) messages.<br/>                                                                      | | <dl> <dt>**DLGC\_WANTMESSAGE**</dt> <dt>0x0004</dt> </dl>     | All keyboard input (the application passes this message in the [**MSG**](/windows/win32/api/winuser/ns-winuser-msg) structure to the control).<br/> | | <dl> <dt>**DLGC\_WANTTAB**</dt> <dt>0x0002</dt> </dl>         | TAB key.<br/>                                                                                                        |</para>
            </returns>
            <remarks>
            <para>Although the [**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowproca) function always returns zero in response to the **WM\_GETDLGCODE** message, the window procedure for the predefined control classes return a code appropriate for each class. The **WM\_GETDLGCODE** message and the returned values are useful only with user-defined dialog box controls or standard controls modified by subclassing.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/dlgbox/wm-getdlgcode#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_SYNCPAINT">
            <summary>The WM\_SYNCPAINT message is used to synchronize painting while avoiding linking independent GUI threads.</summary>
            <returns>An application returns zero if it processes this message.</returns>
            <remarks>When a window has been hidden, shown, moved, or sized, the system may determine that it is necessary to send a **WM\_SYNCPAINT** message to the top-level windows of other threads. Applications must pass **WM\_SYNCPAINT** to [**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowproca)  for processing. The **DefWindowProc** function will send a [**WM\_NCPAINT**](wm-ncpaint.md) message to the window procedure if the window frame must be painted and send a [**WM\_ERASEBKGND**](../winmsg/wm-erasebkgnd.md) message if the window background must be erased.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_NCMOUSEMOVE">
            <summary>Posted to a window when the cursor is moved within the nonclient area of the window. This message is posted to the window that contains the cursor. If a window has captured the mouse, this message is not posted.</summary>
            <returns>If an application processes this message, it should return zero.</returns>
            <remarks>
            <para>If it is appropriate to do so, the system sends the [**WM\_SYSCOMMAND**](/windows/desktop/menurc/wm-syscommand) message to the window. You can also use the [**GET\_X\_LPARAM**](/windows/desktop/api/windowsx/nf-windowsx-get_x_lparam) and [**GET\_Y\_LPARAM**](/windows/desktop/api/windowsx/nf-windowsx-get_y_lparam) macros to extract the values of the x- and y- coordinates from *lParam*.</para>
            <para></para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/inputdev/wm-ncmousemove#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_NCLBUTTONDOWN">
            <summary>Posted when the user presses the left mouse button while the cursor is within the nonclient area of a window. This message is posted to the window that contains the cursor. If a window has captured the mouse, this message is not posted.</summary>
            <returns>If an application processes this message, it should return zero.</returns>
            <remarks>
            <para>The [**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowproca) function tests the specified point to find the location of the cursor and performs the appropriate action. If appropriate, **DefWindowProc** sends the [**WM\_SYSCOMMAND**](/windows/desktop/menurc/wm-syscommand) message to the window. You can also use the [**GET\_X\_LPARAM**](/windows/desktop/api/windowsx/nf-windowsx-get_x_lparam) and [**GET\_Y\_LPARAM**](/windows/desktop/api/windowsx/nf-windowsx-get_y_lparam) macros to extract the values of the x- and y- coordinates from *lParam*.</para>
            <para></para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/inputdev/wm-nclbuttondown#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_NCLBUTTONUP">
            <summary>Posted when the user releases the left mouse button while the cursor is within the nonclient area of a window. This message is posted to the window that contains the cursor. If a window has captured the mouse, this message is not posted.</summary>
            <returns>If an application processes this message, it should return zero.</returns>
            <remarks>
            <para>The [**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowproca) function tests the specified point to find out the location of the cursor and performs the appropriate action. If appropriate, **DefWindowProc** sends the [**WM\_SYSCOMMAND**](/windows/desktop/menurc/wm-syscommand) message to the window. You can also use the [**GET\_X\_LPARAM**](/windows/desktop/api/windowsx/nf-windowsx-get_x_lparam) and [**GET\_Y\_LPARAM**](/windows/desktop/api/windowsx/nf-windowsx-get_y_lparam) macros to extract the values of the x- and y- coordinates from *lParam*.</para>
            <para></para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/inputdev/wm-nclbuttonup#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_NCLBUTTONDBLCLK">
            <summary>Posted when the user double-clicks the left mouse button while the cursor is within the nonclient area of a window. This message is posted to the window that contains the cursor. If a window has captured the mouse, this message is not posted.</summary>
            <returns>If an application processes this message, it should return zero.</returns>
            <remarks>
            <para>You can also use the [**GET\_X\_LPARAM**](/windows/desktop/api/windowsx/nf-windowsx-get_x_lparam) and [**GET\_Y\_LPARAM**](/windows/desktop/api/windowsx/nf-windowsx-get_y_lparam) macros to extract the values of the x- and y- coordinates from *lParam*.</para>
            <para></para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/inputdev/wm-nclbuttondblclk#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_NCRBUTTONDOWN">
            <summary>Posted when the user presses the right mouse button while the cursor is within the nonclient area of a window. This message is posted to the window that contains the cursor. If a window has captured the mouse, this message is not posted.</summary>
            <returns>If an application processes this message, it should return zero.</returns>
            <remarks>
            <para>You can also use the [**GET\_X\_LPARAM**](/windows/desktop/api/windowsx/nf-windowsx-get_x_lparam) and [**GET\_Y\_LPARAM**](/windows/desktop/api/windowsx/nf-windowsx-get_y_lparam) macros to extract the values of the x- and y- coordinates from *lParam*.</para>
            <para></para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/inputdev/wm-ncrbuttondown#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_NCRBUTTONUP">
            <summary>Posted when the user releases the right mouse button while the cursor is within the nonclient area of a window. This message is posted to the window that contains the cursor. If a window has captured the mouse, this message is not posted.</summary>
            <returns>If an application processes this message, it should return zero.</returns>
            <remarks>
            <para>You can also use the [**GET\_X\_LPARAM**](/windows/desktop/api/windowsx/nf-windowsx-get_x_lparam) and [**GET\_Y\_LPARAM**](/windows/desktop/api/windowsx/nf-windowsx-get_y_lparam) macros to extract the values of the x- and y- coordinates from *lParam*.</para>
            <para></para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/inputdev/wm-ncrbuttonup#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_NCRBUTTONDBLCLK">
            <summary>Posted when the user double-clicks the right mouse button while the cursor is within the nonclient area of a window. This message is posted to the window that contains the cursor. If a window has captured the mouse, this message is not posted.</summary>
            <returns>If an application processes this message, it should return zero.</returns>
            <remarks>
            <para>A window need not have the **CS\_DBLCLKS** style to receive **WM\_NCRBUTTONDBLCLK** messages. The system generates a **WM\_NCRBUTTONDBLCLK** message when the user presses, releases, and again presses the right mouse button within the system's double-click time limit. Double-clicking the right mouse button actually generates four messages: [**WM\_NCRBUTTONDOWN**](wm-ncrbuttondown.md), [**WM\_NCRBUTTONUP**](wm-ncrbuttonup.md), **WM\_NCRBUTTONDBLCLK**, and **WM\_NCRBUTTONUP** again. You can also use the [**GET\_X\_LPARAM**](/windows/desktop/api/windowsx/nf-windowsx-get_x_lparam) and [**GET\_Y\_LPARAM**](/windows/desktop/api/windowsx/nf-windowsx-get_y_lparam) macros to extract the values of the x- and y- coordinates from *lParam*.</para>
            <para></para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/inputdev/wm-ncrbuttondblclk#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_NCMBUTTONDOWN">
            <summary>Posted when the user presses the middle mouse button while the cursor is within the nonclient area of a window. This message is posted to the window that contains the cursor. If a window has captured the mouse, this message is not posted.</summary>
            <returns>If an application processes this message, it should return zero.</returns>
            <remarks>
            <para>You can also use the [**GET\_X\_LPARAM**](/windows/desktop/api/windowsx/nf-windowsx-get_x_lparam) and [**GET\_Y\_LPARAM**](/windows/desktop/api/windowsx/nf-windowsx-get_y_lparam) macros to extract the values of the x- and y- coordinates from *lParam*.</para>
            <para></para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/inputdev/wm-ncmbuttondown#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_NCMBUTTONUP">
            <summary>Posted when the user releases the middle mouse button while the cursor is within the nonclient area of a window. This message is posted to the window that contains the cursor. If a window has captured the mouse, this message is not posted.</summary>
            <returns>If an application processes this message, it should return zero.</returns>
            <remarks>
            <para>You can also use the [**GET\_X\_LPARAM**](/windows/desktop/api/windowsx/nf-windowsx-get_x_lparam) and [**GET\_Y\_LPARAM**](/windows/desktop/api/windowsx/nf-windowsx-get_y_lparam) macros to extract the values of the x- and y- coordinates from *lParam*.</para>
            <para></para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/inputdev/wm-ncmbuttonup#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_NCMBUTTONDBLCLK">
            <summary>Posted when the user double-clicks the middle mouse button while the cursor is within the nonclient area of a window. This message is posted to the window that contains the cursor. If a window has captured the mouse, this message is not posted.</summary>
            <returns>If an application processes this message, it should return zero.</returns>
            <remarks>
            <para>A window need not have the **CS\_DBLCLKS** style to receive **WM\_NCMBUTTONDBLCLK** messages. The system generates a **WM\_NCMBUTTONDBLCLK** message when the user presses, releases, and again presses the middle mouse button within the system's double-click time limit. Double-clicking the middle mouse button actually generates four messages: [**WM\_NCMBUTTONDOWN**](wm-ncmbuttondown.md), [**WM\_NCMBUTTONUP**](wm-ncmbuttonup.md), **WM\_NCMBUTTONDBLCLK**, and **WM\_NCMBUTTONUP** again. You can also use the [**GET\_X\_LPARAM**](/windows/desktop/api/windowsx/nf-windowsx-get_x_lparam) and [**GET\_Y\_LPARAM**](/windows/desktop/api/windowsx/nf-windowsx-get_y_lparam) macros to extract the values of the x- and y- coordinates from *lParam*.</para>
            <para></para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/inputdev/wm-ncmbuttondblclk#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_NCXBUTTONDOWN">
            <summary>Posted when the user presses the first or second X button while the cursor is in the nonclient area of a window. This message is posted to the window that contains the cursor. If a window has captured the mouse, this message is not posted.</summary>
            <returns>If an application processes this message, it should return **TRUE**. For more information about processing the return value, see the Remarks section.</returns>
            <remarks>
            <para>Use the following code to get the information in the *wParam* parameter.</para>
            <para></para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/inputdev/wm-ncxbuttondown#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_NCXBUTTONUP">
            <summary>Posted when the user releases the first or second X button while the cursor is in the nonclient area of a window. This message is posted to the window that contains the cursor. If a window has captured the mouse, this message is not posted.</summary>
            <returns>If an application processes this message, it should return **TRUE**. For more information about processing the return value, see the Remarks section.</returns>
            <remarks>
            <para>Use the following code to get the information in the *wParam* parameter.</para>
            <para></para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/inputdev/wm-ncxbuttonup#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_NCXBUTTONDBLCLK">
            <summary>Posted when the user double-clicks the first or second X button while the cursor is in the nonclient area of a window. This message is posted to the window that contains the cursor. If a window has captured the mouse, this message is not posted.</summary>
            <returns>If an application processes this message, it should return **TRUE**. For more information about processing the return value, see the Remarks section.</returns>
            <remarks>
            <para>Use the following code to get the information in the *wParam* parameter.</para>
            <para></para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/inputdev/wm-ncxbuttondblclk#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_INPUT_DEVICE_CHANGE">
            <summary>Sent to the window that registered to receive raw input. A window receives this message through its WindowProc function.</summary>
            <returns>If an application processes this message, it should return zero.</returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/inputdev/wm-input-device-change">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_INPUT">
            <summary>Sent to the window that is getting raw input. A window receives this message through its WindowProc function.</summary>
            <returns>If an application processes this message, it should return zero.</returns>
            <remarks>Raw input is available only when the application calls [**RegisterRawInputDevices**](/windows/win32/api/winuser/nf-winuser-registerrawinputdevices) with valid device specifications.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_KEYDOWN">
            <summary>Posted to the window with the keyboard focus when a nonsystem key is pressed. A nonsystem key is a key that is pressed when the ALT key is not pressed.</summary>
            <returns>An application should return zero if it processes this message.</returns>
            <remarks>
            <para>If the F10 key is pressed, the [**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowproca) function sets an internal flag. When **DefWindowProc** receives the [**WM\_KEYUP**](wm-keyup.md) message, the function checks whether the internal flag is set and, if so, sends a [**WM\_SYSCOMMAND**](/windows/desktop/menurc/wm-syscommand) message to the top-level window. The **WM\_SYSCOMMAND** parameter of the message is set to SC\_KEYMENU. Because of the autorepeat feature, more than one **WM\_KEYDOWN** message may be posted before a [**WM\_KEYUP**](wm-keyup.md) message is posted. The previous key state (bit 30) can be used to determine whether the **WM\_KEYDOWN** message indicates the first down transition or a repeated down transition. For enhanced 101- and 102-key keyboards, extended keys are the right ALT and CTRL keys on the main section of the keyboard; the INS, DEL, HOME, END, PAGE UP, PAGE DOWN, and arrow keys in the clusters to the left of the numeric keypad; and the divide (/) and ENTER keys in the numeric keypad. Other keyboards may support the extended-key bit in the *lParam* parameter. Applications must pass *wParam* to [**TranslateMessage**](/windows/desktop/api/winuser/nf-winuser-translatemessage) without altering it at all.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/inputdev/wm-keydown#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_KEYUP">
            <summary>Posted to the window with the keyboard focus when a nonsystem key is released. A nonsystem key is a key that is pressed when the ALT key is not pressed, or a keyboard key that is pressed when a window has the keyboard focus.</summary>
            <returns>An application should return zero if it processes this message.</returns>
            <remarks>
            <para>The [**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowproca) function sends a [**WM\_SYSCOMMAND**](/windows/desktop/menurc/wm-syscommand) message to the top-level window if the F10 key or the ALT key was released. The *wParam* parameter of the message is set to SC\_KEYMENU. For enhanced 101- and 102-key keyboards, extended keys are the right ALT and CTRL keys on the main section of the keyboard; the INS, DEL, HOME, END, PAGE UP, PAGE DOWN, and arrow keys in the clusters to the left of the numeric keypad; and the divide (/) and ENTER keys in the numeric keypad. Other keyboards may support the extended-key bit in the *lParam* parameter. Applications must pass *wParam* to [**TranslateMessage**](/windows/desktop/api/winuser/nf-winuser-translatemessage) without altering it at all.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/inputdev/wm-keyup#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_CHAR">
            <summary>Posted to the window with the keyboard focus when a WM\_KEYDOWN message is translated by the TranslateMessage function. The WM\_CHAR message contains the character code of the key that was pressed.</summary>
            <returns>An application should return zero if it processes this message.</returns>
            <remarks>
            <para>The **WM\_CHAR** message uses UTF-16 (16-bit Unicode Transformation Format) code units in its **wParam** if the Unicode version of the [**RegisterClass**](/windows/win32/api/winuser/nf-winuser-registerclassw) function was used to register the window class. Otherwise, the system provides characters in the current process code page, which can be set to UTF-8 in Windows Version 1903 (May 2019 Update) and newer. For more information, see [Registering Window Classes](/windows/win32/intl/registering-window-classes) and [Use UTF-8 code pages in Windows apps](/windows/apps/design/globalizing/use-utf8-code-page). Starting with Windows Vista, **WM\_CHAR** message can send [UTF-16 surrogate pairs](/windows/win32/intl/surrogates-and-supplementary-characters) to Unicode windows. Use the [IS_HIGH_SURROGATE](/windows/win32/api/Winnls/nf-winnls-is_high_surrogate), [IS_LOW_SURROGATE](/windows/win32/api/winnls/nf-winnls-is_low_surrogate), and [IS_SURROGATE_PAIR](/windows/win32/api/winnls/nf-winnls-is_surrogate_pair) macros to detect such cases, if necessary. There is not necessarily a one-to-one correspondence between keys pressed and character messages generated, and so the information in the high-order word of the *lParam* parameter is generally not useful to applications. The information in the high-order word applies only to the most recent [**WM\_KEYDOWN**](wm-keydown.md) message that precedes the posting of the **WM\_CHAR** message. For enhanced 101- and 102-key keyboards, extended keys are the right ALT and the right CTRL keys on the main section of the keyboard; the INS, DEL, HOME, END, PAGE UP, PAGE DOWN and arrow keys in the clusters to the left of the numeric keypad; and the divide (/) and ENTER keys in the numeric keypad. Some other keyboards may support the extended-key bit in the *lParam* parameter. The [**WM\_UNICHAR**](wm-unichar.md) message is the same as **WM\_CHAR**, except it uses UTF-32. It is designed to send or post Unicode characters to ANSI windows, and it can handle Unicode Supplementary Plane characters.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/inputdev/wm-char#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_DEADCHAR">
            <summary>Posted to the window with the keyboard focus when a WM\_KEYUP message is translated by the TranslateMessage function.</summary>
            <returns>An application should return zero if it processes this message.</returns>
            <remarks>
            <para>The **WM\_DEADCHAR** message typically is used by applications to give the user feedback about each key pressed. For example, an application can display the accent in the current character position without moving the caret. Because there is not necessarily a one-to-one correspondence between keys pressed and character messages generated, the information in the high-order word of the *lParam* parameter is generally not useful to applications. The information in the high-order word applies only to the most recent [**WM\_KEYDOWN**](wm-keydown.md) message that precedes the posting of the **WM\_DEADCHAR** message. For enhanced 101- and 102-key keyboards, extended keys are the right ALT and the right CTRL keys on the main section of the keyboard; the INS, DEL, HOME, END, PAGE UP, PAGE DOWN and arrow keys in the clusters to the left of the numeric keypad; and the divide (/) and ENTER keys in the numeric keypad. Some other keyboards may support the extended-key bit in the *lParam* parameter.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/inputdev/wm-deadchar#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_SYSKEYDOWN">
            <summary>Posted to the window with the keyboard focus when the user presses the F10 key (which activates the menu bar) or holds down the ALT key and then presses another key.</summary>
            <returns>An application should return zero if it processes this message.</returns>
            <remarks>
            <para>The [**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowproca) function examines the specified key and generates a [**WM\_SYSCOMMAND**](/windows/desktop/menurc/wm-syscommand) message if the key is either TAB or ENTER. When the context code is zero, the message can be passed to the [**TranslateAccelerator**](/windows/desktop/api/winuser/nf-winuser-translateacceleratora) function, which will handle it as though it were a normal key message instead of a character-key message. This allows accelerator keys to be used with the active window even if the active window does not have the keyboard focus. Because of automatic repeat, more than one **WM\_SYSKEYDOWN** message may occur before a [**WM\_SYSKEYUP**](wm-syskeyup.md) message is sent. The previous key state (bit 30) can be used to determine whether the **WM\_SYSKEYDOWN** message indicates the first down transition or a repeated down transition. For enhanced 101- and 102-key keyboards, enhanced keys are the right ALT and CTRL keys on the main section of the keyboard; the INS, DEL, HOME, END, PAGE UP, PAGE DOWN, and arrow keys in the clusters to the left of the numeric keypad; and the divide (/) and ENTER keys in the numeric keypad. Other keyboards may support the extended-key bit in the *lParam* parameter. This message is also sent whenever the user presses the F10 key without the ALT key.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/inputdev/wm-syskeydown#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_SYSKEYUP">
            <summary>Posted to the window with the keyboard focus when the user releases a key that was pressed while the ALT key was held down.</summary>
            <returns>An application should return zero if it processes this message.</returns>
            <remarks>
            <para>The [**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowproca) function sends a [**WM\_SYSCOMMAND**](/windows/desktop/menurc/wm-syscommand) message to the top-level window if the F10 key or the ALT key was released. The *wParam* parameter of the message is set to **SC\_KEYMENU**. When the context code is zero, the message can be passed to the [**TranslateAccelerator**](/windows/desktop/api/winuser/nf-winuser-translateacceleratora) function, which will handle it as though it were a normal key message instead of a character-key message. This allows accelerator keys to be used with the active window even if the active window does not have the keyboard focus. For enhanced 101- and 102-key keyboards, extended keys are the right ALT and CTRL keys on the main section of the keyboard; the INS, DEL, HOME, END, PAGE UP, PAGE DOWN, and arrow keys in the clusters to the left of the numeric keypad; and the divide (/) and ENTER keys in the numeric keypad. Other keyboards may support the extended-key bit in the *lParam* parameter. For non-U.S. enhanced 102-key keyboards, the right ALT key is handled as a CTRL+ALT key. The following table shows the sequence of messages that result when the user presses and releases this key.</para>
            <para>| Message                           | Virtual-key code | |-----------------------------------|------------------| | [**WM\_KEYDOWN**](wm-keydown.md) | **VK\_CONTROL**  | | [**WM\_KEYDOWN**](wm-keydown.md) | **VK\_MENU**     | | [**WM\_KEYUP**](wm-keyup.md)     | **VK\_CONTROL**  | | **WM\_SYSKEYUP**                  | **VK\_MENU**     |</para>
            <para><see href="https://learn.microsoft.com/windows/win32/inputdev/wm-syskeyup#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_SYSCHAR">
            <summary>Posted to the window with the keyboard focus when a WM\_SYSKEYDOWN message is translated by the TranslateMessage function.</summary>
            <returns>An application should return zero if it processes this message.</returns>
            <remarks>
            <para>When the context code is zero, the message can be passed to the [**TranslateAccelerator**](/windows/desktop/api/Winuser/nf-winuser-translateacceleratora) function, which will handle it as though it were a standard key message instead of a system character-key message. This allows accelerator keys to be used with the active window even if the active window does not have the keyboard focus. For enhanced 101- and 102-key keyboards, extended keys are the right ALT and CTRL keys on the main section of the keyboard; the INS, DEL, HOME, END, PAGE UP, PAGE DOWN and arrow keys in the clusters to the left of the numeric keypad; the PRINT SCRN key; the BREAK key; the NUMLOCK key; and the divide (/) and ENTER keys in the numeric keypad. Other keyboards may support the extended-key bit in the parameter.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/menurc/wm-syschar#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_SYSDEADCHAR">
            <summary>Sent to the window with the keyboard focus when a WM\_SYSKEYDOWN message is translated by the TranslateMessage function.</summary>
            <returns>An application should return zero if it processes this message.</returns>
            <remarks>For enhanced 101- and 102-key keyboards, extended keys are the right ALT and CTRL keys on the main section of the keyboard; the INS, DEL, HOME, END, PAGE UP, PAGE DOWN, and arrow keys in the clusters to the left of the numeric keypad; and the divide (/) and ENTER keys in the numeric keypad. Other keyboards may support the extended-key bit in the *lParam* parameter.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_IME_STARTCOMPOSITION">
            <summary>Sent immediately before the IME generates the composition string as a result of a keystroke. A window receives this message through its WindowProc function.</summary>
            <returns>
            <para>This message has no parameters.</para>
            <para>This message has no return value.</para>
            </returns>
            <remarks>
            <para>This message is a notification to an IME window to open its composition window. An application should process this message if it displays composition characters itself. If an application has created an IME window, it should pass this message to that window. The [**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowproca) function processes the message by passing it to the default IME window.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/Intl/wm-ime-startcomposition#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_IME_ENDCOMPOSITION">
            <summary>Sent to an application when the IME ends composition. A window receives this message through its WindowProc function.</summary>
            <returns>
            <para>This message has no parameters.</para>
            <para>This message has no return value.</para>
            </returns>
            <remarks>
            <para>An application should process this message if it displays composition characters itself. If the application has created an IME window, it should pass this message to that window. The [**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowproca)  function processes this message by passing it to the default IME window.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/Intl/wm-ime-endcomposition#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_IME_COMPOSITION">
            <summary>Sent to an application when the IME changes composition status as a result of a keystroke. A window receives this message through its WindowProc function.</summary>
            <returns>This message has no return value.</returns>
            <remarks>
            <para>An application should process this message if it displays composition characters itself. Otherwise, it should send the message to the IME window. If the application has created an IME window, it should pass this message to that window. The [**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowproca)  function processes this message by passing it to the default IME window. The IME window processes this message by updating its appearance based on the change flag specified. An application can call [**ImmGetCompositionString**](/windows/desktop/api/Imm/nf-imm-immgetcompositionstringa) to retrieve the new composition status. If none of the GCS\_ values are set, the message indicates that the current composition has been canceled and applications that draw the composition string should delete the string.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/Intl/wm-ime-composition#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_INITDIALOG">
            <summary>Sent to the dialog box procedure immediately before a dialog box is displayed. Dialog box procedures typically use this message to initialize controls and carry out any other initialization tasks that affect the appearance of the dialog box.</summary>
            <returns>
            <para>The dialog box procedure should return **TRUE** to direct the system to set the keyboard focus to the control specified by *wParam*. Otherwise, it should return **FALSE** to prevent the system from setting the default keyboard focus. The dialog box procedure should return the value directly. The **DWL\_MSGRESULT** value set by the [**SetWindowLong**](/windows/desktop/api/winuser/nf-winuser-setwindowlonga) function is ignored.</para>
            </returns>
            <remarks>
            <para>The control to receive the default keyboard focus is always the first control in the dialog box that is visible, not disabled, and that has the **WS\_TABSTOP** style. When the dialog box procedure returns **TRUE**, the system checks the control to ensure that the procedure has not disabled it. If it has been disabled, the system sets the keyboard focus to the next control that is visible, not disabled, and has the **WS\_TABSTOP**. An application can return **FALSE** only if it has set the keyboard focus to one of the controls of the dialog box.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/dlgbox/wm-initdialog#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_COMMAND">
            <summary>Sent when the user selects a command item from a menu, when a control sends a notification message to its parent window, or when an accelerator keystroke is translated.</summary>
            <returns>If an application processes this message, it should return zero.</returns>
            <remarks>
            <para>Use of the *wParam* and *lParam* parameters are summarized here.</para>
            <para>| Message Source | wParam (high word)                | wParam (low word)                | lParam                       | |----------------|-----------------------------------|----------------------------------|------------------------------| | Menu           | 0                                 | Menu identifier (IDM\_\*)        | 0                            | | Accelerator    | 1                                 | Accelerator identifier (IDM\_\*) | 0                            | | Control        | Control-defined notification code | Control identifier               | Handle to the control window |</para>
            <para><see href="https://learn.microsoft.com/windows/win32/menurc/wm-command#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_SYSCOMMAND">
            <summary>A window receives this message when the user chooses a command from the Window menu (formerly known as the system or control menu) or when the user chooses the maximize button, minimize button, restore button, or close button.</summary>
            <returns>An application should return zero if it processes this message.</returns>
            <remarks>
            <para>To obtain the position coordinates in screen coordinates, use the following code:</para>
            <para></para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/menurc/wm-syscommand#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_TIMER">
            <summary>Posted to the installing thread's message queue when a timer expires. The message is posted by the GetMessage or PeekMessage function.</summary>
            <returns>
            <para>Type: **LRESULT** An application should return zero if it processes this message.</para>
            </returns>
            <remarks>
            <para>You can process the message by providing a **WM\_TIMER** case in the window procedure. Otherwise, [**DispatchMessage**](/windows/win32/api/winuser/nf-winuser-dispatchmessage) will call the [*TimerProc*](/windows/win32/api/winuser/nc-winuser-timerproc) callback function specified in the call to the [**SetTimer**](/windows/win32/api/winuser/nf-winuser-settimer) function used to install the timer. The **WM\_TIMER** message is a low-priority message. The [**GetMessage**](/windows/win32/api/winuser/nf-winuser-getmessage) and [**PeekMessage**](/windows/win32/api/winuser/nf-winuser-peekmessagea) functions post this message only when no other higher-priority messages are in the thread's message queue.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/winmsg/wm-timer#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_HSCROLL">
            <summary>The WM\_HSCROLL message is sent to a window when a scroll event occurs in the window's standard horizontal scroll bar.</summary>
            <returns>If an application processes this message, it should return zero.</returns>
            <remarks>
            <para>The SB\_THUMBTRACK request code is typically used by applications that provide feedback as the user drags the scroll box. If an application scrolls the content of the window, it must also reset the position of the scroll box by using the [**SetScrollPos**](/windows/desktop/api/Winuser/nf-winuser-setscrollpos) function. Note that the **WM\_HSCROLL** message carries only 16 bits of scroll box position data. Thus, applications that rely solely on **WM\_HSCROLL** (and [**WM\_VSCROLL**](wm-vscroll.md)) for scroll position data have a practical maximum position value of 65,535. However, because the [**SetScrollInfo**](/windows/desktop/api/Winuser/nf-winuser-setscrollinfo), [**SetScrollPos**](/windows/desktop/api/Winuser/nf-winuser-setscrollpos), [**SetScrollRange**](/windows/desktop/api/Winuser/nf-winuser-setscrollrange), [**GetScrollInfo**](/windows/desktop/api/Winuser/nf-winuser-getscrollinfo), [**GetScrollPos**](/windows/desktop/api/Winuser/nf-winuser-getscrollpos), and [**GetScrollRange**](/windows/desktop/api/Winuser/nf-winuser-getscrollrange) functions support 32-bit scroll bar position data, there is a way to circumvent the 16-bit barrier of the **WM\_HSCROLL** and [**WM\_VSCROLL**](wm-vscroll.md) messages. See **GetScrollInfo** for a description of the technique.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/Controls/wm-hscroll#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_VSCROLL">
            <summary>The WM\_VSCROLL message is sent to a window when a scroll event occurs in the window's standard vertical scroll bar.</summary>
            <returns>If an application processes this message, it should return zero.</returns>
            <remarks>
            <para>The SB\_THUMBTRACK request code is typically used by applications that provide feedback as the user drags the scroll box. If an application scrolls the content of the window, it must also reset the position of the scroll box by using the [**SetScrollPos**](/windows/desktop/api/Winuser/nf-winuser-setscrollpos) function. Note that the **WM\_VSCROLL** message carries only 16 bits of scroll box position data. Thus, applications that rely solely on **WM\_VSCROLL** (and [**WM\_HSCROLL**](wm-hscroll.md)) for scroll position data have a practical maximum position value of 65,535. However, because the [**SetScrollInfo**](/windows/desktop/api/Winuser/nf-winuser-setscrollinfo), [**SetScrollPos**](/windows/desktop/api/Winuser/nf-winuser-setscrollpos), [**SetScrollRange**](/windows/desktop/api/Winuser/nf-winuser-setscrollrange), [**GetScrollInfo**](/windows/desktop/api/Winuser/nf-winuser-getscrollinfo), [**GetScrollPos**](/windows/desktop/api/Winuser/nf-winuser-getscrollpos), and [**GetScrollRange**](/windows/desktop/api/Winuser/nf-winuser-getscrollrange) functions support 32-bit scroll bar position data, there is a way to circumvent the 16-bit barrier of the [**WM\_HSCROLL**](wm-hscroll.md) and **WM\_VSCROLL** messages. See **GetScrollInfo** for a description of the technique.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/Controls/wm-vscroll#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_INITMENU">
            <summary>Sent when a menu is about to become active.</summary>
            <returns>If an application processes this message, it should return zero.</returns>
            <remarks>A **WM\_INITMENU** message is sent only when a menu is first accessed; only one **WM\_INITMENU** message is generated for each access. For example, moving the mouse across several menu items while holding down the button does not generate new messages. **WM\_INITMENU** does not provide information about menu items.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_INITMENUPOPUP">
            <summary>WM_INITMENUPOPUP message - Sent when a drop-down menu or submenu is about to become active. This allows an application to modify the menu before it is displayed, without changing the entire menu.</summary>
            <returns>If an application processes this message, it should return zero.</returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/menurc/wm-initmenupopup">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_GESTURE">
            <summary>Passes information about a gesture.</summary>
            <returns>
            <para>If an application processes this message, it should return 0. If the application does not process the message, it must call [DefWindowProc](/windows/win32/api/winuser/nf-winuser-defwindowproca). Not doing so will cause the application to leak memory because the touch input handle will not be closed and associated process memory will not be freed.</para>
            </returns>
            <remarks>
            <para>The following table lists the supported gesture commands.</para>
            <para>| Gesture ID            | Value (*dwID*) | Description                                                                                                                                                                                                                                                                          | |-----------------------|----------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------| | **GID\_BEGIN**        | 1              | Indicates a generic gesture is beginning.                                                                                                                                                                                                                                            | | **GID\_END**          | 2              | Indicates a generic gesture end.                                                                                                                                                                                                                                                     | | **GID\_ZOOM**         | 3              | Indicates zoom start, zoom move, or zoom stop. The first **GID\_ZOOM** command message begins a zoom but does not cause any zooming. The second **GID\_ZOOM** command triggers a zoom relative to the state contained in the first **GID\_ZOOM**.                                    | | **GID\_PAN**          | 4              | Indicates pan move or pan start. The first **GID\_PAN** command indicates a pan start but does not perform any panning. With the second **GID\_PAN** command message, the application will begin panning.                                                                            | | **GID\_ROTATE**       | 5              | Indicates rotate move or rotate start. The first **GID\_ROTATE** command message indicates a rotate move or rotate start but will not rotate. The second **GID\_ROTATE** command message will trigger a rotation operation relative to state contained in the first **GID\_ROTATE**. | | **GID\_TWOFINGERTAP** | 6              | Indicates two-finger tap gesture.                                                                                                                                                                                                                                                    | | **GID\_PRESSANDTAP**  | 7              | Indicates the press and tap gesture.                                                                                                                                                                                                                                                 |</para>
            <para>> [!Note] > In order to enable legacy support, messages with the **GID\_BEGIN** and **GID\_END** gesture commands need to be forwarded using [DefWindowProc](/windows/win32/api/winuser/nf-winuser-defwindowproca).</para>
            <para>The following table indicates the gesture arguments passed in the *lParam* and *wParam* parameters.</para>
            <para>| Gesture ID            | Gesture        | *ullArgument*                                                                                                                                                                                                                                                                                                                                                                                            | *ptsLocation* in [**GestureInfo**](/windows/desktop/api/winuser/nf-winuser-getgestureinfo) structure                                                  | |-----------------------|----------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-------------------------------------------------------------------------------------------------------------------| | **GID\_ZOOM**         | Zoom In/Out    | Indicates the distance between the two points.                                                                                                                                                                                                                                                                                                                                                           | Indicates the center of the zoom.                                                                                 | | **GID\_PAN**          | Pan            | Indicates the distance between the two points.                                                                                                                                                                                                                                                                                                                                                           | Indicates the current position of the pan.                                                                        | | **GID\_ROTATE**       | Rotate (pivot) | Indicates the angle of rotation if the **GF\_BEGIN** flag is set. Otherwise, this is the angle change since the rotation has started. This is signed to indicate the direction of the rotation. Use the [**GID\_ROTATE\_ANGLE\_FROM\_ARGUMENT**](/windows/desktop/api/winuser/nf-winuser-gid_rotate_angle_from_argument) and [**GID\_ROTATE\_ANGLE\_TO\_ARGUMENT**](/windows/desktop/api/winuser/nf-winuser-gid_rotate_angle_to_argument) macros to get and set the angle value. | This indicates the center of the rotation which is the stationary point that the target object is rotated around. | | **GID\_TWOFINGERTAP** | Two-finger Tap | Indicates the distance between the two fingers.                                                                                                                                                                                                                                                                                                                                                          | Indicates the center of the two fingers.                                                                          | | **GID\_PRESSANDTAP**  | Press and Tap  | Indicates the delta between the first finger and the second finger. This value is stored in the lower 32 bits of the *ullArgument* in a **POINT** structure.                                                                                                                                                                                                                                             | Indicates the position that the first finger comes down on.                                                       |</para>
            <para>> [!Note] > All distances and positions are provided in physical screen coordinates.</para>
            <para>> [!Note] > The *dwID* and *ullArgument* parameters should only be considered to be accompanying the GID\_\* commands and should not be altered by applications.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/wintouch/wm-gesture#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_GESTURENOTIFY">
            <summary>Gives you a chance to set the gesture configuration.</summary>
            <returns>A value should be returned from [DefWindowProc](/windows/win32/api/winuser/nf-winuser-defwindowproca).</returns>
            <remarks>
            <para>When the **WM\_GESTURENOTIFY** message is received, the application can use [**SetGestureConfig**](/windows/desktop/api/winuser/nf-winuser-setgestureconfig) to specify the gestures to receive. This message should always be bubbled up using the [DefWindowProc](/windows/win32/api/winuser/nf-winuser-defwindowproca) function. > [!Note] > Handling the **WM\_GESTURENOTIFY** message will change the gesture configuration for the lifetime of the Window, not just for the next gesture.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/wintouch/wm-gesturenotify#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_MENUSELECT">
            <summary>Sent to a menu's owner window when the user selects a menu item.</summary>
            <returns>If an application processes this message, it should return zero.</returns>
            <remarks>
            <para>If the high-order word of *wParam* contains 0xFFFF and the *lParam* parameter contains **NULL**, the system has closed the menu. Do not use the value  1 for the high-order word of *wParam*, because this value is specified as (**UINT**) [**HIWORD**](/previous-versions/windows/desktop/legacy/ms632657(v=vs.85))(*wParam*). If the value is 0xFFFF, it would be interpreted as 0x0000FFFF, not  1, because of the cast to a **UINT**.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/menurc/wm-menuselect#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_MENUCHAR">
            <summary>Sent when a menu is active and the user presses a key that does not correspond to any mnemonic or accelerator key. This message is sent to the window that owns the menu.</summary>
            <returns>
            <para>An application that processes this message should return one of the following values in the high-order word of the return value.</para>
            <para>| Return code/value                                                                                                                                  | Description                                                                                                                                                                              | |----------------------------------------------------------------------------------------------------------------------------------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------| | <dl> <dt>**MNC\_CLOSE**</dt> <dt>1</dt> </dl>   | Informs the system that it should close the active menu.<br/>                                                                                                                      | | <dl> <dt>**MNC\_EXECUTE**</dt> <dt>2</dt> </dl> | Informs the system that it should choose the item specified in the low-order word of the return value. The owner window receives a [**WM\_COMMAND**](wm-command.md) message.<br/> | | <dl> <dt>**MNC\_IGNORE**</dt> <dt>0</dt> </dl>  | Informs the system that it should discard the character the user pressed and create a short beep on the system speaker.<br/>                                                       | | <dl> <dt>**MNC\_SELECT**</dt> <dt>3</dt> </dl>  | Informs the system that it should select the item specified in the low-order word of the return value. <br/>                                                                       |</para>
            </returns>
            <remarks>
            <para>The low-order word is ignored if the high-order word contains 0 or 1. An application should process this message when an accelerator is used to select a menu item that displays a bitmap.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/menurc/wm-menuchar#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_ENTERIDLE">
            <summary>Sent to the owner window of a modal dialog box or menu that is entering an idle state. A modal dialog box or menu enters an idle state when no messages are waiting in its queue after it has processed one or more previous messages.</summary>
            <returns>An application should return zero if it processes this message.</returns>
            <remarks>You can suppress the **WM\_ENTERIDLE** message for a dialog box by creating the dialog box with the **DS\_NOIDLEMSG** style.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_MENURBUTTONUP">
            <summary>Sent when the user releases the right mouse button while the cursor is on a menu item.</summary>
            <remarks>The **WM\_MENURBUTTONUP** message allows applications to provide a context-sensitive menu also known as a shortcut menu for the menu item specified in this message. To display a context-sensitive menu for a menu item, call the [**TrackPopupMenuEx**](/windows/desktop/api/Winuser/nf-winuser-trackpopupmenuex) function with **TPM\_RECURSE**.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_MENUDRAG">
            <summary>Sent to the owner of a drag-and-drop menu when the user drags a menu item.</summary>
            <returns>
            <para>The application should return one of the following values.</para>
            <para>| Return code/value                                                                                                                                   | Description                                                                           | |-----------------------------------------------------------------------------------------------------------------------------------------------------|---------------------------------------------------------------------------------------| | <dl> <dt>**MND\_CONTINUE**</dt> <dt>0</dt> </dl> | Menu should remain active. If the mouse is released, it should be ignored.<br/> | | <dl> <dt>**MND\_ENDMENU**</dt> <dt>1</dt> </dl>  | Menu should be ended.<br/>                                                      |</para>
            </returns>
            <remarks>
            <para>The application can call the [**DoDragDrop**](/windows/win32/api/ole2/nf-ole2-dodragdrop) function in response to this message. To create a drag-and-drop menu, call [**SetMenuInfo**](/windows/desktop/api/Winuser/nf-winuser-setmenuinfo) with **MNS\_DRAGDROP**.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/menurc/wm-menudrag#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_MENUGETOBJECT">
            <summary>Sent to the owner of a drag-and-drop menu when the mouse cursor enters a menu item or moves from the center of the item to the top or bottom of the item.</summary>
            <returns>
            <para>The application should return one of the following values.</para>
            <para>| Return code/value                                                                                                                                                | Description                                                                                                            | |------------------------------------------------------------------------------------------------------------------------------------------------------------------|------------------------------------------------------------------------------------------------------------------------| | <dl> <dt>**MNGO\_NOERROR**</dt> <dt>0x00000001</dt> </dl>     | An interface pointer was returned in the **pvObj** member of [**MENUGETOBJECTINFO**](/windows/win32/api/winuser/ns-winuser-menugetobjectinfo)<br/> | | <dl> <dt>**MNGO\_NOINTERFACE**</dt> <dt>0x00000000</dt> </dl> | The interface is not supported.<br/>                                                                             |</para>
            </returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/menurc/wm-menugetobject">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_UNINITMENUPOPUP">
            <summary>Sent when a drop-down menu or submenu has been destroyed.</summary>
            <remarks>If an application receives a [**WM\_INITMENUPOPUP**](wm-initmenupopup.md) message, it will receive a **WM\_UNINITMENUPOPUP** message.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_MENUCOMMAND">
            <summary>Sent when the user makes a selection from a menu.</summary>
            <remarks>
            <para>The **WM\_MENUCOMMAND** message gives you a handle to the menu so you can access the menu data in the [**MENUINFO**](/windows/win32/api/winuser/ns-winuser-menuinfo) structure and also gives you the index of the selected item, which is typically what applications need. In contrast, the [**WM\_COMMAND**](wm-command.md) message gives you the menu item identifier. The **WM\_MENUCOMMAND** message is sent only for menus that are defined with the **MNS\_NOTIFYBYPOS** flag set in the **dwStyle** member of the [**MENUINFO**](/windows/win32/api/winuser/ns-winuser-menuinfo) structure.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/menurc/wm-menucommand#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_CHANGEUISTATE">
            <summary>An application sends the WM\_CHANGEUISTATE message to indicate that the UI state should be changed.</summary>
            <remarks>
            <para>A window should send this message to itself or its parent when it must change the UI state elements of all windows in the same hierarchy. The window procedure must let [**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowproca) process this message so that the entire window tree has a consistent UI state. When the top-level window receives the **WM\_CHANGEUISTATE** message, it sends a [**WM\_UPDATEUISTATE**](wm-updateuistate.md) message with the same parameters to all child windows. When the system processes the **WM\_UPDATEUISTATE** message, it makes the change in the UI state. If the low-order word of *wParam* is UIS\_INITIALIZE, the system will send the [**WM\_UPDATEUISTATE**](wm-updateuistate.md) message with a UI state based on the last input event. For example, if the last input came from the mouse, the system will hide the keyboard cues. And, if the last input came from the keyboard, the system will show the keyboard cues. If the state that results from processing **WM\_CHANGEUISTATE** is the same as the old state, [**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowproca) does not send this message.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/menurc/wm-changeuistate#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_UPDATEUISTATE">
            <summary>An application sends the WM\_UPDATEUISTATE message to change the UI state for the specified window and all its child windows.</summary>
            <remarks>
            <para>A window should send this message to change the UI state of all its child windows. In contrast to the [**WM\_CHANGEUISTATE**](wm-changeuistate.md) message, which is a notification, when [**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowproca) processes the **WM\_UPDATEUISTATE** message it changes the UI state and propagates the changes to all child windows. The [**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowproca) function updates the UI state according to the *wParam* value. If the UI state is modified, the function sends the message to all the immediate child windows. **DefWindowProc** also sends this message when it receives a [**WM\_CHANGEUISTATE**](wm-changeuistate.md) message notifying the system that a child window intends to modify the UI state.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/menurc/wm-updateuistate#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_QUERYUISTATE">
            <summary>An application sends the WM\_QUERYUISTATE message to retrieve the UI state for a window.</summary>
            <returns>
            <para>The return value is **NULL** if the focus indicators and the keyboard accelerators are visible. Otherwise, the return value can be one or more of the following values.</para>
            <para>| Return code/value                                                                                                                                       | Description                                                                 | |---------------------------------------------------------------------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------| | <dl> <dt>**UISF\_ACTIVE**</dt> <dt>0x4</dt> </dl>    | A control should be drawn in the style used for active controls.<br/> | | <dl> <dt>**UISF\_HIDEACCEL**</dt> <dt>0x2</dt> </dl> | Keyboard accelerators are hidden.<br/>                                | | <dl> <dt>**UISF\_HIDEFOCUS**</dt> <dt>0x1</dt> </dl> | Focus indicators are hidden.<br/>                                     |</para>
            </returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/menurc/wm-queryuistate">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_CTLCOLOREDIT">
            <summary>An edit control that is not read-only or disabled sends the WM\_CTLCOLOREDIT message to its parent window when the control is about to be drawn.</summary>
            <returns>If an application processes this message, it must return the handle of a brush. The system uses the brush to paint the background of the edit control.</returns>
            <remarks>
            <para>If the application returns a brush that it created (for example, by using the [**CreateSolidBrush**](/windows/desktop/api/wingdi/nf-wingdi-createsolidbrush) or [**CreateBrushIndirect**](/windows/desktop/api/wingdi/nf-wingdi-createbrushindirect) function), the application must free the brush. If the application returns a system brush (for example, one that was retrieved by the [**GetStockObject**](/windows/desktop/api/wingdi/nf-wingdi-getstockobject) or [**GetSysColorBrush**](/windows/desktop/api/winuser/nf-winuser-getsyscolorbrush) function), the application does not need to free the brush. By default, the [**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowproca) function selects the default system colors for the edit control. Read-only or disabled edit controls do not send the **WM\_CTLCOLOREDIT** message; instead, they send the [**WM\_CTLCOLORSTATIC**](wm-ctlcolorstatic.md) message. The **WM\_CTLCOLOREDIT** message is never sent between threads, it is only sent within the same thread. If a dialog box procedure handles this message, it should cast the desired return value to a **INT\_PTR** and return the value directly. If the dialog box procedure returns **FALSE**, then default message handling is performed. The DWL\_MSGRESULT value set by the [**SetWindowLong**](/windows/desktop/api/winuser/nf-winuser-setwindowlonga) function is ignored. **Rich Edit:** This message is not supported. To set the background color for a rich edit control, use the [**EM\_SETBKGNDCOLOR**](em-setbkgndcolor.md) message.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/Controls/wm-ctlcoloredit#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_CTLCOLORLISTBOX">
            <summary>Sent to the parent window of a list box before the system draws the list box. By responding to this message, the parent window can set the text and background colors of the list box by using the specified display device context handle.</summary>
            <returns>If an application processes this message, it must return a handle to a brush. The system uses the brush to paint the background of the list box.</returns>
            <remarks>
            <para>By default, the [**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowproca) function selects the default system colors for the list box. The **WM\_CTLCOLORLISTBOX** message is never sent between threads. It is sent only within one thread. If a dialog box procedure handles this message, it should cast the desired return value to a **INT\_PTR** and return the value directly. If the dialog box procedure returns **FALSE**, then default message handling is performed. The **DWL\_MSGRESULT** value set by the [**SetWindowLong**](/windows/desktop/api/winuser/nf-winuser-setwindowlonga) function is ignored.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/Controls/wm-ctlcolorlistbox#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_CTLCOLORBTN">
            <summary>The WM\_CTLCOLORBTN message is sent to the parent window of a button before drawing the button. The parent window can change the button's text and background colors. However, only owner-drawn buttons respond to the parent window processing this message.</summary>
            <returns>If an application processes this message, it must return a handle to a brush. The system uses the brush to paint the background of the button.</returns>
            <remarks>
            <para>If the application returns a brush that it created (for example, by using the [**CreateSolidBrush**](/windows/desktop/api/wingdi/nf-wingdi-createsolidbrush) or [**CreateBrushIndirect**](/windows/desktop/api/wingdi/nf-wingdi-createbrushindirect) function), the application must free the brush. If the application returns a system brush (for example, one that was retrieved by the [**GetStockObject**](/windows/desktop/api/wingdi/nf-wingdi-getstockobject) or [**GetSysColorBrush**](/windows/desktop/api/winuser/nf-winuser-getsyscolorbrush) function), the application does not need to free the brush. By default, the [**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowproca) function selects the default system colors for the button. Buttons with the [**BS\_PUSHBUTTON**](button-styles.md), [**BS\_DEFPUSHBUTTON**](button-styles.md), or [**BS\_PUSHLIKE**](button-styles.md) styles do not use the returned brush. Buttons with these styles are always drawn with the default system colors. Drawing push buttons requires several different brushes-face, highlight, and shadow-but the **WM\_CTLCOLORBTN** message allows only one brush to be returned. To provide a custom appearance for push buttons, use an owner-drawn button. For more information, see [Creating Owner-Drawn Controls](user-controls-intro.md). The **WM\_CTLCOLORBTN** message is never sent between threads. It is sent only within one thread. The text color of a check box or radio button applies to the box or button, its check mark, and the text. The focus rectangle for these buttons remains the system default color (typically black). The text color of a group box applies to the text but not to the line that defines the box. The text color of a push button applies only to its focus rectangle; it does not affect the color of the text. If a dialog box procedure handles this message, it should cast the desired return value to a **INT\_PTR** and return the value directly. If the dialog box procedure returns **FALSE**, then default message handling is performed. The DWL\_MSGRESULT value set by the [**SetWindowLong**](/windows/desktop/api/winuser/nf-winuser-setwindowlonga) function is ignored.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/Controls/wm-ctlcolorbtn#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_CTLCOLORDLG">
            <summary>Sent to a dialog box before the system draws the dialog box. By responding to this message, the dialog box can set its text and background colors using the specified display device context handle.</summary>
            <returns>If an application processes this message, it must return a handle to a brush. The system uses the brush to paint the background of the dialog box.</returns>
            <remarks>
            <para>By default, the [**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowproca) function selects the default system colors for the dialog box. The system does not automatically destroy the returned brush. It is the application's responsibility to destroy the brush when it is no longer needed. The **WM\_CTLCOLORDLG** message is never sent between threads. It is sent only within one thread. Note that the **WM\_CTLCOLORDLG** message is sent to the dialog box itself; all of the other **WM\_CTLCOLOR\*** messages are sent to the owner of the control. If a dialog box procedure handles this message, it should cast the desired return value to an **INT\_PTR** and return the value directly. If the dialog box procedure returns **FALSE**, then default message handling is performed. The **DWL\_MSGRESULT** value set by the [**SetWindowLong**](/windows/desktop/api/winuser/nf-winuser-setwindowlonga) function is ignored.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/dlgbox/wm-ctlcolordlg#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_CTLCOLORSCROLLBAR">
            <summary>The WM\_CTLCOLORSCROLLBAR message is sent to the parent window of a scroll bar control when the control is about to be drawn.</summary>
            <returns>If an application processes this message, it must return the handle to a brush. The system uses the brush to paint the background of the scroll bar control.</returns>
            <remarks>
            <para>If the application returns a brush that it created (for example, by using the [**CreateSolidBrush**](/windows/desktop/api/wingdi/nf-wingdi-createsolidbrush) or [**CreateBrushIndirect**](/windows/desktop/api/wingdi/nf-wingdi-createbrushindirect) function), the application must free the brush. If the application returns a system brush (for example, one that was retrieved by the [**GetStockObject**](/windows/desktop/api/wingdi/nf-wingdi-getstockobject) or [**GetSysColorBrush**](/windows/desktop/api/winuser/nf-winuser-getsyscolorbrush) function), the application does not need to free the brush. By default, the [**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowproca) function selects the default system colors for the scroll bar control. The **WM\_CTLCOLORSCROLLBAR** message is never sent between threads; it is only sent within the same thread. If a dialog box procedure handles this message, it should cast the desired return value to a **INT\_PTR** and return the value directly. If the dialog box procedure returns **FALSE**, then default message handling is performed. The DWL\_MSGRESULT value set by the [**SetWindowLong**](/windows/desktop/api/winuser/nf-winuser-setwindowlonga) function is ignored. The **WM\_CTLCOLORSCROLLBAR** message is used only by child scroll bar controls. Scrollbars attached to a window (WS\_SCROLL and WS\_VSCROLL) do not generate this message. To customize the appearance of scrollbars attached to a window, use the flat scroll bar functions.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/Controls/wm-ctlcolorscrollbar#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_CTLCOLORSTATIC">
            <summary>A static control, or an edit control that is read-only or disabled, sends the WM\_CTLCOLORSTATIC message to its parent window when the control is about to be drawn.</summary>
            <returns>If an application processes this message, the return value is a handle to a brush that the system uses to paint the background of the static control.</returns>
            <remarks>
            <para>If the application returns a brush that it created (for example, by using the [**CreateSolidBrush**](/windows/desktop/api/wingdi/nf-wingdi-createsolidbrush) or [**CreateBrushIndirect**](/windows/desktop/api/wingdi/nf-wingdi-createbrushindirect) function), the application must free the brush. If the application returns a system brush (for example, one that was retrieved by the [**GetStockObject**](/windows/desktop/api/wingdi/nf-wingdi-getstockobject) or [**GetSysColorBrush**](/windows/desktop/api/winuser/nf-winuser-getsyscolorbrush) function), the application does not need to free the brush. By default, the [**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowproca) function selects the default system colors for the static control. You can set the text background color of a disabled edit control, but you cannot set the text foreground color. The system always uses COLOR\_GRAYTEXT. Edit controls that are not read-only or disabled do not send the **WM\_CTLCOLORSTATIC** message; instead, they send the [**WM\_CTLCOLOREDIT**](wm-ctlcoloredit.md) message. The **WM\_CTLCOLORSTATIC** message is never sent between threads; it is sent only within the same thread. If a dialog box procedure handles this message, it should cast the desired return value to a **INT\_PTR** and return the value directly. If the dialog box procedure returns **FALSE**, then default message handling is performed. The DWL\_MSGRESULT value set by the [**SetWindowLong**](/windows/desktop/api/winuser/nf-winuser-setwindowlonga) function is ignored.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/Controls/wm-ctlcolorstatic#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_MOUSEMOVE">
            <summary>Posted to a window when the cursor moves. If the mouse is not captured, the message is posted to the window that contains the cursor. Otherwise, the message is posted to the window that has captured the mouse.</summary>
            <returns>If an application processes this message, it should return zero.</returns>
            <remarks>
            <para>Use the following code to obtain the horizontal and vertical position:</para>
            <para></para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/inputdev/wm-mousemove#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <!-- Badly formed XML comment ignored for member "F:Windows.Win32.PInvoke.WM_LBUTTONDOWN" -->
        <member name="F:Windows.Win32.PInvoke.WM_LBUTTONUP">
            <summary>Posted when the user releases the left mouse button while the cursor is in the client area of a window.</summary>
            <returns>If an application processes this message, it should return zero.</returns>
            <remarks>
            <para>Use the following code to obtain the horizontal and vertical position:</para>
            <para></para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/inputdev/wm-lbuttonup#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_LBUTTONDBLCLK">
            <summary>Posted when the user double-clicks the left mouse button while the cursor is in the client area of a window.</summary>
            <returns>If an application processes this message, it should return zero.</returns>
            <remarks>
            <para>Use the following code to obtain the horizontal and vertical position:</para>
            <para></para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/inputdev/wm-lbuttondblclk#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_RBUTTONDOWN">
            <summary>Posted when the user presses the right mouse button while the cursor is in the client area of a window.</summary>
            <returns>If an application processes this message, it should return zero.</returns>
            <remarks>
            <para>Use the following code to obtain the horizontal and vertical position:</para>
            <para></para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/inputdev/wm-rbuttondown#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_RBUTTONUP">
            <summary>Posted when the user releases the right mouse button while the cursor is in the client area of a window.</summary>
            <returns>If an application processes this message, it should return zero.</returns>
            <remarks>
            <para>Use the following code to obtain the horizontal and vertical position:</para>
            <para></para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/inputdev/wm-rbuttonup#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_RBUTTONDBLCLK">
            <summary>Posted when the user double-clicks the right mouse button while the cursor is in the client area of a window.</summary>
            <returns>If an application processes this message, it should return zero.</returns>
            <remarks>
            <para>Only windows that have the **CS\_DBLCLKS** style can receive **WM\_RBUTTONDBLCLK** messages, which the system generates whenever the user presses, releases, and again presses the right mouse button within the system's double-click time limit. Double-clicking the right mouse button actually generates four messages: [**WM\_RBUTTONDOWN**](wm-rbuttondown.md), [**WM\_RBUTTONUP**](wm-rbuttonup.md), **WM\_RBUTTONDBLCLK**, and **WM\_RBUTTONUP** again. Use the following code to obtain the horizontal and vertical position:</para>
            <para></para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/inputdev/wm-rbuttondblclk#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_MBUTTONDOWN">
            <summary>Posted when the user presses the middle mouse button while the cursor is in the client area of a window.</summary>
            <returns>If an application processes this message, it should return zero.</returns>
            <remarks>
            <para>Use the following code to obtain the horizontal and vertical position:</para>
            <para></para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/inputdev/wm-mbuttondown#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_MBUTTONUP">
            <summary>Posted when the user releases the middle mouse button while the cursor is in the client area of a window.</summary>
            <returns>If an application processes this message, it should return zero.</returns>
            <remarks>
            <para>Use the following code to obtain the horizontal and vertical position:</para>
            <para></para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/inputdev/wm-mbuttonup#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_MBUTTONDBLCLK">
            <summary>Posted when the user double-clicks the middle mouse button while the cursor is in the client area of a window.</summary>
            <returns>If an application processes this message, it should return zero.</returns>
            <remarks>
            <para>Use the following code to obtain the horizontal and vertical position:</para>
            <para></para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/inputdev/wm-mbuttondblclk#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_MOUSEWHEEL">
            <summary>Sent to the focus window when the mouse wheel is rotated.</summary>
            <returns>If an application processes this message, it should return zero.</returns>
            <remarks>
            <para>Use the following code to get the information in the *wParam* parameter:</para>
            <para></para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/inputdev/wm-mousewheel#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_XBUTTONDOWN">
            <summary>Posted when the user presses the first or second X button while the cursor is in the client area of a window.</summary>
            <returns>If an application processes this message, it should return **TRUE**. For more information about processing the return value, see the Remarks section.</returns>
            <remarks>
            <para>Use the following code to get the information in the *wParam* parameter:</para>
            <para></para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/inputdev/wm-xbuttondown#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_XBUTTONUP">
            <summary>Posted when the user releases the first or second X button while the cursor is in the client area of a window.</summary>
            <returns>If an application processes this message, it should return **TRUE**. For more information about processing the return value, see the Remarks section.</returns>
            <remarks>
            <para>Use the following code to get the information in the *wParam* parameter:</para>
            <para></para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/inputdev/wm-xbuttonup#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_XBUTTONDBLCLK">
            <summary>Posted when the user double-clicks the first or second X button while the cursor is in the client area of a window.</summary>
            <returns>If an application processes this message, it should return **TRUE**. For more information about processing the return value, see the Remarks section.</returns>
            <remarks>
            <para>Use the following code to get the information in the *wParam* parameter:</para>
            <para></para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/inputdev/wm-xbuttondblclk#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_MOUSEHWHEEL">
            <summary>Sent to the active window when the mouse's horizontal scroll wheel is tilted or rotated.</summary>
            <returns>If an application processes this message, it should return zero.</returns>
            <remarks>
            <para>Use the following code to obtain the information in the *wParam* parameter.</para>
            <para></para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/inputdev/wm-mousehwheel#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_PARENTNOTIFY">
            <summary>Sent to a window when a significant action occurs on a descendant window.</summary>
            <returns>
            <para>If the application processes this message, it returns zero. If the application does not process this message, it calls [**DefWindowProc**](/windows/win32/api/winuser/nf-winuser-defwindowproca).</para>
            </returns>
            <remarks>
            <para>This message is also sent to all ancestor windows of the child window, including the top-level window. All child windows, except those that have the **WS_EX_NOPARENTNOTIFY** extended window style, send this message to their parent windows. By default, child windows in a dialog box have the **WS_EX_NOPARENTNOTIFY** style, unless the [**CreateWindowEx**](/windows/win32/api/winuser/nf-winuser-createwindowexa) function is called to create the child window without this style. This notification provides the child window's ancestor windows an opportunity to examine the pointer information and, if required, capture the pointer using the pointer capture functions.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/inputmsg/wm-parentnotify#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_ENTERMENULOOP">
            <summary>Notifies an application's main window procedure that a menu modal loop has been entered.</summary>
            <returns>An application should return zero if it processes this message.</returns>
            <remarks>The [**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowproca) function returns zero.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_EXITMENULOOP">
            <summary>Notifies an application's main window procedure that a menu modal loop has been exited.</summary>
            <returns>An application should return zero if it processes this message.</returns>
            <remarks>The [**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowproca) function returns zero.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_NEXTMENU">
            <summary>Sent to an application when the right or left arrow key is used to switch between the menu bar and the system menu.</summary>
            <remarks>In responding to this message, the application can specify the menu to switch to in the **hmenuNext** member of [**MDINEXTMENU**](/windows/win32/api/winuser/ns-winuser-mdinextmenu) and the window to receive the menu notification messages in the **hwndNext** member of the **MDINEXTMENU** structure. You must set both members for the changes to take effect (they are initially **NULL**).</remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_SIZING">
            <summary>Sent to a window that the user is resizing. By processing this message, an application can monitor the size and position of the drag rectangle and, if needed, change its size or position.</summary>
            <returns>
            <para>Type: **LRESULT** An application should return **TRUE** if it processes this message.</para>
            </returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/winmsg/wm-sizing">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_CAPTURECHANGED">
            <summary>Sent to the window that is losing the mouse capture.</summary>
            <returns>An application should return zero if it processes this message.</returns>
            <remarks>
            <para>A window receives this message even if it calls [**ReleaseCapture**](/windows/win32/api/winuser/nf-winuser-releasecapture) itself. An application should not attempt to set the mouse capture in response to this message. When it receives this message, a window should redraw itself, if necessary, to reflect the new mouse-capture state.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/inputdev/wm-capturechanged#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_MOVING">
            <summary>Sent to a window that the user is moving. By processing this message, an application can monitor the position of the drag rectangle and, if needed, change its position.</summary>
            <returns>
            <para>Type: **LRESULT** An application should return **TRUE** if it processes this message.</para>
            </returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/winmsg/wm-moving">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_POWERBROADCAST">
            <summary>Notifies applications that a power-management event has occurred.</summary>
            <returns>An application should return **TRUE** if it processes this message.</returns>
            <remarks>
            <para>The system always sends a [PBT\_APMRESUMEAUTOMATIC](pbt-apmresumeautomatic.md) message whenever the system resumes. If the system resumes in response to user input such as pressing a key, the system also sends a **PBT\_APMRESUMESUSPEND** message after sending PBT\_APMRESUMEAUTOMATIC. **WM\_POWERBROADCAST** messages do not distinguish between different low-power states. An application can determine only that the system is entering or has resumed from a low-power state; it cannot determine the specific power state. The system records details about power state transitions in the Windows System event log. To prevent the system from transitioning to a low-power state in Windows Vista, an application must call [**SetThreadExecutionState**](/windows/desktop/api/Winbase/nf-winbase-setthreadexecutionstate) to inform the system that it is in use. The following messages are not supported on any of the operating systems specified in the Requirements section: - PBT_APMQUERYSTANDBY - PBT_APMQUERYSTANDBYFAILED - PBT_APMSTANDBY - PBT_APMRESUMESTANDBY</para>
            <para><see href="https://learn.microsoft.com/windows/win32/Power/wm-powerbroadcast#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_MDICREATE">
            <summary>An application sends the WM\_MDICREATE message to a multiple-document interface (MDI) client window to create an MDI child window.</summary>
            <returns>
            <para>Type: **HWND** If the message succeeds, the return value is the handle to the new child window. If the message fails, the return value is **NULL**.</para>
            </returns>
            <remarks>
            <para>The MDI child window is created with the [**window style**](window-styles.md) bits **WS\_CHILD**, **WS\_CLIPSIBLINGS**, **WS\_CLIPCHILDREN**, **WS\_SYSMENU**, **WS\_CAPTION**, **WS\_THICKFRAME**, **WS\_MINIMIZEBOX**, and **WS\_MAXIMIZEBOX**, plus additional style bits specified in the [**MDICREATESTRUCT**](/windows/win32/api/winuser/ns-winuser-mdicreatestructa) structure. The system adds the title of the new child window to the window menu of the frame window. An application should use this message to create all child windows of the client window. If an MDI client window receives any message that changes the activation of its child windows while the active child window is maximized, the system restores the active child window and maximizes the newly activated child window. When an MDI child window is created, the system sends the [**WM\_CREATE**](wm-create.md) message to the window. The *lParam* parameter of the **WM\_CREATE** message contains a pointer to a [**CREATESTRUCT**](/windows/win32/api/winuser/ns-winuser-createstructa) structure. The *lpCreateParams* member of this structure contains a pointer to the [**MDICREATESTRUCT**](/windows/win32/api/winuser/ns-winuser-mdicreatestructa) structure passed with the **WM\_MDICREATE** message that created the MDI child window. An application should not send a second **WM\_MDICREATE** message while a **WM\_MDICREATE** message is still being processed. For example, it should not send a **WM\_MDICREATE** message while an MDI child window is processing its **WM\_MDICREATE** message.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/winmsg/wm-mdicreate#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_MDIDESTROY">
            <summary>An application sends the WM\_MDIDESTROY message to a multiple-document interface (MDI) client window to close an MDI child window.</summary>
            <returns>
            <para>Type: **zero** This message always returns zero.</para>
            </returns>
            <remarks>
            <para>This message removes the title of the MDI child window from the MDI frame window and deactivates the child window. An application should use this message to close all MDI child windows. If an MDI client window receives a message that changes the activation of its child windows and the active MDI child window is maximized, the system restores the active child window and maximizes the newly activated child window.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/winmsg/wm-mdidestroy#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_MDIACTIVATE">
            <summary>An application sends the WM\_MDIACTIVATE message to a multiple-document interface (MDI) client window to instruct the client window to activate a different MDI child window.</summary>
            <returns>
            <para>Type: **LRESULT** If an application sends this message to an MDI client window, the return value is zero. An MDI child window should return zero if it processes this message.</para>
            </returns>
            <remarks>
            <para>As the client window processes this message, it sends **WM\_MDIACTIVATE** to the child window being deactivated and to the child window being activated. The message parameters received by an MDI child window are as follows: <dl> <dt> <span id="wParam"></span><span id="wparam"></span><span id="WPARAM"></span>*wParam* </dt> <dd> A handle to the MDI child window being deactivated. </dd> <dt> <span id="lParam"></span><span id="lparam"></span><span id="LPARAM"></span>*lParam* </dt> <dd> A handle to the MDI child window being activated. </dd> </dl> An MDI child window is activated independently of the MDI frame window. When the frame window becomes active, the child window last activated by using the **WM\_MDIACTIVATE** message receives the [**WM\_NCACTIVATE**](wm-ncactivate.md) message to draw an active window frame and title bar; the child window does not receive another **WM\_MDIACTIVATE** message.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/winmsg/wm-mdiactivate#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_MDIRESTORE">
            <summary>An application sends the WM\_MDIRESTORE message to a multiple-document interface (MDI) client window to restore an MDI child window from maximized or minimized size.</summary>
            <returns>
            <para>Type: **zero** The return value is always zero.</para>
            </returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/winmsg/wm-mdirestore">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_MDINEXT">
            <summary>An application sends the WM\_MDINEXT message to a multiple-document interface (MDI) client window to activate the next or previous child window.</summary>
            <returns>
            <para>Type: **zero** The return value is always zero.</para>
            </returns>
            <remarks>If an MDI client window receives any message that changes the activation of its child windows while the active MDI child window is maximized, the system restores the active child window and maximizes the newly activated child window.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_MDIMAXIMIZE">
            <summary>An application sends the WM\_MDIMAXIMIZE message to a multiple-document interface (MDI) client window to maximize an MDI child window.</summary>
            <returns>
            <para>Type: **zero** The return value is always zero.</para>
            </returns>
            <remarks>If an MDI client window receives any message that changes the activation of its child windows while the currently active MDI child window is maximized, the system restores the active child window and maximizes the newly activated child window.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_MDITILE">
            <summary>An application sends the WM\_MDITILE message to a multiple-document interface (MDI) client window to arrange all of its MDI child windows in a tile format.</summary>
            <returns>
            <para>Type: **BOOL** If the message succeeds, the return value is **TRUE**. If the message fails, the return value is **FALSE**.</para>
            </returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/winmsg/wm-mditile">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_MDICASCADE">
            <summary>An application sends the WM\_MDICASCADE message to a multiple-document interface (MDI) client window to arrange all its child windows in a cascade format.</summary>
            <returns>
            <para>Type: **BOOL** If the message succeeds, the return value is **TRUE**. If the message fails, the return value is **FALSE**.</para>
            </returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/winmsg/wm-mdicascade">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_MDIICONARRANGE">
            <summary>An application sends the WM\_MDIICONARRANGE message to a multiple-document interface (MDI) client window to arrange all minimized MDI child windows. It does not affect child windows that are not minimized.</summary>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/winmsg/wm-mdiiconarrange">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_MDIGETACTIVE">
            <summary>An application sends the WM\_MDIGETACTIVE message to a multiple-document interface (MDI) client window to retrieve the handle to the active MDI child window.</summary>
            <returns>
            <para>Type: **HWND** The return value is the handle to the active MDI child window.</para>
            </returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/winmsg/wm-mdigetactive">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_MDISETMENU">
            <summary>An application sends the WM\_MDISETMENU message to a multiple-document interface (MDI) client window to replace the entire menu of an MDI frame window, to replace the window menu of the frame window, or both.</summary>
            <returns>
            <para>Type: **HMENU** If the message succeeds, the return value is the handle to the old frame window menu. If the message fails, the return value is zero.</para>
            </returns>
            <remarks>
            <para>After sending this message, an application must call the [**DrawMenuBar**](/windows/win32/api/winuser/nf-winuser-drawmenubar) function to update the menu bar. If this message replaces the window menu, the MDI child window menu items are removed from the previous window menu and added to the new window menu. If an MDI child window is maximized and this message replaces the MDI frame window menu, the window menu icon and restore icon are removed from the previous frame window menu and added to the new frame window menu.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/winmsg/wm-mdisetmenu#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_ENTERSIZEMOVE">
            <summary>Sent one time to a window after it enters the moving or sizing modal loop.</summary>
            <returns>
            <para>Type: **LRESULT** An application should return zero if it processes this message.</para>
            </returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/winmsg/wm-entersizemove">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_EXITSIZEMOVE">
            <summary>Sent one time to a window, after it has exited the moving or sizing modal loop.</summary>
            <returns>
            <para>Type: **LRESULT** An application should return zero if it processes this message.</para>
            </returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/winmsg/wm-exitsizemove">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_DROPFILES">
            <summary>Sent when the user drops a file on the window of an application that has registered itself as a recipient of dropped files.</summary>
            <returns>An application should return zero if it processes this message.</returns>
            <remarks>The HDROP handle is declared in Shellapi.h. You must include this header in your build to use **WM\_DROPFILES**. For further discussion of how to use drag-and-drop to transfer Shell data, see [Transferring Shell Data Using Drag-and-Drop or the Clipboard](dragdrop.md).</remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_MDIREFRESHMENU">
            <summary>An application sends the WM\_MDIREFRESHMENU message to a multiple-document interface (MDI) client window to refresh the window menu of the MDI frame window.</summary>
            <returns>
            <para>Type: **HMENU** If the message succeeds, the return value is the handle to the frame window menu. If the message fails, the return value is **NULL**.</para>
            </returns>
            <remarks>After sending this message, an application must call the [**DrawMenuBar**](/windows/win32/api/winuser/nf-winuser-drawmenubar) function to update the menu bar.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_POINTERDEVICECHANGE">
            <summary>Sent to a window when there is a change in the settings of a monitor that has a digitizer attached to it. This message contains information regarding the scaling of the display mode.</summary>
            <returns>
            <para>If the application processes this message, it should return zero. If the application does not process this message, it should call [**DefWindowProc**](/windows/win32/api/winuser/nf-winuser-defwindowproca).</para>
            </returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/inputmsg/wm-pointerdevicechange">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_POINTERDEVICEINRANGE">
            <summary>Sent to a window when a pointer device is detected within range of an input digitizer. This message contains information regarding the device and its proximity.</summary>
            <returns>
            <para>If the application processes this message, it should return zero. If the application does not process this message, it should call [**DefWindowProc**](/windows/win32/api/winuser/nf-winuser-defwindowproca).</para>
            </returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/inputmsg/wm-pointerdeviceinrange">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_POINTERDEVICEOUTOFRANGE">
            <summary>Sent to a window when a pointer device has departed the range of an input digitizer. This message contains information regarding the device and its proximity.</summary>
            <returns>
            <para>If the application processes this message, it should return zero. If the application does not process this message, it should call [**DefWindowProc**](/windows/win32/api/winuser/nf-winuser-defwindowproca).</para>
            </returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/inputmsg/wm-pointerdeviceoutofrange">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_TOUCH">
            <summary>Notifies the window when one or more touch points, such as a finger or pen, touches a touch-sensitive digitizer surface.</summary>
            <returns>
            <para>If an application processes this message, it should return zero. If the application does not process the message, it must call [DefWindowProc](/windows/win32/api/winuser/nf-winuser-defwindowproca). Not doing so causes the application to leak memory because the touch input handle is not closed and associated process memory is not freed.</para>
            </returns>
            <remarks>**WM\_TOUCH** messages do not respect **HTTRANSPARENT** regions of windows. If a window returns **HTTRANSPARENT** in response to a **WM\_NCHITTEST** message, mouse messages go to the parent, and **WM\_TOUCH** messages go directly to the window.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_NCPOINTERUPDATE">
            <summary>Posted to provide an update on a pointer that made contact over the non-client area of a window or when a hovering uncaptured contact moves over the non-client area of a window.</summary>
            <returns>
            <para>If an application processes this message, it should return zero. If the application does not process this message, it should call [**DefWindowProc**](/windows/win32/api/winuser/nf-winuser-defwindowproca).</para>
            </returns>
            <remarks>If the application does not process this message, [**DefWindowProc**](/windows/win32/api/winuser/nf-winuser-defwindowproca) may perform one or more system actions depending on the hit-test result included in the message. Typically, applications should not need to handle this message.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_NCPOINTERDOWN">
            <summary>Posted when a pointer makes contact over the non-client area of a window.</summary>
            <returns>
            <para>If an application processes this message, it should return zero. If the application does not process this message, it should call [**DefWindowProc**](/windows/win32/api/winuser/nf-winuser-defwindowproca).</para>
            </returns>
            <remarks>If the application does not process this message, [**DefWindowProc**](/windows/win32/api/winuser/nf-winuser-defwindowproca) may perform one or more system actions depending on the hit-test result included in the message. Typically, applications should not need to handle this message.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_NCPOINTERUP">
            <summary>Posted when a pointer that made contact over the non-client area of a window breaks contact.</summary>
            <returns>
            <para>If an application processes this message, it should return zero. If the application does not process this message, it should call [**DefWindowProc**](/windows/win32/api/winuser/nf-winuser-defwindowproca).</para>
            </returns>
            <remarks>If the application does not process this message, [**DefWindowProc**](/windows/win32/api/winuser/nf-winuser-defwindowproca) may perform one or more system actions depending on the hit-test result included in the message. Typically, applications should not need to handle this message.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_POINTERUPDATE">
            <summary>Posted to provide an update on a pointer that made contact over the client area of a window or on a hovering uncaptured pointer over the client area of a window.</summary>
            <returns>
            <para>If an application processes this message, it should return zero. If the application does not process this message, it should call [**DefWindowProc**](/windows/win32/api/winuser/nf-winuser-defwindowproca).</para>
            </returns>
            <remarks>
            <para>Each pointer has a unique pointer identifier during its lifetime. The lifetime of a pointer begins when it is first detected. A [**WM_POINTERENTER**](wm-pointerenter.md) message is generated if a hovering pointer is detected. A [**WM_POINTERDOWN**](wm-pointerdown.md) message followed by a **WM_POINTERENTER** message is generated if a non-hovering pointer is detected. During its lifetime, a pointer may generate a series of **WM_POINTERUPDATE** messages while it is hovering or in contact. The lifetime of a pointer ends when it is no longer detected. This generates a [**WM_POINTERLEAVE**](wm-pointerleave.md) message. When a pointer is aborted, [**POINTER_FLAG_CANCELED**](pointer-flags-contants.md) is set. A [**WM_POINTERLEAVE**](wm-pointerleave.md) message may also be generated when a non-captured pointer moves outside the bounds of a window. To obtain the horizontal and vertical position of a pointer, use the following:</para>
            <para></para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/inputmsg/wm-pointerupdate#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_POINTERDOWN">
            <summary>Posted when a pointer makes contact over the client area of a window.</summary>
            <returns>
            <para>If an application processes this message, it should return zero. If the application does not process this message, it should call [**DefWindowProc**](/windows/win32/api/winuser/nf-winuser-defwindowproca).</para>
            </returns>
            <remarks>
            <para>> ![Important] > When a window loses capture of a pointer and it receives the [**WM_POINTERCAPTURECHANGED**](wm-pointercapturechanged.md) notification, it typically will not receive any further notifications. For this reason, it is important that you not make any assumptions based on evenly paired **WM_POINTERDOWN**/[**WM_POINTERUP**](wm-pointerup.md) or [**WM_POINTERENTER**](wm-pointerenter.md)/[**WM_POINTERLEAVE**](wm-pointerleave.md) notifications.</para>
            <para>Each pointer has a unique pointer identifier during its lifetime. The lifetime of a pointer begins when it is first detected. A [**WM_POINTERENTER**](wm-pointerenter.md) message is generated if a hovering pointer is detected. A **WM_POINTERDOWN** message followed by a **WM_POINTERENTER** message is generated if a non-hovering pointer is detected. During its lifetime, a pointer may generate a series of [**WM_POINTERUPDATE**](wm-pointerupdate.md) messages while it is hovering or in contact. The lifetime of a pointer ends when it is no longer detected. This generates a [**WM_POINTERLEAVE**](wm-pointerleave.md) message. When a pointer is aborted, [**POINTER_FLAG_CANCELED**](pointer-flags-contants.md) is set. A [**WM_POINTERLEAVE**](wm-pointerleave.md) message may also be generated when a non-captured pointer moves outside the bounds of a window. To obtain the horizontal and vertical position of a pointer, use the following:</para>
            <para></para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/inputmsg/wm-pointerdown#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_POINTERUP">
            <summary>Posted when a pointer that made contact over the client area of a window breaks contact.</summary>
            <returns>
            <para>If an application processes this message, it should return zero. If the application does not process this message, it should call [**DefWindowProc**](/windows/win32/api/winuser/nf-winuser-defwindowproca).</para>
            </returns>
            <remarks>
            <para>> ![Important] > When a window loses capture of a pointer and it receives the [**WM_POINTERCAPTURECHANGED**](wm-pointercapturechanged.md) notification, it typically will not receive any further notifications. For this reason, it is important that you not make any assumptions based on evenly paired [**WM_POINTERDOWN**](wm-pointerdown.md)/**WM_POINTERUP** or [**WM_POINTERENTER**](wm-pointerenter.md)/[**WM_POINTERLEAVE**](wm-pointerleave.md) notifications.</para>
            <para>Each pointer has a unique pointer identifier during its lifetime. The lifetime of a pointer begins when it is first detected. A [**WM_POINTERENTER**](wm-pointerenter.md) message is generated if a hovering pointer is detected. A [**WM_POINTERDOWN**](wm-pointerdown.md) message followed by a **WM_POINTERENTER** message is generated if a non-hovering pointer is detected. During its lifetime, a pointer may generate a series of [**WM_POINTERUPDATE**](wm-pointerupdate.md) messages while it is hovering or in contact. The lifetime of a pointer ends when it is no longer detected. This generates a [**WM_POINTERLEAVE**](wm-pointerleave.md) message. When a pointer is aborted, [**POINTER_FLAG_CANCELED**](pointer-flags-contants.md) is set. A [**WM_POINTERLEAVE**](wm-pointerleave.md) message may also be generated when a non-captured pointer moves outside the bounds of a window. To obtain the horizontal and vertical position of a pointer, use the following: Use the following code to obtain the horizontal and vertical position:</para>
            <para></para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/inputmsg/wm-pointerup#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_POINTERENTER">
            <summary>Sent to a window when a new pointer enters detection range over the window (hover) or when an existing pointer moves within the boundaries of the window.</summary>
            <returns>
            <para>If an application processes this message, it should return zero. If the application does not process this message, it should call [**DefWindowProc**](/windows/win32/api/winuser/nf-winuser-defwindowproca).</para>
            </returns>
            <remarks>
            <para>The **WM_POINTERENTER** notification can be used by a window to provide feedback to the user while the pointer is over its surface or to otherwise react to the presence of a pointer over its surface. This notification is only sent to the window that is receiving input for the pointer. The following table lists some of the situations in which this notification is sent.</para>
            <para>| Action                                                   | Flags Set                                                                                                                                         | Notifications Sent To                                 | |----------------------------------------------------------|---------------------------------------------------------------------------------------------------------------------------------------------------|-------------------------------------------------------| | A new pointer enters detection range (hover).            | [**IS_POINTER_NEW_WPARAM**](/windows/win32/api/winuser/nf-winuser-is_pointer_new_wparam)<br/> [**IS_POINTER_INRANGE_WPARAM**](/windows/win32/api/winuser/nf-winuser-is_pointer_new_wparam)<br/> | Window over which the pointer enters detection range. | | A hovering pointer crosses within the window boundaries. | [**IS_POINTER_INRANGE_WPARAM**](/windows/win32/api/winuser/nf-winuser-is_pointer_inrange_wparam)<br/>                                                                      | Window within which the pointer has crossed.          |</para>
            <para>> ![Important] > When a window loses capture of a pointer and it receives the [**WM_POINTERCAPTURECHANGED**](wm-pointercapturechanged.md) notification, it typically will not receive any further notifications. For this reason, it is important that you not make any assumptions based on evenly paired [**WM_POINTERDOWN**](wm-pointerdown.md)/[**WM_POINTERUP**](wm-pointerup.md) or **WM_POINTERENTER**/[**WM_POINTERLEAVE**](wm-pointerleave.md) notifications.</para>
            <para>When inputs come from the mouse, as a result of mouse and pointer message integration, **WM_POINTERENTER** is not sent.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/inputmsg/wm-pointerenter#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_POINTERLEAVE">
            <summary>Sent to a window when a pointer leaves detection range over the window (hover) or when a pointer moves outside the boundaries of the window.</summary>
            <returns>
            <para>If an application processes this message, it should return zero. If the application does not process this message, it should call [**DefWindowProc**](/windows/win32/api/winuser/nf-winuser-defwindowproca).</para>
            </returns>
            <remarks>
            <para>The **WM_POINTERLEAVE** notification can be used by a window to change mode or stop any feedback to the user while the pointer is over the window surface. This notification is only sent to the window that is receiving input for the pointer. The following table lists some of the situations in which this notification is sent.</para>
            <para>| Action                                        | Flags Set                                                         | Notifications Sent To                                | |-----------------------------------------------|-------------------------------------------------------------------|------------------------------------------------------| | A hovering pointer crosses window boundaries. | [**IS_POINTER_INRANGE_WPARAM**](/windows/win32/api/winuser/nf-winuser-is_pointer_inrange_wparam) | Window outside of whose boundary the pointer moved.  | | A pointer goes out of detection range.        | N/A                                                               | Window for which the pointer leaves detection range. |</para>
            <para>> ![Important] > When a window loses capture of a pointer and it receives the [**WM_POINTERCAPTURECHANGED**](wm-pointercapturechanged.md) notification, it typically will not receive any further notifications. For this reason, it is important that you not make any assumptions based on evenly paired [**WM_POINTERDOWN**](wm-pointerdown.md)/[**WM_POINTERUP**](wm-pointerup.md) or [**WM_POINTERENTER**](wm-pointerenter.md)/**WM_POINTERLEAVE** notifications.</para>
            <para>If contact is maintained with the input digitizer and the pointer moves outside the window, **WM_POINTERLEAVE** is not generated. **WM_POINTERLEAVE** is generated only when a hovering pointer crosses window boundaries or contact is terminated. **WM_POINTERLEAVE** is posted to the posted message queue if the input is originated from a mouse device.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/inputmsg/wm-pointerleave#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_POINTERACTIVATE">
            <summary>Sent to an inactive window when a primary pointer generates a WM_POINTERDOWN over the window.</summary>
            <returns>
            <para>If an application processes this message, it should return one of the values described in the Remarks section. If the application does not process this message, it should call [**DefWindowProc**](/windows/win32/api/winuser/nf-winuser-defwindowproca).</para>
            </returns>
            <remarks>
            <para>An application can handle this message and return one of the following values to determine how the system processes the activation and the activating input: -   PA_ACTIVATE -   PA_NOACTIVATE It is important to note that, when the user is interacting with the system with multiple simultaneous pointers, the activation opportunity that the **WM_POINTERACTIVATE** message represents is available to applications only for the first of those pointers. Applications should, therefore, be aware that they may still receive input from pointers while they are inactive. If the application does not handle this message, [**DefWindowProc**](/windows/win32/api/winuser/nf-winuser-defwindowproca) passes the message to the parent window.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/inputmsg/wm-pointeractivate#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_POINTERCAPTURECHANGED">
            <summary>Sent to a window that is losing capture of an input pointer.</summary>
            <returns>
            <para>If an application processes this message, it should return zero. If the application does not process this message, it should call [**DefWindowProc**](/windows/win32/api/winuser/nf-winuser-defwindowproca).</para>
            </returns>
            <remarks>
            <para>A window should use this notification to stop processing subsequent messages and initiate any cleanup required for the pointer being lost. Processing of gestures associated with the pointer should also be terminated (for example, by calling [**StopInteractionContext**](/windows/win32/api/interactioncontext/nf-interactioncontext-stopinteractioncontext)) and remaining contacts re-associated with the window. Typically, if a window receives the **WM_POINTERCAPTURECHANGED** notification, no subsequent notifications related to the input pointer are received. Because of this, do not depend on paired notifications such as [**WM_POINTERENTER**](wm-pointerenter.md) and [**WM_POINTERLEAVE**](wm-pointerleave.md). **WM_POINTERCAPTURECHANGED** does not include [**POINTER_INFO**](/windows/win32/api/winuser/ns-winuser-pointer_info) data. Other than the [**POINTER_FLAG_CAPTURECHANGED**](pointer-flags-contants.md) flag being set, the data returned by [**GetPointerInfo**](/windows/win32/api/winuser/ns-winuser-pointer_info) (or any variant) is identical to that returned prior to the notification. If the application does not process this notification, [**DefWindowProc**](/windows/win32/api/winuser/nf-winuser-defwindowproca) may generate one or more [**WM_GESTURE**](../wintouch/wm-gesture.md) messages or, if a gesture is not recognized, **DefWindowProc** may generate mouse input. If an application selectively consumes some pointer input and passes the rest to [**DefWindowProc**](/windows/win32/api/winuser/nf-winuser-defwindowproca), the resulting behavior is undefined.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/inputmsg/wm-pointercapturechanged#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_TOUCHHITTESTING">
            <summary>Sent to a window on a touch down in order to determine the most probable touch target.</summary>
            <returns>
            <para>If one or more elements are within the touch contact area, an application should return the result of [**PackTouchHitTestingProximityEvaluation**](/windows/win32/api/winuser/nf-winuser-packtouchhittestingproximityevaluation). If no elements are within the touch contact area, an application should set the value of **score** in [**TOUCH_HIT_TESTING_PROXIMITY_EVALUATION**](/windows/win32/api/winuser/ns-winuser-touch_hit_testing_proximity_evaluation) to [**TOUCH_HIT_TESTING_PROXIMITY_FARTHEST**](/previous-versions/windows/desktop/input_touchhittest/hit-testing-scores) and call [**PackTouchHitTestingProximityEvaluation**](/windows/win32/api/winuser/nf-winuser-packtouchhittestingproximityevaluation) to get the LRESULT return value. If the application does not process this message, it must call [**DefWindowProc**](/windows/win32/api/winuser/nf-winuser-defwindowproca).</para>
            </returns>
            <remarks>This message is sent to windows that register through the [**RegisterTouchHitTestingWindow**](/windows/win32/api/winuser/nf-winuser-registertouchhittestingwindow) function.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_POINTERWHEEL">
            <summary>Posted to the window with foreground keyboard focus when a scroll wheel is rotated.</summary>
            <returns>
            <para>If the application processes this message, it should return zero. If the application does not process this message, it should call [**DefWindowProc**](/windows/win32/api/winuser/nf-winuser-defwindowproca).</para>
            </returns>
            <remarks>
            <para>To retrieve the wheel scroll units, use the **inputData** filed of the [**POINTER_INFO**](/windows/win32/api/winuser/ns-winuser-pointer_info) structure returned by calling [**GetPointerInfo**](/windows/win32/api/winuser/ns-winuser-pointer_info) function. This field contains a signed value and is expressed in a multiple of **WHEEL_DELTA**. A positive value indicates a rotation forward and a negative value indicates a rotation backward. Note that the wheel inputs may be delivered even if the mouse cursor is located outside of application s window. The wheel messages are delivered in a way very similar to the keyboard inputs. The focus window of the foregournd message queue receives the wheel messages.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/inputmsg/wm-pointerwheel#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_POINTERHWHEEL">
            <summary>Posted to the window with foreground keyboard focus when a horizontal scroll wheel is rotated.</summary>
            <returns>
            <para>If the application processes this message, it should return zero. If the application does not process this message, it should call [**DefWindowProc**](/windows/win32/api/winuser/nf-winuser-defwindowproca).</para>
            </returns>
            <remarks>
            <para>To retrieve the wheel scroll units, use the **inputData** filed of the [**POINTER_INFO**](/windows/win32/api/winuser/ns-winuser-pointer_info) structure returned by calling [**GetPointerInfo**](/windows/win32/api/winuser/ns-winuser-pointer_info) function. This field contains a signed value and is expressed in a multiple of **WHEEL_DELTA**. A positive value indicates a rotation forward and a negative value indicates a rotation backward. Note that the wheel inputs may be delivered even if the mouse cursor is located outside of application s window. The wheel messages are delivered in a way very similar to the keyboard inputs. The focus window of the foregournd message queue receives the wheel messages.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/inputmsg/wm-pointerhwheel#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_POINTERROUTEDTO">
            <summary>Sent when ongoing pointer input, for an existing pointer ID, transitions from one process to another across content configured for cross-process chaining (AddContentWithCrossProcessChaining).</summary>
            <returns>NULL</returns>
            <remarks>
            <para>This message is not sent when a [**WM_POINTERDOWN**](wm-pointerdown.md) message is posted for a new pointer ID on a different process. A [**WM_POINTERDOWN**](wm-pointerdown.md) message is not sent if a **WM_POINTERROUTEDTO** message is posted first.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/inputmsg/wm-pointerroutedto#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_POINTERROUTEDAWAY">
            <summary>Occurs on the process receiving input when the pointer input is routed to another process.AddContentWithCrossProcessChaining).</summary>
            <returns>NULL</returns>
            <remarks>This message is not sent with either a [**WM_POINTERUP**](wm-pointerup.md) message or a [**WM_POINTERCAPTURECHANGED**](wm-pointercapturechanged.md) message.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_POINTERROUTEDRELEASED">
            <summary>Sent to all processes (configured for cross-process chaining through AddContentWithCrossProcessChaining and not currently handling pointer input) ever associated with a specific pointer ID, when a WM_POINTERUP message is received on the current process.</summary>
            <returns>NULL</returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/inputmsg/wm-pointerroutedreleased">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_IME_SETCONTEXT">
            <summary>Sent to an application when a window is activated. A window receives this message through its WindowProc function.</summary>
            <returns>Returns the value returned by [**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowproca) or [**ImmIsUIMessage**](/windows/desktop/api/Imm/nf-imm-immisuimessagea).</returns>
            <remarks>
            <para>If the application has created an IME window, it should call [**ImmIsUIMessage**](/windows/desktop/api/Imm/nf-imm-immisuimessagea). Otherwise, it should pass this message to [**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowproca). If the application draws the composition window, the default IME window does not have to show its composition window. In this case, the application must clear the **ISC\_SHOWUICOMPOSITIONWINDOW** value from the *lParam* parameter before passing the message to [**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowproca) or [**ImmIsUIMessage**](/windows/desktop/api/Imm/nf-imm-immisuimessagea). To display a certain user interface window, an application should remove the corresponding value so that the IME will not display it.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/Intl/wm-ime-setcontext#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_IME_NOTIFY">
            <summary>Sent to an application to notify it of changes to the IME window. A window receives this message through its WindowProc function.</summary>
            <returns>The return value depends on the command sent.</returns>
            <remarks>An application processes this message if it is responsible for managing the IME window.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_IME_CONTROL">
            <summary>Sent by an application to direct the IME window to carry out the requested command.</summary>
            <returns>The message returns a command-specific value.</returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/Intl/wm-ime-control">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_IME_COMPOSITIONFULL">
            <summary>Sent to an application when the IME window finds no space to extend the area for the composition window. A window receives this message through its WindowProc function.</summary>
            <returns>
            <para>This message has no parameters.</para>
            <para>This message has no return value.</para>
            </returns>
            <remarks>
            <para>The application should use the [IMC\_SETCOMPOSITIONWINDOW](imc-setcompositionwindow.md) command to specify how the window should be displayed. The IME window, instead of the IME, sends this notification message by the [**SendMessage**](/windows/win32/api/winuser/nf-winuser-sendmessage) function.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/Intl/wm-ime-compositionfull#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_IME_SELECT">
            <summary>Sent to an application when the operating system is about to change the current IME. A window receives this message through its WindowProc function.</summary>
            <returns>This message has no return value.</returns>
            <remarks>
            <para>An application that has created an IME window should pass this message to that window so that it can retrieve the keyboard layout handle to the newly selected IME. The [**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowproca)  function processes this message by passing the information to the default IME window.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/Intl/wm-ime-select#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_IME_CHAR">
            <summary>Sent to an application when the IME gets a character of the conversion result. A window receives this message through its WindowProc function.</summary>
            <remarks>
            <para>Unlike the [**WM\_CHAR**](../inputdev/wm-char.md) message for a non-Unicode window, this message can include double-byte and single-byte character values. For a Unicode window, this message is the same as WM\_CHAR. For a non-Unicode window, if the WM\_IME\_CHAR message includes a double-byte character and the application passes this message to [**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowproca), the IME converts this message into two WM\_CHAR messages, each containing one byte of the double-byte character.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/Intl/wm-ime-char#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_IME_REQUEST">
            <summary>Sent to an application to provide commands and request information. A window receives this message through its WindowProc function.</summary>
            <returns>Returns a command-specific value.</returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/Intl/wm-ime-request">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_IME_KEYDOWN">
            <summary>Sent to an application by the IME to notify the application of a key press and to keep message order. A window receives this message through its WindowProc function.</summary>
            <returns>An application should return 0 if it processes this message.</returns>
            <remarks>An application can process this message or pass it to the [**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowproca)  function to generate a matching [**WM\_KEYDOWN**](../inputdev/wm-keydown.md) message.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_IME_KEYUP">
            <summary>Sent to an application by the IME to notify the application of a key release and to keep message order. A window receives this message through its WindowProc function.</summary>
            <returns>An application should return 0 if it processes this message.</returns>
            <remarks>An application can process this message or pass it to the [**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowproca)  function to generate a matching [**WM\_KEYUP**](../inputdev/wm-keyup.md) message.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_NCMOUSEHOVER">
            <summary>Posted to a window when the cursor hovers over the nonclient area of the window for the period of time specified in a prior call to TrackMouseEvent.</summary>
            <returns>If an application processes this message, it should return zero.</returns>
            <remarks>
            <para>Hover tracking stops when this message is generated. The application must call [**TrackMouseEvent**](/windows/win32/api/winuser/nf-winuser-trackmouseevent) again if it requires further tracking of mouse hover behavior. You can also use the [**GET\_X\_LPARAM**](/windows/desktop/api/windowsx/nf-windowsx-get_x_lparam) and [**GET\_Y\_LPARAM**](/windows/desktop/api/windowsx/nf-windowsx-get_y_lparam) macros to extract the values of the x- and y- coordinates from *lParam*.</para>
            <para></para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/inputdev/wm-ncmousehover#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_NCMOUSELEAVE">
            <summary>Posted to a window when the cursor leaves the nonclient area of the window specified in a prior call to TrackMouseEvent.</summary>
            <returns>If an application processes this message, it should return zero.</returns>
            <remarks>All tracking requested by [**TrackMouseEvent**](/windows/win32/api/winuser/nf-winuser-trackmouseevent) is canceled when this message is generated. The application must call **TrackMouseEvent** when the mouse reenters its window if it requires further tracking of mouse hover behavior.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_DPICHANGED">
            <summary>Sent when the effective dots per inch (dpi) for a window has changed.</summary>
            <returns>If an application processes this message, it should return zero.</returns>
            <remarks>
            <para>This message is only relevant for **PROCESS\_PER\_MONITOR\_DPI\_AWARE** applications or **DPI\_AWARENESS\_PER\_MONITOR\_AWARE** threads. It may be received on certain DPI changes if your top-level window or process is running as **DPI unaware** or **system DPI aware**, but in those situations it can be safely ignored. For more information about the different types of awareness, see [**PROCESS\_DPI\_AWARENESS**](/windows/desktop/api/ShellScalingApi/ne-shellscalingapi-process_dpi_awareness) and [**DPI\_AWARENESS**](/windows/desktop/api/windef/ne-windef-dpi_awareness). Older versions of Windows required DPI awareness to be tied at the level of an application. Those apps use **PROCESS\_DPI\_AWARENESS**. Currently, DPI awareness is tied to threads and individual windows rather than the entire application. These apps use **DPI\_AWARENESS**. You only need to use either the X-axis or the Y-axis value when scaling your application since they are the same. In order to handle this message correctly, you will need to resize and reposition your window based on the suggestions provided by *lParam* and using [**SetWindowPos**](/windows/desktop/api/winuser/nf-winuser-setwindowpos). If you do not do this, your window will grow or shrink with respect to everything else on the new monitor. For example, if a user is using multiple monitors and drags your window from a 96 DPI monitor to a 192 DPI monitor, your window will appear to be half as large with respect to other items on the 192 DPI monitor. The base value of DPI is defined as **USER\_DEFAULT\_SCREEN\_DPI** which is set to 96. To determine the scaling factor for a monitor, take the DPI value and divide by **USER\_DEFAULT\_SCREEN\_DPI**. The following table provides some sample DPI values and associated scaling factors.</para>
            <para>| DPI value | Scaling percentage | |-----------|--------------------| | 96        | 100%               | | 120       | 125%               | | 144       | 150%               | | 192       | 200%               |</para>
            <para>The following example provides a sample DPI change handler.</para>
            <para></para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/hidpi/wm-dpichanged#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_DPICHANGED_BEFOREPARENT">
            <summary>For Per Monitor v2 top-level windows, this message is sent to all HWNDs in the child HWDN tree of the window that is undergoing a DPI change. | WM_DPICHANGED_BEFOREPARENT message (Winuser.h)</summary>
            <returns>This value is unused and ignored by the system.</returns>
            <remarks>
            <para>There is no default handling of this message in [DefWindowProc](/windows/win32/api/winuser/nf-winuser-defwindowproca). This message is only sent when the top-level window has a DPI awareness context of PMv2.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/hidpi/wm-dpichanged-beforeparent#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_DPICHANGED_AFTERPARENT">
            <summary>For Per Monitor v2 top-level windows, this message is sent to all HWNDs in the child HWDN tree of the window that is undergoing a DPI change. | WM_DPICHANGED_AFTERPARENT message (Winuser.h)</summary>
            <returns>This value is unused and ignored by the system.</returns>
            <remarks>
            <para>There is no default handling of this message in [DefWindowProc](/windows/win32/api/winuser/nf-winuser-defwindowproca). This message is only sent when the top-level window has a DPI awareness context of PMv2.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/hidpi/wm-dpichanged-afterparent#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_GETDPISCALEDSIZE">
            <summary>This message tells the operating system that the window will be sized to dimensions other than the default.</summary>
            <returns>The function returns a BOOL. Returning TRUE indicates that a new size has been computed. Returning FALSE indicates that the message will not be handled, and the default linear DPI scaling will apply to the window.</returns>
            <remarks>
            <para>This message is only sent to top-level windows which have a DPI awareness context of Per Monitor v2. This event is necessary to facilitate graceful non-linear scaling, and ensures that the windows's position remains constant in relationship to the cursor and when moving back and forth across monitors. There is no specific default handling of this message in [DefWindowProc](/windows/win32/api/winuser/nf-winuser-defwindowproca). As for all messages it does not explicitly handle, [DefWindowProc](/windows/win32/api/winuser/nf-winuser-defwindowproca) will return zero for this message. As noted above, this return tells the system to use the default linear behavior.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/hidpi/wm-getdpiscaledsize#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_CUT">
            <summary>An application sends a WM\_CUT message to an edit control or combo box to delete (cut) the current selection, if any, in the edit control and copy the deleted text to the clipboard in CF\_TEXT format.</summary>
            <returns>This message does not return a value.</returns>
            <remarks>
            <para>The deletion performed by the **WM\_CUT** message can be undone by sending the edit control an [**EM\_UNDO**](../controls/em-undo.md) message. To delete the current selection without placing the deleted text on the clipboard, use the [**WM\_CLEAR**](wm-clear.md) message. When sent to a combo box, the **WM\_CUT** message is handled by its edit control. This message has no effect when sent to a combo box with the [**CBS\_DROPDOWNLIST**](../controls/combo-box-styles.md) style.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/dataxchg/wm-cut#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_COPY">
            <summary>An application sends the WM\_COPY message to an edit control or combo box to copy the current selection to the clipboard in CF\_TEXT format.</summary>
            <returns>Returns nonzero value on success, else zero.</returns>
            <remarks>When sent to a combo box, the **WM\_COPY** message is handled by its edit control. This message has no effect when sent to a combo box with the [**CBS\_DROPDOWNLIST**](../controls/combo-box-styles.md) style.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_PASTE">
            <summary>An application sends a WM\_PASTE message to an edit control or combo box to copy the current content of the clipboard to the edit control at the current caret position. Data is inserted only if the clipboard contains data in CF\_TEXT format.</summary>
            <returns>This message does not return a value.</returns>
            <remarks>When sent to a combo box, the **WM\_PASTE** message is handled by its edit control. This message has no effect when sent to a combo box with the [**CBS\_DROPDOWNLIST**](../controls/combo-box-styles.md) style.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_CLEAR">
            <summary>An application sends a WM\_CLEAR message to an edit control or combo box to delete (clear) the current selection, if any, from the edit control.</summary>
            <returns>This message does not return a value.</returns>
            <remarks>
            <para>The deletion performed by the **WM\_CLEAR** message can be undone by sending the edit control an [**EM\_UNDO**](../controls/em-undo.md) message. To delete the current selection and place the deleted content on the clipboard, use the [**WM\_CUT**](wm-cut.md) message. When sent to a combo box, the **WM\_CLEAR** message is handled by its edit control. This message has no effect when sent to a combo box with the [**CBS\_DROPDOWNLIST**](../controls/combo-box-styles.md) style.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/dataxchg/wm-clear#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_UNDO">
            <summary>An application sends a WM\_UNDO message to an edit control to undo the last operation. When this message is sent to an edit control, the previously deleted text is restored or the previously added text is deleted.</summary>
            <returns>
            <para>If the message succeeds, the return value is **TRUE**. If the message fails, the return value is **FALSE**.</para>
            </returns>
            <remarks>**Rich Edit:** It is recommended that [**EM\_UNDO**](em-undo.md) be used instead of **WM\_UNDO**.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_RENDERFORMAT">
            <summary>Sent to the clipboard owner if it has delayed rendering a specific clipboard format and if an application has requested data in that format.</summary>
            <returns>If an application processes this message, it should return zero.</returns>
            <remarks>When responding to a **WM\_RENDERFORMAT** message, the clipboard owner must not open the clipboard before calling [**SetClipboardData**](/windows/win32/api/winuser/nf-winuser-setclipboarddata). Opening the clipboard is not necessary before placing data in response to **WM\_RENDERFORMAT**, and any attempt to open the clipboard will fail because the clipboard is currently being held open by the application that requested the format to be rendered.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_RENDERALLFORMATS">
            <summary>Sent to the clipboard owner before it is destroyed, if the clipboard owner has delayed rendering one or more clipboard formats.</summary>
            <returns>If an application processes this message, it should return zero.</returns>
            <remarks>
            <para>When responding to a **WM\_RENDERALLFORMATS** message, the application must call the [**OpenClipboard**](/windows/win32/api/winuser/nf-winuser-openclipboard) function and then check that it is still the clipboard owner by calling the [**GetClipboardOwner**](/windows/win32/api/winuser/nf-winuser-getclipboardowner) function before calling [**SetClipboardData**](/windows/win32/api/winuser/nf-winuser-setclipboarddata). The application needs to check that it is still the clipboard owner after opening the clipboard because after it receives the **WM\_RENDERALLFORMATS** message, but before it opens the clipboard, another application may have opened and taken ownership of the clipboard, and that application's data should not be overwritten. In most cases, the application should not call the [**EmptyClipboard**](/windows/win32/api/winuser/nf-winuser-emptyclipboard) function before calling [**SetClipboardData**](/windows/win32/api/winuser/nf-winuser-setclipboarddata), since doing so will erase the clipboard formats that the application has already rendered. When the application returns, the system removes any unrendered formats from the list of available clipboard formats. For information about delayed rendering, see [Delayed Rendering](clipboard-operations.md#delayed-rendering).</para>
            <para><see href="https://learn.microsoft.com/windows/win32/dataxchg/wm-renderallformats#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_DESTROYCLIPBOARD">
            <summary>Sent to the clipboard owner when a call to the EmptyClipboard function empties the clipboard. A window receives this message through its WindowProc function.</summary>
            <returns>If an application processes this message, it should return zero.</returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/dataxchg/wm-destroyclipboard">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_DRAWCLIPBOARD">
            <summary>Sent to the first window in the clipboard viewer chain when the content of the clipboard changes. This enables a clipboard viewer window to display the new content of the clipboard. A window receives this message through its WindowProc function.</summary>
            <remarks>
            <para>Only clipboard viewer windows receive this message. These are windows that have been added to the clipboard viewer chain by using the [**SetClipboardViewer**](/windows/desktop/api/Winuser/nf-winuser-setclipboardviewer) function. Each window that receives the **WM\_DRAWCLIPBOARD** message must call the [**SendMessage**](/windows/desktop/api/winuser/nf-winuser-sendmessage) function to pass the message on to the next window in the clipboard viewer chain. The handle to the next window in the chain is returned by [**SetClipboardViewer**](/windows/desktop/api/Winuser/nf-winuser-setclipboardviewer), and may change in response to a [**WM\_CHANGECBCHAIN**](wm-changecbchain.md) message.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/dataxchg/wm-drawclipboard#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_PAINTCLIPBOARD">
            <summary>Sent to the clipboard owner by a clipboard viewer window when the clipboard contains data in the CF\_OWNERDISPLAY format and the clipboard viewer's client area needs repainting.</summary>
            <returns>If an application processes this message, it should return zero.</returns>
            <remarks>
            <para>To determine whether the entire client area or just a portion of it needs repainting, the clipboard owner must compare the dimensions of the drawing area given in the **rcPaint** member of [**PAINTSTRUCT**](/windows/win32/api/winuser/ns-winuser-paintstruct) to the dimensions given in the most recent [**WM\_SIZECLIPBOARD**](wm-sizeclipboard.md) message. The clipboard owner must use the [**GlobalLock**](/windows/desktop/api/winbase/nf-winbase-globallock) function to lock the memory that contains the [**PAINTSTRUCT**](/windows/win32/api/winuser/ns-winuser-paintstruct) structure. Before returning, the clipboard owner must unlock that memory by using the [**GlobalUnlock**](/windows/desktop/api/winbase/nf-winbase-globalunlock) function.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/dataxchg/wm-paintclipboard#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_VSCROLLCLIPBOARD">
            <summary>Sent to the clipboard owner by a clipboard viewer window when the clipboard contains data in the CF\_OWNERDISPLAY format and an event occurs in the clipboard viewer's vertical scroll bar.</summary>
            <returns>If an application processes this message, it should return zero.</returns>
            <remarks>The clipboard owner can use the [**ScrollWindow**](https://msdn.microsoft.com/library/Cc410994(v=MSDN.10).aspx) function to scroll the image in the clipboard viewer window and invalidate the appropriate region.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_SIZECLIPBOARD">
            <summary>Sent to the clipboard owner by a clipboard viewer window when the clipboard contains data in the CF\_OWNERDISPLAY format and the clipboard viewer's client area has changed size.</summary>
            <returns>If an application processes this message, it should return zero.</returns>
            <remarks>
            <para>When the clipboard viewer window is about to be destroyed or resized, a **WM\_SIZECLIPBOARD** message is sent with a null rectangle (0, 0, 0, 0) as the new size. This permits the clipboard owner to free its display resources. The clipboard owner must use the [**GlobalLock**](/windows/desktop/api/winbase/nf-winbase-globallock) function to lock the memory object that contains [**RECT**](/windows/win32/api/windef/ns-windef-rect). Before returning, the clipboard owner must unlock the object by using the [**GlobalUnlock**](/windows/desktop/api/winbase/nf-winbase-globalunlock) function.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/dataxchg/wm-sizeclipboard#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_ASKCBFORMATNAME">
            <summary>Sent to the clipboard owner by a clipboard viewer window to request the name of a CF\_OWNERDISPLAY clipboard format.</summary>
            <returns>If an application processes this message, it should return zero.</returns>
            <remarks>
            <para>In response to this message, the clipboard owner should copy the name of the owner-display format to the specified buffer, not exceeding the buffer size specified by the *wParam* parameter. A clipboard viewer window sends this message to the clipboard owner to determine the name of the [**CF\_OWNERDISPLAY**](standard-clipboard-formats.md) format   for example, to initialize a menu listing available formats.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/dataxchg/wm-askcbformatname#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_CHANGECBCHAIN">
            <summary>Sent to the first window in the clipboard viewer chain when a window is being removed from the chain. A window receives this message through its WindowProc function.</summary>
            <returns>If an application processes this message, it should return zero.</returns>
            <remarks>
            <para>Each clipboard viewer window saves the handle to the next window in the clipboard viewer chain. Initially, this handle is the return value of the [**SetClipboardViewer**](/windows/desktop/api/Winuser/nf-winuser-setclipboardviewer) function. When a clipboard viewer window receives the **WM\_CHANGECBCHAIN** message, it should call the [**SendMessage**](/windows/desktop/api/winuser/nf-winuser-sendmessage) function to pass the message to the next window in the chain, unless the next window is the window being removed. In this case, the clipboard viewer should save the handle specified by the *lParam* parameter as the next window in the chain.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/dataxchg/wm-changecbchain#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_HSCROLLCLIPBOARD">
            <summary>Sent to the clipboard owner by a clipboard viewer window.</summary>
            <returns>If an application processes this message, it should return zero.</returns>
            <remarks>The clipboard owner can use the [**ScrollWindow**](https://msdn.microsoft.com/library/Cc410994(v=MSDN.10).aspx) function to scroll the image in the clipboard viewer window and invalidate the appropriate region.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_QUERYNEWPALETTE">
            <summary>The WM\_QUERYNEWPALETTE message informs a window that it is about to receive the keyboard focus, giving the window the opportunity to realize its logical palette when it receives the focus.</summary>
            <returns>If the window realizes its logical palette, it must return **TRUE**; otherwise, it must return **FALSE**.</returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/gdi/wm-querynewpalette">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_PALETTEISCHANGING">
            <summary>The WM\_PALETTEISCHANGING message informs applications that an application is going to realize its logical palette.</summary>
            <returns>If an application processes this message, it should return zero.</returns>
            <remarks>
            <para>The application changing its palette does not wait for acknowledgment of this message before changing the palette and sending the [**WM\_PALETTECHANGED**](wm-palettechanged.md) message. As a result, the palette may already be changed by the time an application receives this message. If the application either ignores or fails to process this message and a second application realizes its palette while the first is using palette indexes, there is a strong possibility that the user will see unexpected colors during subsequent drawing operations.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/gdi/wm-paletteischanging#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_PALETTECHANGED">
            <summary>The WM\_PALETTECHANGED message is sent to all top-level and overlapped windows after the window with the keyboard focus has realized its logical palette, thereby changing the system palette.</summary>
            <remarks>
            <para>This message must be sent to all top-level and overlapped windows, including the one that changed the system palette. If any child windows use a color palette, this message must be passed on to them as well. To avoid creating an infinite loop, a window that receives this message must not realize its palette, unless it determines that *wParam* does not contain its own window handle.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/gdi/wm-palettechanged#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_HOTKEY">
            <summary>Posted when the user presses a hot key registered by the RegisterHotKey function. The message is placed at the top of the message queue associated with the thread that registered the hot key.</summary>
            <remarks>**WM\_HOTKEY** is unrelated to the [**WM\_GETHOTKEY**](wm-gethotkey.md) and [**WM\_SETHOTKEY**](wm-sethotkey.md) hot keys. The **WM\_HOTKEY** message is sent for generic hot keys while the **WM\_SETHOTKEY** and **WM\_GETHOTKEY** messages relate to window activation hot keys.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_PRINT">
            <summary>The WM\_PRINT message is sent to a window to request that it draw itself in the specified device context, most commonly in a printer device context.</summary>
            <remarks>The [**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowproca) function processes this message based on which drawing option is specified: if PRF\_CHECKVISIBLE is specified and the window is not visible, do nothing, if PRF\_NONCLIENT is specified, draw the nonclient area in the specified device context, if PRF\_ERASEBKGND is specified, send the window a [**WM\_ERASEBKGND**](../winmsg/wm-erasebkgnd.md) message, if PRF\_CLIENT is specified, send the window a [**WM\_PRINTCLIENT**](wm-printclient.md) message, if PRF\_CHILDREN is set, send each visible child window a **WM\_PRINT** message, if PRF\_OWNED is set, send each visible owned window a **WM\_PRINT** message.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_APPCOMMAND">
            <summary>Notifies a window that the user generated an application command event, for example, by clicking an application command button using the mouse or typing an application command key on the keyboard.</summary>
            <returns>If an application processes this message, it should return **TRUE**. For more information about processing the return value, see the Remarks section.</returns>
            <remarks>
            <para>[**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowproca) generates the **WM\_APPCOMMAND** message when it processes the [**WM\_XBUTTONUP**](wm-xbuttonup.md) or [**WM\_NCXBUTTONUP**](wm-ncxbuttonup.md) message, or when the user types an application command key. If a child window does not process this message and instead calls [**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowproca), **DefWindowProc** will send the message to its parent window. If a top level window does not process this message and instead calls **DefWindowProc**, **DefWindowProc** will call a shell hook with the hook code equal to **HSHELL\_APPCOMMAND**. To get the coordinates of the cursor if the message was generated by a mouse click, the application can call [**GetMessagePos**](/windows/desktop/api/winuser/nf-winuser-getmessagepos). An application can test whether the message was generated by the mouse by checking whether *lParam* contains **FAPPCOMMAND\_MOUSE**. Unlike other windows messages, an application should return **TRUE** from this message if it processes it. Doing so will allow software that simulates this message on Windows systems earlier than Windows 2000 to determine whether the window procedure processed the message or called [**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowproca) to process it.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/inputdev/wm-appcommand#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_THEMECHANGED">
            <summary>Broadcast to every window following a theme change event. Examples of theme change events are the activation of a theme, the deactivation of a theme, or a transition from one theme to another.</summary>
            <returns>
            <para>Type: **LRESULT** If an application processes this message, it should return zero.</para>
            </returns>
            <remarks>
            <para>A window receives this message through its [**WindowProc**](/previous-versions/windows/desktop/legacy/ms633573(v=vs.85)) function. > [!Note] > This message is posted by the operating system. Applications typically do not send this message.</para>
            <para>Themes are specifications for the appearance of controls, so that the visual element of a control is treated separately from its functionality. To release an existing theme handle, call [**CloseThemeData**](/windows/win32/api/uxtheme/nf-uxtheme-closethemedata). To acquire a new theme handle, use [**OpenThemeData**](/windows/win32/api/uxtheme/nf-uxtheme-openthemedata). Following the **WM\_THEMECHANGED** broadcast, any existing theme handles are invalid. A theme-aware window should release and reopen any of its pre-existing theme handles when it receives the **WM\_THEMECHANGED** message. If the [**OpenThemeData**](/windows/win32/api/uxtheme/nf-uxtheme-openthemedata) function returns **NULL**, the window should paint unthemed.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/winmsg/wm-themechanged#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_CLIPBOARDUPDATE">
            <summary>Sent when the contents of the clipboard have changed.</summary>
            <returns>If an application processes this message, it should return zero.</returns>
            <remarks>To register a window to receive this message, use the [**AddClipboardFormatListener**](/windows/desktop/api/Winuser/nf-winuser-addclipboardformatlistener) function.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_DWMCOMPOSITIONCHANGED">
            <summary>Informs all top-level windows that Desktop Window Manager (DWM) composition has been enabled or disabled.</summary>
            <returns>If an application processes this message, it should return zero.</returns>
            <remarks>
            <para>A window receives this message through its [**WindowProc**](/previous-versions/windows/desktop/legacy/ms633573(v=vs.85)) function. The [**DwmIsCompositionEnabled**](/windows/desktop/api/Dwmapi/nf-dwmapi-dwmiscompositionenabled) function can be used to determine the current composition state.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/dwm/wm-dwmcompositionchanged#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_DWMNCRENDERINGCHANGED">
            <summary>Sent when the non-client area rendering policy has changed.</summary>
            <returns>If an application processes this message, it should return zero.</returns>
            <remarks>
            <para>A window receives this message through its [**WindowProc**](/previous-versions/windows/desktop/legacy/ms633573(v=vs.85)) function. The [**DwmGetWindowAttribute**](/windows/desktop/api/Dwmapi/nf-dwmapi-dwmgetwindowattribute) and [**DwmSetWindowAttribute**](/windows/desktop/api/Dwmapi/nf-dwmapi-dwmsetwindowattribute) functions are used to get or set the non-client rendering policy.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/dwm/wm-dwmncrenderingchanged#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_DWMCOLORIZATIONCOLORCHANGED">
            <summary>Informs all top-level windows that the colorization color has changed.</summary>
            <returns>If an application processes this message, it should return zero.</returns>
            <remarks>
            <para>A window receives this message through its [**WindowProc**](/previous-versions/windows/desktop/legacy/ms633573(v=vs.85)) function. [**DwmGetColorizationColor**](/windows/desktop/api/Dwmapi/nf-dwmapi-dwmgetcolorizationcolor) is used to determine the current color value.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/dwm/wm-dwmcolorizationcolorchanged#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_DWMWINDOWMAXIMIZEDCHANGE">
            <summary>Sent when a Desktop Window Manager (DWM) composed window is maximized.</summary>
            <returns>If an application processes this message, it should return zero.</returns>
            <remarks>A window receives this message through its [**WindowProc**](/previous-versions/windows/desktop/legacy/ms633573(v=vs.85)) function.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_DWMSENDICONICTHUMBNAIL">
            <summary>Instructs a window to provide a static bitmap to use as a thumbnail representation of that window.</summary>
            <returns>If an application processes this message, it should return zero.</returns>
            <remarks>
            <para>DWM sends this message to a window if all of the following situations are true: -   DWM is displaying an iconic representation of the window. -   The [**DWMWA\_HAS\_ICONIC\_BITMAP**](/windows/desktop/api/Dwmapi/ne-dwmapi-dwmwindowattribute) attribute is set on the window. -   The window did not set a cached bitmap. -   There is room in the cache for another bitmap. The window that receives this message should respond by generating a bitmap that is not larger than the size that is requested in the message parameters. The window then calls the [**DwmSetIconicThumbnail**](/windows/desktop/api/Dwmapi/nf-dwmapi-dwmseticonicthumbnail) function to override the default thumbnail. If the window does not supply a bitmap in a given amount of time, DWM uses its own default iconic representation for the window. The window must belong to the calling process.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/dwm/wm-dwmsendiconicthumbnail#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_DWMSENDICONICLIVEPREVIEWBITMAP">
            <summary>Instructs a window to provide a static bitmap to use as a live preview (also known as a Peek preview) of that window.</summary>
            <returns>If an application processes this message, it should return zero.</returns>
            <remarks>
            <para>A *live preview* (also known as a *Peek preview*) of a window appears when a user moves the mouse pointer over the window's thumbnail in the taskbar or gives the thumbnail focus in the ALT+TAB window. This view is a full-sized preview of the window and can be a live snapshot or an iconic representation. Desktop Window Manager (DWM) sends this message to a window if all of the following situations are true: -   Live preview has been invoked on the window. -   The [**DWMWA\_HAS\_ICONIC\_BITMAP**](/windows/desktop/api/Dwmapi/ne-dwmapi-dwmwindowattribute) attribute is set on the window. -   An iconic representation is the only one that exists for this window. The window that receives this message should respond by generating a full-scale bitmap. The window then calls the [**DwmSetIconicLivePreviewBitmap**](/windows/desktop/api/Dwmapi/nf-dwmapi-dwmseticoniclivepreviewbitmap) function to set the live preview. If the window does not set a bitmap in a given amount of time, DWM uses its own default iconic representation for the window.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/dwm/wm-dwmsendiconiclivepreviewbitmap#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_GETTITLEBARINFOEX">
            <summary>Sent to request extended title bar information. A window receives this message through its WindowProc function.</summary>
            <remarks>
            <para>The following example shows how the message receiver casts an **LPARAM** value to retrieve the [**TITLEBARINFOEX**](/windows/win32/api/winuser/ns-winuser-titlebarinfoex) structure. `TITLEBARINFOEX *ptinfo = (TITLEBARINFOEX *)lParam;`</para>
            <para><see href="https://learn.microsoft.com/windows/win32/menurc/wm-gettitlebarinfoex#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_APP">
            <summary>Used to define private messages, usually of the form WM\_APP+x, where x is an integer value.</summary>
            <remarks>
            <para>The **WM\_APP** constant is used to distinguish between message values that are reserved for use by the system and values that can be used by an application to send messages within a private window class. The following are the ranges of message numbers available.</para>
            <para>| Range                                                 | Meaning                                                        | |-------------------------------------------------------|----------------------------------------------------------------| | 0 through [**WM\_USER**](wm-user.md) –1<br/>   | Messages reserved for use by the system.<br/>            | | [**WM\_USER**](wm-user.md) through 0x7FFF<br/> | Integer messages for use by private window classes.<br/> | | **WM\_APP** through 0xBFFF<br/>                 | Messages available for use by applications.<br/>         | | 0xC000 through 0xFFFF<br/>                      | String messages for use by applications.<br/>            | | Greater than 0xFFFF<br/>                        | Reserved by the system.<br/>                             |</para>
            <para>Message numbers in the first range (0 through [**WM\_USER**](wm-user.md) –1) are defined by the system. Values in this range that are not explicitly defined are reserved by the system. Message numbers in the second range ([**WM\_USER**](wm-user.md) through 0x7FFF) can be defined and used by an application to send messages within a private window class. These values cannot be used to define messages that are meaningful throughout an application because some predefined window classes already define values in this range. For example, predefined control classes such as **BUTTON**, **EDIT**, **LISTBOX**, and **COMBOBOX** may use these values. Messages in this range should not be sent to other applications unless the applications have been designed to exchange messages and to attach the same meaning to the message numbers. Message numbers in the third range (0x8000 through 0xBFFF) are available for applications to use as private messages. Messages in this range do not conflict with system messages. Message numbers in the fourth range (0xC000 through 0xFFFF) are defined at run time when an application calls the [**RegisterWindowMessage**](/windows/win32/api/winuser/nf-winuser-registerwindowmessagea) function to retrieve a message number for a string. All applications that register the same string can use the associated message number for exchanging messages. The actual message number, however, is not a constant and cannot be assumed to be the same between different sessions. Message numbers in the fifth range (greater than 0xFFFF) are reserved by the system.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/winmsg/wm-app#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_USER">
            <summary>Used to define private messages for use by private window classes, usually of the form WM\_USER+x, where x is an integer value.</summary>
            <remarks>
            <para>The following are the ranges of message numbers.</para>
            <para>| Range                                                        | Meaning                                                        | |--------------------------------------------------------------|----------------------------------------------------------------| | 0 through **WM\_USER** –1<br/>                         | Messages reserved for use by the system.<br/>            | | **WM\_USER** through 0x7FFF<br/>                       | Integer messages for use by private window classes.<br/> | | [**WM\_APP**](wm-app.md) (0x8000) through 0xBFFF<br/> | Messages available for use by applications.<br/>         | | 0xC000 through 0xFFFF<br/>                             | String messages for use by applications.<br/>            | | Greater than 0xFFFF<br/>                               | Reserved by the system.<br/>                             |</para>
            <para>Message numbers in the first range (0 through **WM\_USER** –1) are defined by the system. Values in this range that are not explicitly defined are reserved by the system. Message numbers in the second range (**WM\_USER** through 0x7FFF) can be defined and used by an application to send messages within a private window class. These values cannot be used to define messages that are meaningful throughout an application because some predefined window classes already define values in this range. For example, predefined control classes such as **BUTTON**, **EDIT**, **LISTBOX**, and **COMBOBOX** may use these values. Messages in this range should not be sent to other applications unless the applications have been designed to exchange messages and to attach the same meaning to the message numbers. Message numbers in the third range (0x8000 through 0xBFFF) are available for applications to use as private messages. Messages in this range do not conflict with system messages. Message numbers in the fourth range (0xC000 through 0xFFFF) are defined at run time when an application calls the [**RegisterWindowMessage**](/windows/win32/api/winuser/nf-winuser-registerwindowmessagea) function to retrieve a message number for a string. All applications that register the same string can use the associated message number for exchanging messages. The actual message number, however, is not a constant and cannot be assumed to be the same between different sessions. Message numbers in the fifth range (greater than 0xFFFF) are reserved by the system.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/winmsg/wm-user#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_CAP_SET_CALLBACK_ERROR">
            <summary>The WM\_CAP\_SET\_CALLBACK\_ERROR message sets an error callback function in the client application. AVICap calls this procedure when errors occur. You can send this message explicitly or by using the capSetCallbackOnError macro.</summary>
            <returns>
            <para><span id="fpProc"></span><span id="fpproc"></span><span id="FPPROC"></span>*fpProc* Pointer to the error callback function, of type [**capErrorCallback**](/windows/desktop/api/Vfw/nc-vfw-caperrorcallbacka). Specify **NULL** for this parameter to disable a previously installed error callback function.</para>
            <para>Returns **TRUE** if successful or **FALSE** if streaming capture or a single-frame capture session is in progress.</para>
            </returns>
            <remarks>
            <para>Applications can optionally set an error callback function. If set, AVICap calls the error procedure in the following situations: -   The disk is full. -   A capture window cannot be connected with a capture driver. -   A waveform-audio device cannot be opened. -   The number of frames dropped during capture exceeds the specified percentage. -   The frames cannot be captured due to vertical synchronization interrupt problems.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/Multimedia/wm-cap-set-callback-error#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_CAP_SET_CALLBACK_STATUS">
            <summary>The WM\_CAP\_SET\_CALLBACK\_STATUS message sets a status callback function in the application. AVICap calls this procedure whenever the capture window status changes. You can send this message explicitly or by using the capSetCallbackOnStatus macro.</summary>
            <returns>
            <para><span id="fpProc"></span><span id="fpproc"></span><span id="FPPROC"></span>*fpProc* Pointer to the status callback function, of type [**capStatusCallback**](/windows/desktop/api/Vfw/nc-vfw-capstatuscallbacka). Specify **NULL** for this parameter to disable a previously installed status callback function.</para>
            <para>Returns **TRUE** if successful or **FALSE** if streaming capture or a single-frame capture session is in progress.</para>
            </returns>
            <remarks>
            <para>Applications can optionally set a status callback function. If set, AVICap calls this procedure in the following situations: -   A capture session is completed. -   A capture driver successfully connected to a capture window. -   An optimal palette is created. -   The number of captured frames is reported.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/Multimedia/wm-cap-set-callback-status#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_CAP_SET_CALLBACK_YIELD">
            <summary>The WM\_CAP\_SET\_CALLBACK\_YIELD message sets a callback function in the application. AVICap calls this procedure when the capture window yields during streaming capture. You can send this message explicitly or by using the capSetCallbackOnYield macro.</summary>
            <returns>
            <para><span id="fpProc"></span><span id="fpproc"></span><span id="FPPROC"></span>*fpProc* Pointer to the yield callback function, of type [**capYieldCallback**](/windows/desktop/api/Vfw/nc-vfw-capyieldcallback). Specify **NULL** for this parameter to disable a previously installed yield callback function.</para>
            <para>Returns **TRUE** if successful or **FALSE** if streaming capture or a single-frame capture session is in progress.</para>
            </returns>
            <remarks>
            <para>Applications can optionally set a yield callback function. The yield callback function is called at least once for each video frame captured during streaming capture. If a yield callback function is installed, it will be called regardless of the state of the **fYield** member of the [**CAPTUREPARMS**](/windows/win32/api/vfw/ns-vfw-captureparms) structure. If the yield callback function is used, it must be installed before starting the capture session and it must remain enabled for the duration of the session. It can be disabled after streaming capture ends. Applications typically perform some type of message processing in the callback function consisting of a [PeekMessage](/windows/win32/api/winuser/nf-winuser-peekmessagea), [TranslateMessage](/windows/win32/api/winuser/nf-winuser-translatemessage), [DispatchMessage](/windows/win32/api/winuser/nf-winuser-dispatchmessage) loop, as in the message loop of a [WinMain](/windows/win32/api/winbase/nf-winbase-winmain) function. The yield callback function must also filter and remove messages that can cause reentrancy problems. An application typically returns **TRUE** in the yield procedure to continue streaming capture. If a yield callback function returns **FALSE**, the capture window stops the capture process.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/Multimedia/wm-cap-set-callback-yield#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_CAP_SET_CALLBACK_FRAME">
            <summary>The WM\_CAP\_SET\_CALLBACK\_FRAME message sets a preview callback function in the application. AVICap calls this procedure when the capture window captures preview frames. You can send this message explicitly or by using the capSetCallbackOnFrame macro.</summary>
            <returns>
            <para><span id="fpProc"></span><span id="fpproc"></span><span id="FPPROC"></span>*fpProc* Pointer to the preview callback function, of type [**capVideoStreamCallback**](/windows/desktop/api/Vfw/nc-vfw-capvideocallback). Specify **NULL** for this parameter to disable a previously installed callback function.</para>
            <para>Returns **TRUE** if successful or **FALSE** if streaming capture or a single-frame capture session is in progress.</para>
            </returns>
            <remarks>The capture window calls the callback function before displaying preview frames. This allows an application to modify the frame if desired. This callback function is not used during streaming video capture.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_CAP_SET_CALLBACK_VIDEOSTREAM">
            <summary>The WM\_CAP\_SET\_CALLBACK\_VIDEOSTREAM message sets a callback function in the application.</summary>
            <returns>
            <para><span id="fpProc"></span><span id="fpproc"></span><span id="FPPROC"></span>*fpProc* Pointer to the video-stream callback function, of type [**capVideoStreamCallback**](/windows/desktop/api/Vfw/nc-vfw-capvideocallback). Specify **NULL** for this parameter to disable a previously installed video-stream callback function.</para>
            <para>Returns **TRUE** if successful or **FALSE** if streaming capture or a single-frame capture session is in progress.</para>
            </returns>
            <remarks>
            <para>The capture window calls the callback function before writing the captured frame to disk. This allows applications to modify the frame if desired. If a video stream callback function is used for streaming capture, the procedure must be installed before starting the capture session and it must remain enabled for the duration of the session. It can be disabled after streaming capture ends.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/Multimedia/wm-cap-set-callback-videostream#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_CAP_SET_CALLBACK_WAVESTREAM">
            <summary>The WM\_CAP\_SET\_CALLBACK\_WAVESTREAM message sets a callback function in the application.</summary>
            <returns>
            <para><span id="fpProc"></span><span id="fpproc"></span><span id="FPPROC"></span>*fpProc* Pointer to the wave stream callback function, of type [**capWaveStreamCallback**](/windows/desktop/api/Vfw/nc-vfw-capwavecallback). Specify **NULL** for this parameter to disable a previously installed wave stream callback function.</para>
            <para>Returns **TRUE** if successful or **FALSE** if streaming capture or a single-frame capture session is in progress.</para>
            </returns>
            <remarks>
            <para>The capture window calls the procedure before writing the audio buffer to disk. This allows applications to modify the audio buffer if desired. If a wave stream callback function is used, it must be installed before starting the capture session and it must remain enabled for the duration of the session. It can be disabled after streaming capture ends.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/Multimedia/wm-cap-set-callback-wavestream#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_CAP_GET_USER_DATA">
            <summary>The WM\_CAP\_GET\_USER\_DATA message retrieves a LONG\_PTR data value associated with a capture window. You can send this message explicitly or by using the capGetUserData macro.</summary>
            <returns>Returns a value previously saved by using the [**WM\_CAP\_SET\_USER\_DATA**](wm-cap-set-user-data.md) message.</returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/Multimedia/wm-cap-get-user-data">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_CAP_SET_USER_DATA">
            <summary>The WM\_CAP\_SET\_USER\_DATA message associates a LONG\_PTR data value with a capture window. You can send this message explicitly or by using the capSetUserData macro.</summary>
            <returns>
            <para><span id="lUser"></span><span id="luser"></span><span id="LUSER"></span>*lUser* Data value to associate with a capture window.</para>
            <para>Returns **TRUE** if successful or **FALSE** if streaming capture is in progress.</para>
            </returns>
            <remarks>Typically this message is used to point to a block of data associated with a capture window.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_CAP_DRIVER_CONNECT">
            <summary>The WM\_CAP\_DRIVER\_CONNECT message connects a capture window to a capture driver. You can send this message explicitly or by using the capDriverConnect macro.</summary>
            <returns>
            <para><span id="iIndex"></span><span id="iindex"></span><span id="IINDEX"></span>*iIndex* Index of the capture driver. The index can range from 0 through 9.</para>
            <para>Returns **TRUE** if successful or **FALSE** if the specified capture driver cannot be connected to the capture window.</para>
            </returns>
            <remarks>Connecting a capture driver to a capture window automatically disconnects any previously connected capture driver.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_CAP_DRIVER_DISCONNECT">
            <summary>The WM\_CAP\_DRIVER\_DISCONNECT message disconnects a capture driver from a capture window. You can send this message explicitly or by using the capDriverDisconnect macro.</summary>
            <returns>Returns **TRUE** if successful or **FALSE** if the capture window is not connected to a capture driver.</returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/Multimedia/wm-cap-driver-disconnect">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_CAP_DRIVER_GET_NAME">
            <summary>The WM\_CAP\_DRIVER\_GET\_NAME message returns the name of the capture driver connected to the capture window. You can send this message explicitly or by using the capDriverGetName macro.</summary>
            <returns>
            <para><span id="wSize"></span><span id="wsize"></span><span id="WSIZE"></span>*wSize* Size, in bytes, of the buffer referenced by**szName**.</para>
            <para><span id="szName"></span><span id="szname"></span><span id="SZNAME"></span>*szName* Pointer to an application-defined buffer used to return the device name as a null-terminated string.</para>
            <para>Returns **TRUE** if successful or **FALSE** if the capture window is not connected to a capture driver.</para>
            </returns>
            <remarks>The name is a text string retrieved from the driver's resource area. Applications should allocate approximately 80 bytes for this string. If the driver does not contain a name resource, the full path name of the driver listed in the registry or in the SYSTEM.INI file is returned.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_CAP_DRIVER_GET_VERSION">
            <summary>The WM\_CAP\_DRIVER\_GET\_VERSION message returns the version information of the capture driver connected to a capture window. You can send this message explicitly or by using the capDriverGetVersion macro.</summary>
            <returns>
            <para><span id="wSize"></span><span id="wsize"></span><span id="WSIZE"></span>*wSize* Size, in bytes, of the application-defined buffer referenced by**szVer**.</para>
            <para><span id="szVer"></span><span id="szver"></span><span id="SZVER"></span>*szVer* Pointer to an application-defined buffer used to return the version information as a null-terminated string.</para>
            <para>Returns **TRUE** if successful or **FALSE** if the capture window is not connected to a capture driver.</para>
            </returns>
            <remarks>The version information is a text string retrieved from the driver's resource area. Applications should allocate approximately 40 bytes for this string. If version information is not available, a **NULL** string is returned.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_CAP_DRIVER_GET_CAPS">
            <summary>The WM\_CAP\_DRIVER\_GET\_CAPS message returns the hardware capabilities of the capture driver currently connected to a capture window. You can send this message explicitly or by using the capDriverGetCaps macro.</summary>
            <returns>
            <para><span id="wSize"></span><span id="wsize"></span><span id="WSIZE"></span>*wSize* Size, in bytes, of the structure referenced by**s**.</para>
            <para><span id="psCaps"></span><span id="pscaps"></span><span id="PSCAPS"></span>*psCaps* Pointer to the [**CAPDRIVERCAPS**](/windows/win32/api/vfw/ns-vfw-capdrivercaps) structure to contain the hardware capabilities.</para>
            <para>Returns **TRUE** if successful or **FALSE** if the capture window is not connected to a capture driver.</para>
            </returns>
            <remarks>The capabilities returned in [**CAPDRIVERCAPS**](/windows/win32/api/vfw/ns-vfw-capdrivercaps) are constant for a given capture driver. Applications need to retrieve this information once when the capture driver is first connected to a capture window.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_CAP_FILE_SET_CAPTURE_FILE">
            <summary>The WM\_CAP\_FILE\_SET\_CAPTURE\_FILE message names the file used for video capture. You can send this message explicitly or by using the capFileSetCaptureFile macro.</summary>
            <returns>
            <para><span id="szName"></span><span id="szname"></span><span id="SZNAME"></span>*szName* Pointer to the null-terminated string that contains the name of the capture file to use.</para>
            <para>Returns **TRUE** if successful or **FALSE** if the filename is invalid, or if streaming or single-frame capture is in progress.</para>
            </returns>
            <remarks>This message stores the filename in an internal structure. It does not create, allocate, or open the specified file. The default capture filename is C:\\CAPTURE.AVI.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_CAP_FILE_GET_CAPTURE_FILE">
            <summary>The WM\_CAP\_FILE\_GET\_CAPTURE\_FILE message returns the name of the current capture file. You can send this message explicitly or by using the capFileGetCaptureFile macro.</summary>
            <returns>
            <para><span id="wSize"></span><span id="wsize"></span><span id="WSIZE"></span>*wSize* Size, in bytes, of the application-defined buffer referenced by**szName**.</para>
            <para><span id="szName"></span><span id="szname"></span><span id="SZNAME"></span>*szName* Pointer to an application-defined buffer used to return the name of the capture file as a null-terminated string.</para>
            <para>Returns **TRUE** if successful or **FALSE** otherwise.</para>
            </returns>
            <remarks>The default capture filename is C:\\CAPTURE.AVI.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_CAP_FILE_SAVEAS">
            <summary>The WM\_CAP\_FILE\_SAVEAS message copies the contents of the capture file to another file. You can send this message explicitly or by using the capFileSaveAs macro.</summary>
            <returns>
            <para><span id="szName"></span><span id="szname"></span><span id="SZNAME"></span>*szName* Pointer to the null-terminated string that contains the name of the destination file used to copy the file.</para>
            <para>Returns **TRUE** if successful or **FALSE** otherwise. If an error occurs and an error callback function is set using the [**WM\_CAP\_SET\_CALLBACK\_ERROR**](wm-cap-set-callback-error.md) message, the error callback function is called.</para>
            </returns>
            <remarks>
            <para>This message does not change the name or contents of the current capture file. If the copy operation is unsuccessful due to a disk full error, the destination file is automatically deleted. Typically, a capture file is preallocated for the largest capture segment anticipated and only a portion of it might be used to capture data. This message copies only the portion of the file containing the capture data.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/Multimedia/wm-cap-file-saveas#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_CAP_FILE_SAVEDIB">
            <summary>The WM\_CAP\_FILE\_SAVEDIB message copies the current frame to a DIB file. You can send this message explicitly or by using the capFileSaveDIB macro.</summary>
            <returns>
            <para><span id="szName"></span><span id="szname"></span><span id="SZNAME"></span>*szName* Pointer to the null-terminated string that contains the name of the destination DIB file.</para>
            <para>Returns **TRUE** if successful or **FALSE** otherwise. If an error occurs and an error callback function is set using the [**WM\_CAP\_SET\_CALLBACK\_ERROR**](wm-cap-set-callback-error.md) message, the error callback function is called.</para>
            </returns>
            <remarks>If the capture driver supplies frames in a compressed format, this call attempts to decompress the frame before writing the file.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_CAP_FILE_ALLOCATE">
            <summary>The WM\_CAP\_FILE\_ALLOCATE message creates (preallocates) a capture file of a specified size. You can send this message explicitly or by using the capFileAlloc macro.</summary>
            <returns>
            <para><span id="dwSize"></span><span id="dwsize"></span><span id="DWSIZE"></span>*dwSize* Size, in bytes, to create the capture file.</para>
            <para>Returns **TRUE** if successful or **FALSE** otherwise. If an error occurs and an error callback function is set using the [**WM\_CAP\_SET\_CALLBACK\_ERROR**](wm-cap-set-callback-error.md) message, the error callback function is called.</para>
            </returns>
            <remarks>You can improve streaming capture performance significantly by preallocating a capture file large enough to store an entire video clip and by defragmenting the capture file before capturing the clip.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_CAP_FILE_SET_INFOCHUNK">
            <summary>The WM\_CAP\_FILE\_SET\_INFOCHUNK message sets and clears information chunks.</summary>
            <returns>
            <para><span id="lpInfoChunk"></span><span id="lpinfochunk"></span><span id="LPINFOCHUNK"></span>*lpInfoChunk* Pointer to a [**CAPINFOCHUNK**](/windows/win32/api/vfw/ns-vfw-capinfochunk) structure defining the information chunk to be created or deleted.</para>
            <para>Returns **TRUE** if successful or **FALSE** otherwise. If an error occurs and an error callback function is set using the [**WM\_CAP\_SET\_CALLBACK\_ERROR**](wm-cap-set-callback-error.md) message, the error callback function is called.</para>
            </returns>
            <remarks>Multiple registered information chunks can be added to an AVI file. After an information chunk is set, it continues to be added to subsequent capture files until either the entry is cleared or all information chunk entries are cleared. To clear a single entry, specify the information chunk in the **fccInfoID** member and **NULL** in the **lpData** member of the [**CAPINFOCHUNK**](/windows/win32/api/vfw/ns-vfw-capinfochunk) structure. To clear all entries, specify **NULL** in **fccInfoID**.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_CAP_EDIT_COPY">
            <summary>The WM\_CAP\_EDIT\_COPY message copies the contents of the video frame buffer and associated palette to the clipboard. You can send this message explicitly or by using the capEditCopy macro.</summary>
            <returns>Returns **TRUE** if successful or **FALSE** otherwise.</returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/Multimedia/wm-cap-edit-copy">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_CAP_SET_AUDIOFORMAT">
            <summary>The WM\_CAP\_SET\_AUDIOFORMAT message sets the audio format to use when performing streaming or step capture. You can send this message explicitly or by using the capSetAudioFormat macro.</summary>
            <returns>
            <para><span id="wSize"></span><span id="wsize"></span><span id="WSIZE"></span>*wSize* Size, in bytes, of the structure referenced by **s**.</para>
            <para><span id="psAudioFormat"></span><span id="psaudioformat"></span><span id="PSAUDIOFORMAT"></span>*psAudioFormat* Pointer to a [**WAVEFORMATEX**](/windows/win32/api/mmeapi/ns-mmeapi-waveformatex) or [**PCMWAVEFORMAT**](/windows/win32/api/mmreg/ns-mmreg-pcmwaveformat) structure that defines the audio format.</para>
            <para>Returns **TRUE** if successful or **FALSE** otherwise.</para>
            </returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/Multimedia/wm-cap-set-audioformat">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_CAP_GET_AUDIOFORMAT">
            <summary>The WM\_CAP\_GET\_AUDIOFORMAT message obtains the audio format or the size of the audio format. You can send this message explicitly or by using the capGetAudioFormat and capGetAudioFormatSize macros.</summary>
            <returns>
            <para><span id="wSize"></span><span id="wsize"></span><span id="WSIZE"></span>*wSize* Size, in bytes, of the structure referenced by**s**.</para>
            <para><span id="psAudioFormat"></span><span id="psaudioformat"></span><span id="PSAUDIOFORMAT"></span>*psAudioFormat* Pointer to a [**WAVEFORMATEX**](/windows/win32/api/mmeapi/ns-mmeapi-waveformatex) structure, or **NULL**. If the value is **NULL**, the size, in bytes, required to hold the structure is returned.</para>
            <para>Returns the size, in bytes, of the audio format.</para>
            </returns>
            <remarks>Because compressed audio formats vary in size requirements applications must first retrieve the size, then allocate memory, and finally request the audio format data.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_CAP_DLG_VIDEOFORMAT">
            <summary>The WM\_CAP\_DLG\_VIDEOFORMAT message displays a dialog box in which the user can select the video format.</summary>
            <returns>Returns **TRUE** if successful or **FALSE** otherwise.</returns>
            <remarks>
            <para>After this message returns, applications might need to update the [**CAPSTATUS**](/windows/win32/api/vfw/ns-vfw-capstatus) structure because the user might have changed the image dimensions. The Video Format dialog box is unique for each capture driver. Some capture drivers might not support a Video Format dialog box. Applications can determine if the capture driver supports this message by checking the **fHasDlgVideoFormat** member of [**CAPDRIVERCAPS**](/windows/win32/api/vfw/ns-vfw-capdrivercaps).</para>
            <para><see href="https://learn.microsoft.com/windows/win32/Multimedia/wm-cap-dlg-videoformat#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_CAP_DLG_VIDEOSOURCE">
            <summary>The WM\_CAP\_DLG\_VIDEOSOURCE message displays a dialog box in which the user can control the video source.</summary>
            <returns>Returns **TRUE** if successful or **FALSE** otherwise.</returns>
            <remarks>The Video Source dialog box is unique for each capture driver. Some capture drivers might not support a Video Source dialog box. Applications can determine if the capture driver supports this message by checking the **fHasDlgVideoSource** member of the [**CAPDRIVERCAPS**](/windows/win32/api/vfw/ns-vfw-capdrivercaps) structure.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_CAP_DLG_VIDEODISPLAY">
            <summary>The WM\_CAP\_DLG\_VIDEODISPLAY message displays a dialog box in which the user can set or adjust the video output.</summary>
            <returns>Returns **TRUE** if successful or **FALSE** otherwise.</returns>
            <remarks>
            <para>The controls in this dialog box do not affect digitized video data; they affect only the output or redisplay of the video signal. The Video Display dialog box is unique for each capture driver. Some capture drivers might not support a Video Display dialog box. Applications can determine if the capture driver supports this message by checking the **fHasDlgVideoDisplay** member of the [**CAPDRIVERCAPS**](/windows/win32/api/vfw/ns-vfw-capdrivercaps) structure.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/Multimedia/wm-cap-dlg-videodisplay#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_CAP_GET_VIDEOFORMAT">
            <summary>The WM\_CAP\_GET\_VIDEOFORMAT message retrieves a copy of the video format in use or the size required for the video format. You can send this message explicitly or by using the capGetVideoFormat and capGetVideoFormatSize macros.</summary>
            <returns>
            <para><span id="wSize"></span><span id="wsize"></span><span id="WSIZE"></span>*wSize* Size, in bytes, of the structure referenced by**s**.</para>
            <para><span id="psVideoFormat"></span><span id="psvideoformat"></span><span id="PSVIDEOFORMAT"></span>*psVideoFormat* Pointer to a [**BITMAPINFO**](/windows/win32/api/wingdi/ns-wingdi-bitmapinfo) structure. You can also specify **NULL** to retrieve the number of bytes needed.</para>
            <para>Returns the size, in bytes, of the video format or zero if the capture window is not connected to a capture driver. For video formats that require a palette, the current palette is also returned.</para>
            </returns>
            <remarks>Because compressed video formats vary in size requirements applications must first retrieve the size, then allocate memory, and finally request the video format data.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_CAP_SET_VIDEOFORMAT">
            <summary>The WM\_CAP\_SET\_VIDEOFORMAT message sets the format of captured video data. You can send this message explicitly or by using the capSetVideoFormat macro.</summary>
            <returns>
            <para><span id="wSize"></span><span id="wsize"></span><span id="WSIZE"></span>*wSize* Size, in bytes, of the structure referenced by **s**.</para>
            <para><span id="psVideoFormat"></span><span id="psvideoformat"></span><span id="PSVIDEOFORMAT"></span>*psVideoFormat* Pointer to a [**BITMAPINFO**](/windows/win32/api/wingdi/ns-wingdi-bitmapinfo) structure.</para>
            <para>Returns **TRUE** if successful or **FALSE** otherwise.</para>
            </returns>
            <remarks>Because video formats are device-specific, applications should check the return value from this function to determine if the format is accepted by the driver.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_CAP_DLG_VIDEOCOMPRESSION">
            <summary>The WM\_CAP\_DLG\_VIDEOCOMPRESSION message displays a dialog box in which the user can select a compressor to use during the capture process.</summary>
            <returns>Returns **TRUE** if successful or **FALSE** otherwise.</returns>
            <remarks>
            <para>Use this message with capture drivers that provide frames only in the BI\_RGB format. This message is most useful in the step capture operation to combine capture and compression in a single operation. Compressing frames with a software compressor as part of a real-time capture operation is most likely too time-consuming to perform. Compression does not affect the frames copied to the clipboard.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/Multimedia/wm-cap-dlg-videocompression#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_CAP_SET_PREVIEW">
            <summary>The WM\_CAP\_SET\_PREVIEW message enables or disables preview mode.</summary>
            <returns>
            <para><span id="f"></span><span id="F"></span>*f* Preview flag. Specify **TRUE** for this parameter to enable preview mode or **FALSE** to disable it.</para>
            <para>Returns **TRUE** if successful or **FALSE** otherwise.</para>
            </returns>
            <remarks>
            <para>The preview mode uses substantial CPU resources. Applications can disable preview or lower the preview rate when another application has the focus. The **fLiveWindow** member of the [**CAPSTATUS**](/windows/win32/api/vfw/ns-vfw-capstatus) structure indicates if preview mode is currently enabled. Enabling preview mode automatically disables overlay mode.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/Multimedia/wm-cap-set-preview#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_CAP_SET_OVERLAY">
            <summary>The WM\_CAP\_SET\_OVERLAY message enables or disables overlay mode. In overlay mode, video is displayed using hardware overlay. You can send this message explicitly or by using the capOverlay macro.</summary>
            <returns>
            <para><span id="f"></span><span id="F"></span>*f* Overlay flag. Specify **TRUE** for this parameter to enable overlay mode or **FALSE** to disable it.</para>
            <para>Returns **TRUE** if successful or **FALSE** otherwise.</para>
            </returns>
            <remarks>
            <para>Using an overlay does not require CPU resources. The **fHasOverlay** member of the [**CAPDRIVERCAPS**](/windows/win32/api/vfw/ns-vfw-capdrivercaps) structure indicates whether the device is capable of overlay. The **fOverlayWindow** member of the [**CAPSTATUS**](/windows/win32/api/vfw/ns-vfw-capstatus) structure indicates whether overlay mode is currently enabled. Enabling overlay mode automatically disables preview mode.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/Multimedia/wm-cap-set-overlay#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_CAP_SET_PREVIEWRATE">
            <summary>The WM\_CAP\_SET\_PREVIEWRATE message sets the frame display rate in preview mode. You can send this message explicitly or by using the capPreviewRate macro.</summary>
            <returns>
            <para><span id="wMS"></span><span id="wms"></span><span id="WMS"></span>*wMS* Rate, in milliseconds, at which new frames are captured and displayed.</para>
            <para>Returns **TRUE** if successful or **FALSE** if the capture window is not connected to a capture driver.</para>
            </returns>
            <remarks>The preview mode uses substantial CPU resources. Applications can disable preview or lower the preview rate when another application has the focus. During streaming video capture, the previewing task is lower priority than writing frames to disk, and preview frames are displayed only if no other buffers are available for writing.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_CAP_SET_SCALE">
            <summary>The WM\_CAP\_SET\_SCALE message enables or disables scaling of the preview video images.</summary>
            <returns>
            <para><span id="f"></span><span id="F"></span>*f* Preview scaling flag. Specify **TRUE** for this parameter to stretch preview frames to the size of the capture window or **FALSE** to display them at their natural size.</para>
            <para>Returns **TRUE** if successful or **FALSE** otherwise.</para>
            </returns>
            <remarks>
            <para>Scaling preview images controls the immediate presentation of captured frames within the capture window. It has no effect on the size of the frames saved to file. Scaling has no effect when using overlay to display video in the frame buffer.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/Multimedia/wm-cap-set-scale#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_CAP_GET_STATUS">
            <summary>The WM\_CAP\_GET\_STATUS message retrieves the status of the capture window. You can send this message explicitly or by using the capGetStatus macro.</summary>
            <returns>
            <para><span id="wSize"></span><span id="wsize"></span><span id="WSIZE"></span>*wSize* Size, in bytes, of the structure referenced by**s**.</para>
            <para><span id="s"></span><span id="S"></span>*s* Pointer to a [**CAPSTATUS**](/windows/win32/api/vfw/ns-vfw-capstatus) structure.</para>
            <para>Returns **TRUE** if successful or **FALSE** if the capture window is not connected to a capture driver.</para>
            </returns>
            <remarks>The [**CAPSTATUS**](/windows/win32/api/vfw/ns-vfw-capstatus) structure contains the current state of the capture window. Since this state is dynamic and changes in response to various messages, the application should initialize this structure after sending the [**WM\_CAP\_DLG\_VIDEOFORMAT**](wm-cap-dlg-videoformat.md) message (or using the [**capDlgVideoFormat**](/windows/desktop/api/Vfw/nf-vfw-capdlgvideoformat) macro) and whenever it needs to enable menu items or determine the actual state of the window.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_CAP_SET_SCROLL">
            <summary>The WM\_CAP\_SET\_SCROLL message defines the portion of the video frame to display in the capture window.</summary>
            <returns>
            <para><span id="lpP"></span><span id="lpp"></span><span id="LPP"></span>*lpP* Address to contain the desired scroll position.</para>
            <para>Returns **TRUE** if successful or **FALSE** otherwise.</para>
            </returns>
            <remarks>The scroll position affects the image in both preview and overlay modes.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_CAP_GRAB_FRAME">
            <summary>The WM\_CAP\_GRAB\_FRAME message retrieves and displays a single frame from the capture driver. After capture, overlay and preview are disabled. You can send this message explicitly or by using the capGrabFrame macro.</summary>
            <returns>Returns **TRUE** if successful or **FALSE** otherwise.</returns>
            <remarks>For information about installing callback functions, see the [**WM\_CAP\_SET\_CALLBACK\_ERROR**](wm-cap-set-callback-error.md) and [**WM\_CAP\_SET\_CALLBACK\_FRAME**](wm-cap-set-callback-frame.md) messages.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_CAP_GRAB_FRAME_NOSTOP">
            <summary>The WM\_CAP\_GRAB\_FRAME\_NOSTOP message fills the frame buffer with a single uncompressed frame from the capture device and displays it.</summary>
            <returns>Returns **TRUE** if successful or **FALSE** otherwise.</returns>
            <remarks>For information about installing callback functions, see the [**WM\_CAP\_SET\_CALLBACK\_ERROR**](wm-cap-set-callback-error.md) and [**WM\_CAP\_SET\_CALLBACK\_FRAME**](wm-cap-set-callback-frame.md) messages.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_CAP_SEQUENCE">
            <summary>The WM\_CAP\_SEQUENCE message initiates streaming video and audio capture to a file. You can send this message explicitly or by using the capCaptureSequence macro.</summary>
            <returns>
            <para>Returns **TRUE** if successful or **FALSE** otherwise. If an error occurs and an error callback function is set using the [**WM\_CAP\_SET\_CALLBACK\_ERROR**](wm-cap-set-callback-error.md) message, the error callback function is called.</para>
            </returns>
            <remarks>
            <para>If you want to alter the parameters controlling streaming capture, use the [**WM\_CAP\_SET\_SEQUENCE\_SETUP**](wm-cap-set-sequence-setup.md) message prior to starting the capture. By default, the capture window does not allow other applications to continue running during capture. To override this, either set the **fYield** member of the [**CAPTUREPARMS**](/windows/win32/api/vfw/ns-vfw-captureparms) structure to **TRUE**, or install a yield callback function. During streaming capture, the capture window can optionally issue notifications to your application of specific types of conditions. To install callback procedures for these notifications, use the following messages: -   [**WM\_CAP\_SET\_CALLBACK\_ERROR**](wm-cap-set-callback-error.md) -   [**WM\_CAP\_SET\_CALLBACK\_STATUS**](wm-cap-set-callback-status.md) -   [**WM\_CAP\_SET\_CALLBACK\_YIELD**](wm-cap-set-callback-yield.md) -   [**WM\_CAP\_SET\_CALLBACK\_VIDEOSTREAM**](wm-cap-set-callback-videostream.md) -   [**WM\_CAP\_SET\_CALLBACK\_WAVESTREAM**](wm-cap-set-callback-wavestream.md)</para>
            <para><see href="https://learn.microsoft.com/windows/win32/Multimedia/wm-cap-sequence#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_CAP_SEQUENCE_NOFILE">
            <summary>The WM\_CAP\_SEQUENCE\_NOFILE message initiates streaming video capture without writing data to a file. You can send this message explicitly or by using the capCaptureSequenceNoFile macro.</summary>
            <returns>Returns **TRUE** if successful or **FALSE** otherwise.</returns>
            <remarks>
            <para>This message is useful in conjunction with video stream or waveform-audio stream callback functions that let your application use the video and audio data directly. If you want to alter the parameters controlling streaming capture, use the [**WM\_CAP\_SET\_SEQUENCE\_SETUP**](wm-cap-set-sequence-setup.md) message prior to starting the capture. By default, the capture window does not allow other applications to continue running during capture. To override this, either set the **fYield** member of the [**CAPTUREPARMS**](/windows/win32/api/vfw/ns-vfw-captureparms) structure to **TRUE**, or install a yield callback function. During streaming capture, the capture window can optionally issue notifications to your application of specific types of conditions. To install callback procedures for these notifications, use the following messages: -   [**WM\_CAP\_SET\_CALLBACK\_ERROR**](wm-cap-set-callback-error.md) -   [**WM\_CAP\_SET\_CALLBACK\_STATUS**](wm-cap-set-callback-status.md) -   [**WM\_CAP\_SET\_CALLBACK\_YIELD**](wm-cap-set-callback-yield.md) -   [**WM\_CAP\_SET\_CALLBACK\_VIDEOSTREAM**](wm-cap-set-callback-videostream.md) -   [**WM\_CAP\_SET\_CALLBACK\_WAVESTREAM**](wm-cap-set-callback-wavestream.md)</para>
            <para><see href="https://learn.microsoft.com/windows/win32/Multimedia/wm-cap-sequence-nofile#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_CAP_SET_SEQUENCE_SETUP">
            <summary>The WM\_CAP\_SET\_SEQUENCE\_SETUP message sets the configuration parameters used with streaming capture. You can send this message explicitly or by using the capCaptureSetSetup macro.</summary>
            <returns>
            <para><span id="wSize"></span><span id="wsize"></span><span id="WSIZE"></span>*wSize* Size, in bytes, of the structure referenced by**s**.</para>
            <para><span id="psCapParms"></span><span id="pscapparms"></span><span id="PSCAPPARMS"></span>*psCapParms* Pointer to a [**CAPTUREPARMS**](/windows/win32/api/vfw/ns-vfw-captureparms) structure.</para>
            <para>Returns **TRUE** if successful or **FALSE** otherwise.</para>
            </returns>
            <remarks>For information about the parameters used to control streaming capture, see the [**CAPTUREPARMS**](/windows/win32/api/vfw/ns-vfw-captureparms) structure.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_CAP_GET_SEQUENCE_SETUP">
            <summary>The WM\_CAP\_GET\_SEQUENCE\_SETUP message retrieves the current settings of the streaming capture parameters. You can send this message explicitly or by using the capCaptureGetSetup macro.</summary>
            <returns>
            <para><span id="wSize"></span><span id="wsize"></span><span id="WSIZE"></span>*wSize* Size, in bytes, of the structure referenced by**s**.</para>
            <para><span id="s"></span><span id="S"></span>*s* Pointer to a [**CAPTUREPARMS**](/windows/win32/api/vfw/ns-vfw-captureparms) structure.</para>
            <para>Returns **TRUE** if successful or **FALSE** otherwise.</para>
            </returns>
            <remarks>For information about the parameters used to control streaming capture, see the [**CAPTUREPARMS**](/windows/win32/api/vfw/ns-vfw-captureparms) structure.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_CAP_SET_MCI_DEVICE">
            <summary>The WM\_CAP\_SET\_MCI\_DEVICE message specifies the name of the MCI video device to be used to capture data. You can send this message explicitly or by using the capSetMCIDeviceName macro.</summary>
            <returns>
            <para><span id="szName"></span><span id="szname"></span><span id="SZNAME"></span>*szName* Pointer to a null-terminated string containing the name of the device.</para>
            <para>Returns **TRUE** if successful or **FALSE** otherwise.</para>
            </returns>
            <remarks>This message stores the MCI device name in an internal structure. It does not open or access the device. The default device name is **NULL**.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_CAP_GET_MCI_DEVICE">
            <summary>The WM\_CAP\_GET\_MCI\_DEVICE message retrieves the name of an MCI device previously set with the WM\_CAP\_SET\_MCI\_DEVICE message. You can send this message explicitly or by using the capGetMCIDeviceName macro.</summary>
            <returns>
            <para><span id="wSize"></span><span id="wsize"></span><span id="WSIZE"></span>*wSize* Length, in bytes, of the buffer referenced by**szName**.</para>
            <para><span id="szName"></span><span id="szname"></span><span id="SZNAME"></span>*szName* Pointer to a null-terminated string that contains the MCI device name.</para>
            <para>Returns **TRUE** if successful or **FALSE** otherwise.</para>
            </returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/Multimedia/wm-cap-get-mci-device">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_CAP_STOP">
            <summary>The WM\_CAP\_STOP message stops the capture operation. You can send this message explicitly or by using the capCaptureStop macro.</summary>
            <returns>Returns **TRUE** if successful or **FALSE** otherwise.</returns>
            <remarks>The capture operation must yield to use this message. Use the [**WM\_CAP\_ABORT**](wm-cap-abort.md) message to abandon the current capture operation.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_CAP_ABORT">
            <summary>The WM\_CAP\_ABORT message stops the capture operation.</summary>
            <returns>Returns **TRUE** if successful or **FALSE** otherwise.</returns>
            <remarks>
            <para>The capture operation must yield to use this message. Use the [**WM\_CAP\_STOP**](wm-cap-stop.md) message to halt step capture at the current position, and then capture audio.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/Multimedia/wm-cap-abort#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_CAP_SINGLE_FRAME_OPEN">
            <summary>The WM\_CAP\_SINGLE\_FRAME\_OPEN message opens the capture file for single-frame capturing. Any previous information in the capture file is overwritten. You can send this message explicitly or by using the capCaptureSingleFrameOpen macro.</summary>
            <returns>Returns **TRUE** if successful or **FALSE** otherwise.</returns>
            <remarks>For information about installing callback functions, see the [**WM\_CAP\_SET\_CALLBACK\_ERROR**](wm-cap-set-callback-error.md) and [**WM\_CAP\_SET\_CALLBACK\_FRAME**](wm-cap-set-callback-frame.md) messages.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_CAP_SINGLE_FRAME_CLOSE">
            <summary>The WM\_CAP\_SINGLE\_FRAME\_CLOSE message closes the capture file opened by the WM\_CAP\_SINGLE\_FRAME\_OPEN message. You can send this message explicitly or by using the capCaptureSingleFrameClose macro.</summary>
            <returns>Returns **TRUE** if successful or **FALSE** otherwise.</returns>
            <remarks>For information about installing callback functions, see the [**WM\_CAP\_SET\_CALLBACK\_ERROR**](wm-cap-set-callback-error.md) and [**WM\_CAP\_SET\_CALLBACK\_FRAME**](wm-cap-set-callback-frame.md) messages.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_CAP_SINGLE_FRAME">
            <summary>The WM\_CAP\_SINGLE\_FRAME message appends a single frame to a capture file that was opened using the WM\_CAP\_SINGLE\_FRAME\_OPEN message. You can send this message explicitly or by using the capCaptureSingleFrame macro.</summary>
            <returns>Returns **TRUE** if successful or **FALSE** otherwise.</returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/Multimedia/wm-cap-single-frame">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_CAP_PAL_OPEN">
            <summary>The WM\_CAP\_PAL\_OPEN message loads a new palette from a palette file and passes it to a capture driver.</summary>
            <returns>
            <para><span id="szName"></span><span id="szname"></span><span id="SZNAME"></span>*szName* Pointer to a null-terminated string containing the palette filename.</para>
            <para>Returns **TRUE** if successful or **FALSE** otherwise. If an error occurs and an error callback function is set using the [**WM\_CAP\_SET\_CALLBACK\_ERROR**](wm-cap-set-callback-error.md) message, the error callback function is called.</para>
            </returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/Multimedia/wm-cap-pal-open">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_CAP_PAL_SAVE">
            <summary>The WM\_CAP\_PAL\_SAVE message saves the current palette to a palette file. Palette files typically use the filename extension .PAL. You can send this message explicitly or by using the capPaletteSave macro.</summary>
            <returns>
            <para><span id="szName"></span><span id="szname"></span><span id="SZNAME"></span>*szName* Pointer to a null-terminated string containing the palette filename.</para>
            <para>Returns **TRUE** if successful or **FALSE** otherwise. If an error occurs and an error callback function is set using the [**WM\_CAP\_SET\_CALLBACK\_ERROR**](wm-cap-set-callback-error.md) message, the error callback function is called.</para>
            </returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/Multimedia/wm-cap-pal-save">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_CAP_PAL_PASTE">
            <summary>The WM\_CAP\_PAL\_PASTE message copies the palette from the clipboard and passes it to a capture driver. You can send this message explicitly or by using the capPalettePaste macro.</summary>
            <returns>
            <para>Returns **TRUE** if successful or **FALSE** otherwise. If an error occurs and an error callback function is set using the [**WM\_CAP\_SET\_CALLBACK\_ERROR**](wm-cap-set-callback-error.md) message, the error callback function is called.</para>
            </returns>
            <remarks>A capture driver uses a palette when required by the specified digitized video format.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_CAP_PAL_AUTOCREATE">
            <summary>The WM\_CAP\_PAL\_AUTOCREATE message requests that the capture driver sample video frames and automatically create a new palette. You can send this message explicitly or by using the capPaletteAuto macro.</summary>
            <returns>
            <para><span id="iFrames"></span><span id="iframes"></span><span id="IFRAMES"></span>*iFrames* Number of frames to sample.</para>
            <para><span id="iColors"></span><span id="icolors"></span><span id="ICOLORS"></span>*iColors* Number of colors in the palette. The maximum value for this parameter is 256.</para>
            <para>Returns **TRUE** if successful or **FALSE** otherwise. If an error occurs and an error callback function is set using the [**WM\_CAP\_SET\_CALLBACK\_ERROR**](wm-cap-set-callback-error.md) message, the error callback function is called.</para>
            </returns>
            <remarks>The sampled video sequence should include all the colors you want in the palette. To obtain the best palette, you might have to sample the whole sequence rather than a portion of it.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_CAP_PAL_MANUALCREATE">
            <summary>The WM\_CAP\_PAL\_MANUALCREATE message requests that the capture driver manually sample video frames and create a new palette. You can send this message explicitly or by using the capPaletteManual macro.</summary>
            <returns>
            <para><span id="fGrab"></span><span id="fgrab"></span><span id="FGRAB"></span>*fGrab* Palette histogram flag. Set this parameter to **TRUE** for each frame included in creating the optimal palette. After the last frame has been collected, set this parameter to **FALSE** to calculate the optimal palette and send it to the capture driver.</para>
            <para><span id="iColors"></span><span id="icolors"></span><span id="ICOLORS"></span>*iColors* Number of colors in the palette. The maximum value for this parameter is 256. This value is used only during collection of the first frame in a sequence.</para>
            <para>Returns **TRUE** if successful or **FALSE** otherwise. If an error occurs and an error callback function is set using the [**WM\_CAP\_SET\_CALLBACK\_ERROR**](wm-cap-set-callback-error.md) message, the error callback function is called.</para>
            </returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/Multimedia/wm-cap-pal-manualcreate">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_CAP_SET_CALLBACK_CAPCONTROL">
            <summary>The WM\_CAP\_SET\_CALLBACK\_CAPCONTROL message sets a callback function in the application giving it precise recording control. You can send this message explicitly or by using the capSetCallbackOnCapControl macro.</summary>
            <returns>
            <para><span id="fpProc"></span><span id="fpproc"></span><span id="FPPROC"></span>*fpProc* Pointer to the callback function, of type [**capControlCallback**](/windows/desktop/api/Vfw/nc-vfw-capcontrolcallback). Specify **NULL** for this parameter to disable a previously installed callback function.</para>
            <para>Returns **TRUE** if successful or **FALSE** if a streaming capture or a single-frame capture session is in progress.</para>
            </returns>
            <remarks>A single callback function is used to give the application precise control over the moments that streaming capture begins and completes. The capture window first calls the procedure with *nState* set to CONTROLCALLBACK\_PREROLL after all buffers have been allocated and all other capture preparations have finished. This gives the application the ability to preroll video sources, returning from the callback function at the exact moment recording is to begin. A return value of **TRUE** from the callback function continues capture, and a return value of **FALSE** aborts capture. After capture begins, this callback function will be called frequently with *nState* set to CONTROLCALLBACK\_CAPTURING to allow the application to end capture by returning **FALSE**.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_ADSPROP_NOTIFY_PAGEINIT">
            <summary>An Active Directory property sheet extension calls the ADsPropGetInitInfo to obtain data about regarding the directory object that the property sheet extension applies to.</summary>
            <returns>This message has no return value.</returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/AD/wm-adsprop-notify-pageinit">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_ADSPROP_NOTIFY_PAGEHWND">
            <summary>An Active Directory directory service property sheet extension calls the ADsPropSetHwnd to inform the notification object of the property page window handle.</summary>
            <returns>This message has no return value.</returns>
            <remarks>An Active Directory property sheet extension normally calls the [**ADsPropSetHwnd**](/windows/desktop/api/Adsprop/nf-adsprop-adspropsethwnd) function while processing the [**WM\_INITDIALOG**](../dlgbox/wm-initdialog.md) message.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_ADSPROP_NOTIFY_CHANGE">
            <summary>The WM\_ADSPROP\_NOTIFY\_CHANGE message is used internally by the notification object.</summary>
            <returns>This message has no return value.</returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/AD/wm-adsprop-notify-change">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_ADSPROP_NOTIFY_APPLY">
            <summary>An Active Directory directory service property sheet extension sends the WM\_ADSPROP\_NOTIFY\_APPLY message to the notification object if the property page PSN\_APPLY handler succeeds.</summary>
            <returns>This message has no return value.</returns>
            <remarks>When adding pages to the Active Directory Manager MMC snap-in, Active Directory MMC property sheets create the notification objects by a call to the [**ADsPropCreateNotifyObj**](/windows/desktop/api/Adsprop/nf-adsprop-adspropcreatenotifyobj) function, and then passes the notification object handle to each property page.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_ADSPROP_NOTIFY_SETFOCUS">
            <summary>The WM\_ADSPROP\_NOTIFY\_SETFOCUS message is used internally by the notification object.</summary>
            <returns>This message has no return value.</returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/AD/wm-adsprop-notify-setfocus">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_ADSPROP_NOTIFY_FOREGROUND">
            <summary>The WM\_ADSPROP\_NOTIFY\_FOREGROUND message is used internally by the notification object.</summary>
            <returns>This message has no return value.</returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/AD/wm-adsprop-notify-foreground">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_ADSPROP_NOTIFY_EXIT">
            <summary>An Active Directory property sheet extension sends the WM\_ADSPROP\_NOTIFY\_EXIT message to the notification object when the notification object is no longer required.</summary>
            <returns>This message has no return value.</returns>
            <remarks>The notification object will delete itself in response to this message. When this message has been sent, the notification object handle should be considered invalid.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_ADSPROP_NOTIFY_ERROR">
            <summary>The WM\_ADSPROP\_NOTIFY\_ERROR message adds an error message to a list of error messages that are displayed by calling the ADsPropShowErrorDialog function.</summary>
            <returns>This message has no return value.</returns>
            <remarks>
            <para>The [**ADsPropSendErrorMessage**](/windows/desktop/api/Adsprop/nf-adsprop-adspropsenderrormessage) function is the preferred method of sending this message. The error messages added by the **WM\_ADSPROP\_NOTIFY\_ERROR** message are accumulated until [**ADsPropShowErrorDialog**](/windows/desktop/api/Adsprop/nf-adsprop-adspropshowerrordialog) is called. **ADsPropShowErrorDialog** combines and displays the accumulated error messages. When the error dialog is dismissed, the accumulated error messages are deleted.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/AD/wm-adsprop-notify-error#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_RASDIALEVENT">
            <summary>The operating system sends a WM\_RASDIALEVENT message to a window procedure when a change of state event occurs during a RAS connection process.</summary>
            <returns>If an application processes this message, it should return **TRUE**.</returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/RRAS/wm-rasdialevent">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.PInvoke.CloseHandle(Windows.Win32.Foundation.HANDLE)">
            <summary>Closes an open object handle.</summary>
            <param name="hObject">A valid handle to an open object.</param>
            <returns>
            <para>If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. If the application is running under a debugger,  the function will throw an exception if it receives either a  handle value that is not valid  or a pseudo-handle value. This can happen if you close a handle twice, or if you  call <b>CloseHandle</b> on a handle returned by the <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-findfirstfilea">FindFirstFile</a> function instead of calling the <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-findclose">FindClose</a> function.</para>
            </returns>
            <remarks>
            <para>The <b>CloseHandle</b> function closes handles to the following objects: </para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/handleapi/nf-handleapi-closehandle#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.PInvoke.FreeLibrary(Windows.Win32.Foundation.HMODULE)">
            <summary>Frees the loaded dynamic-link library (DLL) module and, if necessary, decrements its reference count.</summary>
            <param name="hLibModule">
            <para>A handle to the loaded library module. The <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-loadlibrarya">LoadLibrary</a>, <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-loadlibraryexa">LoadLibraryEx</a>, <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-getmodulehandlea">GetModuleHandle</a>, or <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-getmodulehandleexa">GetModuleHandleEx</a> function returns this handle.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/libloaderapi/nf-libloaderapi-freelibrary#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <returns>
            <para>If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call the <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.</para>
            </returns>
            <remarks>
            <para>The system maintains a per-process reference count for each loaded module. A  module that was loaded at process initialization due to load-time dynamic linking has a reference count of one. The reference count for a module is incremented each time the  module is loaded by a call to <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-loadlibrarya">LoadLibrary</a>. The reference count is also incremented by a call to <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-loadlibraryexa">LoadLibraryEx</a> unless the  module  is being loaded for the first time and is being loaded as   a data or image file. The reference count is decremented each time the <b>FreeLibrary</b> or <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-freelibraryandexitthread">FreeLibraryAndExitThread</a> function is called for the module. When a  module's reference count reaches zero or the process terminates, the system unloads the module from the address space of the  process. Before unloading a library module, the system enables the module to detach from the process by calling the module's <a href="https://docs.microsoft.com/windows/desktop/Dlls/dllmain">DllMain</a> function, if it has one, with the DLL_PROCESS_DETACH value. Doing so gives the library module an opportunity to clean up resources allocated on behalf of the current process. After the entry-point function returns, the library module is removed from the address space of the current process. It is not safe to call <b>FreeLibrary</b> from <a href="https://docs.microsoft.com/windows/desktop/Dlls/dllmain">DllMain</a>. For more information, see the Remarks section in <a href="https://docs.microsoft.com/windows/desktop/Dlls/dllmain">DllMain</a>. Calling <b>FreeLibrary</b> does not affect other processes that are using the same module. Use caution when calling <b>FreeLibrary</b> with a handle returned by <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-getmodulehandlea">GetModuleHandle</a>. The <b>GetModuleHandle</b> function does not increment a module's reference count, so passing this handle to <b>FreeLibrary</b> can cause a module to be unloaded prematurely. A thread that must unload the DLL in which it is executing and then terminate itself should call <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-freelibraryandexitthread">FreeLibraryAndExitThread</a> instead of calling <b>FreeLibrary</b> and <b>ExitThread</b> separately. Otherwise, a race condition can occur. For details, see the Remarks section of <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-freelibraryandexitthread">FreeLibraryAndExitThread</a>.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/libloaderapi/nf-libloaderapi-freelibrary#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.PInvoke.LoadLibrary(System.String)">
            <inheritdoc cref="M:Windows.Win32.PInvoke.LoadLibrary(Windows.Win32.Foundation.PCWSTR)"/>
        </member>
        <member name="M:Windows.Win32.PInvoke.LoadLibrary(Windows.Win32.Foundation.PCWSTR)">
            <summary>Loads the specified module into the address space of the calling process. (LoadLibraryW)</summary>
            <param name="lpLibFileName">
            <para>The name of the module. This can be either a library module (a .dll file) or an executable module (an .exe file). If the specified module is an executable module, static imports are not loaded; instead, the module is loaded as if by <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-loadlibraryexw">LoadLibraryEx</a> with the `DONT_RESOLVE_DLL_REFERENCES` flag. The name specified is the file name of the module and is not related to the name stored in the library module itself, as specified by the <b>LIBRARY</b> keyword in the module-definition (.def) file. If the string specifies a full path, the function searches only that path for the module. If the string specifies a relative path or a module name without a path, the function uses a standard search strategy to find the module; for more information, see the Remarks. If the function cannot find the  module, the function fails. When specifying a path, be sure to use backslashes (\\), not forward slashes (/). For more information about paths, see <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming a File or Directory</a>. If the string specifies a module name without a path and the file name extension is omitted, the function appends the default library extension ".DLL" to the module name. To prevent the function from appending ".DLL" to the module name, include a trailing point character (.) in the module name string.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/libloaderapi/nf-libloaderapi-loadlibraryw#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <returns>
            <para>If the function succeeds, the return value is a handle to the module. If the function fails, the return value is NULL. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
            </returns>
            <remarks>
            <para>To enable or disable error messages displayed by the loader during DLL loads, use the <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-seterrormode">SetErrorMode</a> function. <b>LoadLibrary</b> can be used to load a library module into the address space of the process and return a handle that can be used in <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-getprocaddress">GetProcAddress</a> to get the address of a DLL function. <b>LoadLibrary</b> can also be used to load other executable modules. For example, the function can specify an .exe file to get a handle that can be used in <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-findresourcea">FindResource</a> or <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-loadresource">LoadResource</a>. However, do not use <b>LoadLibrary</b> to run an .exe file. Instead, use the <a href="https://docs.microsoft.com/windows/desktop/api/processthreadsapi/nf-processthreadsapi-createprocessa">CreateProcess</a> function. If the specified module is a DLL that is not already loaded for the calling process, the system calls the DLL's <a href="https://docs.microsoft.com/windows/desktop/Dlls/dllmain">DllMain</a> function with the <b>DLL_PROCESS_ATTACH</b> value. If <b>DllMain</b> returns <b>TRUE</b>, <b>LoadLibrary</b> returns a handle to the module. If <b>DllMain</b> returns <b>FALSE</b>, the system unloads the DLL from the process address space and <b>LoadLibrary</b> returns <b>NULL</b>. It is not safe to call <b>LoadLibrary</b> from <b>DllMain</b>. For more information, see the Remarks section in <b>DllMain</b>. Module handles are not global or inheritable. A call to <b>LoadLibrary</b> by one process does not produce a handle that another process can use — for example, in calling <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-getprocaddress">GetProcAddress</a>. The other process must make its own call to <b>LoadLibrary</b> for the module before calling <b>GetProcAddress</b>. If <i>lpFileName</i> does not include a path and there is more than one loaded module with the same base name and extension, the function returns a handle to the module that was loaded first. If no file name extension is specified in the <i>lpFileName</i> parameter, the default library extension .dll is appended. However, the file name string can include a trailing point character (.) to indicate that the module name has no extension. When no path is specified, the function searches for loaded modules whose base name matches the base name of the module to be loaded. If the name matches, the load succeeds. Otherwise, the function searches for the file. The first directory searched is the directory containing the image file used to create the calling process (for more information, see the <a href="https://docs.microsoft.com/windows/desktop/api/processthreadsapi/nf-processthreadsapi-createprocessa">CreateProcess</a> function). Doing this allows private dynamic-link library (DLL) files associated with a process to be found without adding the process's installed directory to the PATH environment variable. If a relative path is specified, the entire relative path is appended to every token in the DLL search path list. To load a module from a relative path without searching any other path, use <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-getfullpathnamea">GetFullPathName</a> to get a nonrelative path and call <b>LoadLibrary</b> with the nonrelative path. For more information on the DLL search order, see <a href="https://docs.microsoft.com/windows/desktop/Dlls/dynamic-link-library-search-order">Dynamic-Link Library Search Order</a>. The search path can be altered using the <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-setdlldirectorya">SetDllDirectory</a> function. This solution is recommended instead of using <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-setcurrentdirectory">SetCurrentDirectory</a> or hard-coding the full path to the DLL. If a path is specified and there is a redirection file for the application, the function searches for the module in the application's directory. If the module exists in the application's directory, <b>LoadLibrary</b> ignores the specified path and loads the module from the application's directory. If the module does not exist in the application's directory, <b>LoadLibrary</b> loads the module from the specified directory. For more information, see <a href="https://docs.microsoft.com/windows/desktop/Dlls/dynamic-link-library-redirection">Dynamic Link Library Redirection</a>. If you call <b>LoadLibrary</b> with the name of an assembly without a path specification and the assembly is listed in the system compatible manifest, the call is automatically redirected to the side-by-side assembly. The system maintains a per-process reference count on all loaded modules. Calling <b>LoadLibrary</b> increments the reference count. Calling the <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-freelibrary">FreeLibrary</a> or <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-freelibraryandexitthread">FreeLibraryAndExitThread</a> function decrements the reference count. The system unloads a module when its reference count reaches zero or when the process terminates (regardless of the reference count). <b>Windows Server 2003 and Windows XP:  </b>The Visual C++ compiler supports a syntax that enables you to declare thread-local variables: <b>_declspec(thread)</b>. If you use this syntax in a DLL, you will not be able to load the DLL explicitly using <b>LoadLibrary</b> on versions of Windows prior to Windows Vista. If your DLL will be loaded explicitly, you must use the thread local storage functions instead of <b>_declspec(thread)</b>. For an example, see <a href="https://docs.microsoft.com/windows/desktop/Dlls/using-thread-local-storage-in-a-dynamic-link-library">Using Thread Local Storage in a Dynamic Link Library</a>. <h3><a id="Security_Remarks"></a><a id="security_remarks"></a><a id="SECURITY_REMARKS"></a>Security Remarks</h3> Do not use the <a href="https://docs.microsoft.com/windows/desktop/api/processenv/nf-processenv-searchpathw">SearchPath</a> function to retrieve a path to a DLL for a subsequent <b>LoadLibrary</b> call. The <b>SearchPath</b> function uses a different search order than <b>LoadLibrary</b> and it does not use safe process search mode unless this is explicitly enabled by calling <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-setsearchpathmode">SetSearchPathMode</a> with <b>BASE_SEARCH_PATH_ENABLE_SAFE_SEARCHMODE</b>. Therefore, <b>SearchPath</b> is likely to first search the user’s current working directory for the specified DLL. If an attacker has copied a malicious version of a DLL into the current working directory, the path retrieved by <b>SearchPath</b> will point to the malicious DLL, which <b>LoadLibrary</b> will then load. Do not make assumptions about the operating system version based on a <b>LoadLibrary</b> call that searches for a DLL. If the application is running in an environment where the DLL is legitimately not present but a malicious version of the DLL is in the search path, the malicious version of the DLL may be loaded. Instead, use the recommended techniques described in <a href="https://docs.microsoft.com/windows/desktop/SysInfo/getting-the-system-version">Getting the System Version</a>.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/libloaderapi/nf-libloaderapi-loadlibraryw#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.PInvoke.GetClassLong(Windows.Win32.Foundation.HWND,Windows.Win32.UI.WindowsAndMessaging.GET_CLASS_LONG_INDEX)">
            <summary>Retrieves the specified 32-bit (DWORD) value from the WNDCLASSEX structure associated with the specified window. (Unicode)</summary>
            <param name="hWnd">
            <para>Type: <b>HWND</b> A handle to the window and, indirectly, the class to which the window belongs.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-getclasslongw#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <param name="nIndex">Type: <b>int</b></param>
            <returns>
            <para>Type: <b>DWORD</b> If the function succeeds, the return value is the requested value. If the function fails, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
            </returns>
            <remarks>
            <para>Reserve extra class memory by specifying a nonzero value in the <b>cbClsExtra</b> member of the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-wndclassexa">WNDCLASSEX</a> structure used with the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-registerclassexa">RegisterClassEx</a> function.</para>
            <para>> [!NOTE] > The winuser.h header defines GetClassLong as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-getclasslongw#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.PInvoke.GetFocus">
            <summary>Retrieves the handle to the window that has the keyboard focus, if the window is attached to the calling thread's message queue.</summary>
            <returns>
            <para>Type: <b>HWND</b> The return value is the handle to the window with the keyboard focus. If the calling thread's message queue does not have an associated window with the keyboard focus, the return value is <b>NULL</b>.</para>
            </returns>
            <remarks>
            <para><b>GetFocus</b> returns the window with the keyboard focus for the current thread's message queue. If <b>GetFocus</b> returns <b>NULL</b>, another thread's queue may be attached to a window that has the keyboard focus. Use the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-getforegroundwindow">GetForegroundWindow</a> function to retrieve the handle to the window with which the user is currently working. You can associate your thread's message queue with the windows owned by another thread by using the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-attachthreadinput">AttachThreadInput</a> function. To get the window with the keyboard focus on the foreground queue or the queue of another thread, use the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-getguithreadinfo">GetGUIThreadInfo</a> function.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-getfocus#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.PInvoke.GetKeyboardState(System.Span{System.Byte})">
            <inheritdoc cref="M:Windows.Win32.PInvoke.GetKeyboardState(System.Byte*)"/>
        </member>
        <member name="M:Windows.Win32.PInvoke.GetKeyboardState(System.Byte*)">
            <summary>Copies the status of the 256 virtual keys to the specified buffer.</summary>
            <param name="lpKeyState">
            <para>Type: <b>PBYTE</b> The 256-byte array that receives the status data for each virtual key.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-getkeyboardstate#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <returns>
            <para>Type: <b>BOOL</b> If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
            </returns>
            <remarks>
            <para>An application can call this function to retrieve the current status of all the virtual keys. The status changes as a thread removes keyboard messages from its message queue. The status does not change as keyboard messages are posted to the thread's message queue, nor does it change as keyboard messages are posted to or retrieved from message queues of other threads. (Exception: Threads that are connected through <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-attachthreadinput">AttachThreadInput</a> share the same keyboard state.) When the function returns, each member of the array pointed to by the <i>lpKeyState</i> parameter contains status data for a virtual key. If the high-order bit is 1, the key is down; otherwise, it is up. If the key is a toggle key, for example CAPS LOCK, then the low-order bit is 1 when the key is toggled and is 0 if the key is untoggled.  The low-order bit is meaningless for non-toggle keys. A toggle key is said to be toggled when it is turned on. A toggle key's indicator light (if any) on the keyboard will be on when the key is toggled, and off when the key is untoggled. To retrieve status information for an individual key, use the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-getkeystate">GetKeyState</a> function. To retrieve the current state for an individual key regardless of whether the corresponding keyboard message has been retrieved from the message queue, use the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-getasynckeystate">GetAsyncKeyState</a> function. An application can use the virtual-key code constants <b>VK_SHIFT</b>, <b>VK_CONTROL</b> and <b>VK_MENU</b> as indices into the array pointed to by <i>lpKeyState</i>. This gives the status of the SHIFT, CTRL, or ALT keys without distinguishing between left and right. An application can also use the following virtual-key code constants as indices to distinguish between the left and right instances of those keys: </para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-getkeyboardstate#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.PInvoke.GetMonitorInfo(Windows.Win32.Graphics.Gdi.HMONITOR,Windows.Win32.Graphics.Gdi.MONITORINFO@)">
            <inheritdoc cref="M:Windows.Win32.PInvoke.GetMonitorInfo(Windows.Win32.Graphics.Gdi.HMONITOR,Windows.Win32.Graphics.Gdi.MONITORINFO*)"/>
        </member>
        <member name="M:Windows.Win32.PInvoke.GetMonitorInfo(Windows.Win32.Graphics.Gdi.HMONITOR,Windows.Win32.Graphics.Gdi.MONITORINFO*)">
            <summary>The GetMonitorInfo function retrieves information about a display monitor. (Unicode)</summary>
            <param name="hMonitor">A handle to the display monitor of interest.</param>
            <param name="lpmi">
            <para>A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-monitorinfo">MONITORINFO</a> or <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-monitorinfoexa">MONITORINFOEX</a> structure that receives information about the specified display monitor. You must set the <b>cbSize</b> member of the structure to sizeof(MONITORINFO) or sizeof(MONITORINFOEX) before calling the <b>GetMonitorInfo</b> function. Doing so lets the function determine the type of structure you are passing to it. The <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-monitorinfoexa">MONITORINFOEX</a> structure is a superset of the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-monitorinfo">MONITORINFO</a> structure. It has one additional member: a string that contains a name for the display monitor. Most applications have no use for a display monitor name, and so can save some bytes by using a <b>MONITORINFO</b> structure.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-getmonitorinfow#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <returns>
            <para>If the function succeeds, the return value is nonzero. If the function fails, the return value is zero.</para>
            </returns>
            <remarks>
            <para>> [!NOTE] > The winuser.h header defines GetMonitorInfo as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-getmonitorinfow#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.PInvoke.LoadImage(System.Runtime.InteropServices.SafeHandle,System.String,Windows.Win32.UI.WindowsAndMessaging.GDI_IMAGE_TYPE,System.Int32,System.Int32,Windows.Win32.UI.WindowsAndMessaging.IMAGE_FLAGS)">
            <inheritdoc cref="M:Windows.Win32.PInvoke.LoadImage(Windows.Win32.Foundation.HINSTANCE,Windows.Win32.Foundation.PCWSTR,Windows.Win32.UI.WindowsAndMessaging.GDI_IMAGE_TYPE,System.Int32,System.Int32,Windows.Win32.UI.WindowsAndMessaging.IMAGE_FLAGS)"/>
        </member>
        <member name="M:Windows.Win32.PInvoke.LoadImage(Windows.Win32.Foundation.HINSTANCE,Windows.Win32.Foundation.PCWSTR,Windows.Win32.UI.WindowsAndMessaging.GDI_IMAGE_TYPE,System.Int32,System.Int32,Windows.Win32.UI.WindowsAndMessaging.IMAGE_FLAGS)">
            <summary>Loads an icon, cursor, animated cursor, or bitmap. (Unicode)</summary>
            <param name="hInst">
            <para>Type: <b>HINSTANCE</b> A handle to the module of either a DLL or executable (.exe) that contains the image to be loaded. For more information, see <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-getmodulehandlea">GetModuleHandle</a>. Note that as of  32-bit Windows, an instance handle (<b>HINSTANCE</b>), such as the application instance handle exposed by system function call of <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-winmain">WinMain</a>, and a module handle (<b>HMODULE</b>) are the same thing.</para>
            <para>To load an OEM image, set this parameter to <b>NULL</b>. To load a stand-alone resource (icon, cursor, or bitmap file)—for example, c:\myimage.bmp—set this parameter to <b>NULL</b>.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-loadimagew#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <param name="name">
            <para>Type: <b>LPCTSTR</b> The image to be loaded. If the <i>hinst</i> parameter is non-<b>NULL</b> and the <i>fuLoad</i> parameter omits <b>LR_LOADFROMFILE</b>, <i>lpszName</i> specifies the image resource in the <i>hinst</i> module. If the image resource is to be loaded by name from the module, the <i>lpszName</i> parameter is a pointer to a null-terminated string that contains the name of the image resource. If the image resource is to be loaded by ordinal from the module, use the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-makeintresourcea">MAKEINTRESOURCE</a> macro to convert the image ordinal into a form that can be passed to the <b>LoadImage</b> function. For more information, see the Remarks section below. If the <i>hinst</i> parameter is <b>NULL</b> and the <i>fuLoad</i> parameter omits the <b>LR_LOADFROMFILE</b> value, the <i>lpszName</i> specifies the OEM image to load. The OEM image identifiers are defined in Winuser.h and have the following prefixes. </para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-loadimagew#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <param name="type">Type: <b>UINT</b></param>
            <param name="cx">
            <para>Type: <b>int</b> The width, in pixels, of the icon or cursor. If this parameter is zero and the <i>fuLoad</i> parameter is <b>LR_DEFAULTSIZE</b>, the function uses the <b>SM_CXICON</b> or <b>SM_CXCURSOR</b> system metric value to set the width. If this parameter is zero and <b>LR_DEFAULTSIZE</b> is not used, the function uses the actual resource width.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-loadimagew#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <param name="cy">
            <para>Type: <b>int</b> The height, in pixels, of the icon or cursor. If this parameter is zero and the <i>fuLoad</i> parameter is <b>LR_DEFAULTSIZE</b>, the function uses the <b>SM_CYICON</b> or <b>SM_CYCURSOR</b> system metric value to set the height. If this parameter is zero and <b>LR_DEFAULTSIZE</b> is not used, the function uses the actual resource height.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-loadimagew#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <param name="fuLoad">Type: <b>UINT</b></param>
            <returns>
            <para>Type: <b>HANDLE</b> If the function succeeds, the return value is the handle of the newly loaded image. If the function fails, the return value is <b>NULL</b>. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
            </returns>
            <remarks>
            <para>If <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-is_intresource">IS_INTRESOURCE</a>(<i>lpszName</i>) is <b>TRUE</b>, then <i>lpszName</i> specifies the integer identifier of the given resource. Otherwise, it is a pointer to a null-terminated string. If the first character of the string is a pound sign (#), then the remaining characters represent a decimal number that specifies the integer identifier of the resource. For example, the string "#258" represents the identifier 258. When you are finished using a bitmap, cursor, or icon you loaded without specifying the <b>LR_SHARED</b> flag, you can release its associated memory by calling one of the functions in the following table.</para>
            <para></para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-loadimagew#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.PInvoke.LoadString(System.Runtime.InteropServices.SafeHandle,System.UInt32,Windows.Win32.Foundation.PWSTR,System.Int32)">
            <inheritdoc cref="M:Windows.Win32.PInvoke.LoadString(Windows.Win32.Foundation.HINSTANCE,System.UInt32,Windows.Win32.Foundation.PWSTR,System.Int32)"/>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Windows.Win32.PInvoke.LoadString(Windows.Win32.Foundation.HINSTANCE,System.UInt32,Windows.Win32.Foundation.PWSTR,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:Windows.Win32.PInvoke.MapVirtualKey(System.UInt32,Windows.Win32.UI.Input.KeyboardAndMouse.MAP_VIRTUAL_KEY_TYPE)" -->
        <member name="M:Windows.Win32.PInvoke.MonitorFromRect(Windows.Win32.Foundation.RECT@,Windows.Win32.Graphics.Gdi.MONITOR_FROM_FLAGS)">
            <inheritdoc cref="M:Windows.Win32.PInvoke.MonitorFromRect(Windows.Win32.Foundation.RECT*,Windows.Win32.Graphics.Gdi.MONITOR_FROM_FLAGS)"/>
        </member>
        <member name="M:Windows.Win32.PInvoke.MonitorFromRect(Windows.Win32.Foundation.RECT*,Windows.Win32.Graphics.Gdi.MONITOR_FROM_FLAGS)">
            <summary>The MonitorFromRect function retrieves a handle to the display monitor that has the largest area of intersection with a specified rectangle.</summary>
            <param name="lprc">A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/windef/ns-windef-rect">RECT</a> structure that specifies the rectangle of interest in virtual-screen coordinates.</param>
            <param name="dwFlags">Determines the function's return value if the rectangle does not intersect any display monitor.</param>
            <returns>
            <para>If the rectangle intersects one or more display monitor rectangles, the return value is an <b>HMONITOR</b> handle to the display monitor that has the largest area of intersection with the rectangle. If the rectangle does not intersect a display monitor, the return value depends on the value of <i>dwFlags</i>.</para>
            </returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-monitorfromrect">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.PInvoke.ReleaseCapture">
            <summary>Releases the mouse capture from a window in the current thread and restores normal mouse input processing.</summary>
            <returns>
            <para>Type: <b>BOOL</b> If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
            </returns>
            <remarks>An application calls this function after calling the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-setcapture">SetCapture</a> function.</remarks>
        </member>
        <member name="M:Windows.Win32.PInvoke.SendMessage(Windows.Win32.Foundation.HWND,System.UInt32,Windows.Win32.Foundation.WPARAM,Windows.Win32.Foundation.LPARAM)">
            <summary>Sends the specified message to a window or windows. The SendMessage function calls the window procedure for the specified window and does not return until the window procedure has processed the message. (SendMessageW)</summary>
            <param name="hWnd">
            <para>Type: <b>HWND</b> A handle to the window whose window procedure will receive the message. If this parameter is <b>HWND_BROADCAST</b> ((HWND)0xffff), the message is sent to all top-level windows in the system, including disabled or invisible unowned windows, overlapped windows, and pop-up windows; but the message is not sent to child windows. Message sending is subject to UIPI. The thread of a process can send messages only to message queues of threads in processes of lesser or equal integrity level.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-sendmessagew#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <param name="Msg">
            <para>Type: <b>UINT</b> The message to be sent. For lists of the system-provided messages, see <a href="https://docs.microsoft.com/windows/desktop/winmsg/about-messages-and-message-queues">System-Defined Messages</a>.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-sendmessagew#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <param name="wParam">
            <para>Type: <b>WPARAM</b> Additional message-specific information.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-sendmessagew#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <param name="lParam">
            <para>Type: <b>LPARAM</b> Additional message-specific information.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-sendmessagew#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <returns>
            <para>Type: <b>LRESULT</b> The return value specifies the result of the message processing; it depends on the message sent.</para>
            </returns>
            <remarks>
            <para>When a message is blocked by UIPI the last error, retrieved with <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, is set to 5 (access denied). Applications that need to communicate using <b>HWND_BROADCAST</b> should use the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-registerwindowmessagea">RegisterWindowMessage</a> function to obtain a unique message for inter-application communication. The system only does marshalling for system messages (those in the range 0 to (<a href="https://docs.microsoft.com/windows/desktop/winmsg/wm-user">WM_USER</a>-1)). To send other messages (those &gt;= <b>WM_USER</b>) to another process, you must do custom marshalling. If the specified window was created by the calling thread, the window procedure is called immediately as a subroutine. If the specified window was created by a different thread, the system switches to that thread and calls the appropriate window procedure. Messages sent between threads are processed only when the receiving thread executes message retrieval code. The sending thread is blocked until the receiving thread processes the message. However, the sending thread will process incoming nonqueued messages while waiting for its message to be processed. To prevent this, use <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-sendmessagetimeouta">SendMessageTimeout</a> with SMTO_BLOCK set. For more information on nonqueued messages, see <a href="https://docs.microsoft.com/windows/desktop/winmsg/about-messages-and-message-queues">Nonqueued Messages</a>. An accessibility application can use <b>SendMessage</b> to send <a href="https://docs.microsoft.com/windows/desktop/inputdev/wm-appcommand">WM_APPCOMMAND</a> messages  to the shell to launch applications. This  functionality is not guaranteed to work for other types of applications.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-sendmessagew#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.PInvoke.SetFocus(Windows.Win32.Foundation.HWND)">
            <summary>Sets the keyboard focus to the specified window. The window must be attached to the calling thread's message queue.</summary>
            <param name="hWnd">
            <para>Type: **HWND** A handle to the window that will receive the keyboard input. If this parameter is NULL, keystrokes are ignored.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-setfocus#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <returns>
            <para>Type: **HWND** If the function succeeds, the return value is the handle to the window that previously had the keyboard focus. If the *hWnd* parameter is invalid or the window is not attached to the calling thread's message queue, the return value is NULL. To get extended error information, call [GetLastError function](../errhandlingapi/nf-errhandlingapi-getlasterror.md). Extended error ERROR_INVALID_PARAMETER (0x57) means that window is in disabled state.</para>
            </returns>
            <remarks>
            <para>This function sends a [WM_KILLFOCUS](/windows/desktop/inputdev/wm-killfocus) message to the window that loses the keyboard focus and a [WM_SETFOCUS](/windows/desktop/inputdev/wm-setfocus) message to the window that receives the keyboard focus. It also activates either the window that receives the focus or the parent of the window that receives the focus. If a window is active but does not have the focus, any key pressed produces the [WM_SYSCHAR](/windows/desktop/menurc/wm-syschar), [WM_SYSKEYDOWN](/windows/desktop/inputdev/wm-syskeydown), or [WM_SYSKEYUP](/windows/desktop/inputdev/wm-syskeyup) message. If the VK_MENU key is also pressed, bit 30 of the *lParam* parameter of the message is set. Otherwise, the messages produced do not have this bit set. By using the [AttachThreadInput function](nf-winuser-attachthreadinput.md), a thread can attach its input processing to another thread. This allows a thread to call SetFocus to set the keyboard focus to a window attached to another thread's message queue.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-setfocus#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.PInvoke.ToUnicode(System.UInt32,System.UInt32,System.ReadOnlySpan{System.Byte},Windows.Win32.Foundation.PWSTR,System.Int32,System.UInt32)">
            <inheritdoc cref="M:Windows.Win32.PInvoke.ToUnicode(System.UInt32,System.UInt32,System.Byte*,Windows.Win32.Foundation.PWSTR,System.Int32,System.UInt32)"/>
        </member>
        <member name="M:Windows.Win32.PInvoke.ToUnicode(System.UInt32,System.UInt32,System.Byte*,Windows.Win32.Foundation.PWSTR,System.Int32,System.UInt32)">
            <summary>Translates the specified virtual-key code and keyboard state to the corresponding Unicode character or characters. (ToUnicode)</summary>
            <param name="wVirtKey">
            <para>Type: <b>UINT</b> The virtual-key code to be translated. See <a href="https://docs.microsoft.com/windows/desktop/inputdev/virtual-key-codes">Virtual-Key Codes</a>.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-tounicode#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <param name="wScanCode">
            <para>Type: <b>UINT</b> The hardware <a href="https://docs.microsoft.com/windows/win32/inputdev/about-keyboard-input#scan-codes">scan code</a> of the key to be translated. The high-order bit of this value is set if the key is up.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-tounicode#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <param name="lpKeyState">
            <para>Type: <b>const BYTE*</b> A pointer to a 256-byte array that contains the current keyboard state. Each element (byte) in the array contains the state of one key. If the high-order bit of a byte is set, the key is down. The low bit, if set, indicates that the key is toggled on. In this function, only the toggle bit of the CAPS LOCK key is relevant. The toggle state of the NUM LOCK and SCROLL LOCK keys is ignored. See <a href="https://docs.microsoft.com/windows/win32/api/winuser/nf-winuser-getkeyboardstate">GetKeyboardState</a> for more info.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-tounicode#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <param name="pwszBuff">
            <para>Type: <b>LPWSTR</b> The buffer that receives the translated character or characters as array of UTF-16 code units. This buffer may be returned without being null-terminated even though the variable name suggests that it is null-terminated. You can use the return value of this method to determine how many characters were written.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-tounicode#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <param name="cchBuff">
            <para>Type: <b>int</b> The size, in characters, of the buffer pointed to by the <i>pwszBuff</i> parameter.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-tounicode#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <param name="wFlags">
            <para>Type: <b>UINT</b> The behavior of the function. If bit 0 is set, a menu is active. In this mode <b>Alt+Numeric keypad</b> key combinations are not handled. If bit 2 is set, keyboard state is not changed (Windows 10, version 1607 and newer) All other bits (through 31) are reserved.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-tounicode#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <returns>
            <para>Type: <b>int</b> The function returns one of the following values. </para>
            <para>This doc was truncated.</para>
            </returns>
            <remarks>
            <para>To specify a handle to the keyboard layout to use to translate the specified code, use the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-tounicodeex">ToUnicodeEx</a> function. Some keyboard layouts may return several characters and/or supplementary characters as <a href="https://docs.microsoft.com/windows/win32/intl/surrogates-and-supplementary-characters">surrogate pairs</a> in <i>pwszBuff</i>. If a dead key character (accent or diacritic) stored in the keyboard layout could not be combined with the specified virtual key to form a single character then the previous entered dead character can be combined with the current character. The parameters supplied to the <b>ToUnicodeEx</b> function might not be sufficient to translate the virtual-key code because a previous <a href="https://docs.microsoft.com/windows/win32/inputdev/about-keyboard-input#dead-character-messages">dead key</a> is stored in the keyboard layout. Typically, <b>ToUnicode</b> performs the translation based on the virtual-key code. In some cases, however, bit 15 of the <i>wScanCode</i> parameter can be used to distinguish between a key press and a key release (for example for ALT+numpad key entry). As <b>ToUnicode</b> translates the virtual-key code, it also changes the state of the kernel-mode keyboard buffer. This state-change affects dead keys, ligatures, <b>Alt+Numeric keypad</b> key entry, and so on. It might also cause undesired side-effects if used in conjunction with <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-translatemessage">TranslateMessage</a> (which also changes the state of the kernel-mode keyboard buffer).</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-tounicode#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="T:Windows.Win32.Foundation.PCWSTR">
            <summary>
            A pointer to a null-terminated, constant character string.
            </summary>
        </member>
        <member name="F:Windows.Win32.Foundation.PCWSTR.Value">
            <summary>
            A pointer to the first character in the string. The content should be considered readonly, as it was typed as constant in the SDK.
            </summary>
        </member>
        <member name="P:Windows.Win32.Foundation.PCWSTR.Length">
            <summary>
            Gets the number of characters up to the first null character (exclusive).
            </summary>
        </member>
        <member name="M:Windows.Win32.Foundation.PCWSTR.ToString">
            <summary>
            Returns a <see langword="string"/> with a copy of this character array, up to the first null character (exclusive).
            </summary>
            <returns>A <see langword="string"/>, or <see langword="null"/> if <see cref="F:Windows.Win32.Foundation.PCWSTR.Value"/> is <see langword="null"/>.</returns>
        </member>
        <member name="M:Windows.Win32.Foundation.PCWSTR.AsSpan">
            <summary>
            Returns a span of the characters in this string, up to the first null character (exclusive).
            </summary>
        </member>
        <member name="M:Windows.Win32.Foundation.PWSTR.ToString">
            <inheritdoc cref="M:Windows.Win32.Foundation.PCWSTR.ToString"/>
        </member>
        <member name="P:Windows.Win32.Foundation.PWSTR.Length">
            <inheritdoc cref="P:Windows.Win32.Foundation.PCWSTR.Length"/>
        </member>
        <member name="M:Windows.Win32.Foundation.PWSTR.AsSpan">
            <summary>
            Returns a span of the characters in this string, up to the first null character (exclusive).
            </summary>
        </member>
        <member name="T:Windows.Win32.Foundation.RECT">
            <summary>The RECT structure defines a rectangle by the coordinates of its upper-left and lower-right corners.</summary>
            <remarks>The RECT structure is identical to the <a href="https://docs.microsoft.com/windows/desktop/api/windef/ns-windef-rectl">RECTL</a> structure.</remarks>
        </member>
        <member name="F:Windows.Win32.Foundation.RECT.left">
            <summary>Specifies the <i>x</i>-coordinate of the upper-left corner of the rectangle.</summary>
        </member>
        <member name="F:Windows.Win32.Foundation.RECT.top">
            <summary>Specifies the <i>y</i>-coordinate of the upper-left corner of the rectangle.</summary>
        </member>
        <member name="F:Windows.Win32.Foundation.RECT.right">
            <summary>Specifies the <i>x</i>-coordinate of the lower-right corner of the rectangle.</summary>
        </member>
        <member name="F:Windows.Win32.Foundation.RECT.bottom">
            <summary>Specifies the <i>y</i>-coordinate of the lower-right corner of the rectangle.</summary>
        </member>
        <member name="T:Windows.Win32.FreeLibrarySafeHandle">
            <summary>
            Represents a Win32 handle that can be closed with <see cref="M:Windows.Win32.PInvoke.FreeLibrary(Windows.Win32.Foundation.HMODULE)"/>.
            </summary>
        </member>
        <member name="T:Windows.Win32.Graphics.Gdi.MONITORINFO">
            <summary>The MONITORINFO structure contains information about a display monitor.The GetMonitorInfo function stores information in a MONITORINFO structure or a MONITORINFOEX structure.The MONITORINFO structure is a subset of the MONITORINFOEX structure.</summary>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/ns-winuser-monitorinfo">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.Graphics.Gdi.MONITORINFO.cbSize">
            <summary>
            <para>The size of the structure, in bytes. Set this member to <c>sizeof ( MONITORINFO )</c> before calling the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-getmonitorinfoa">GetMonitorInfo</a> function. Doing so lets the function determine the type of structure you are passing to it.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/ns-winuser-monitorinfo#members">Read more on docs.microsoft.com</see>.</para>
            </summary>
        </member>
        <member name="F:Windows.Win32.Graphics.Gdi.MONITORINFO.rcMonitor">
            <summary>A <a href="https://docs.microsoft.com/windows/desktop/api/windef/ns-windef-rect">RECT</a> structure that specifies the display monitor rectangle, expressed in virtual-screen coordinates. Note that if the monitor is not the primary display monitor, some of the rectangle's coordinates may be negative values.</summary>
        </member>
        <member name="F:Windows.Win32.Graphics.Gdi.MONITORINFO.rcWork">
            <summary>A <a href="https://docs.microsoft.com/windows/desktop/api/windef/ns-windef-rect">RECT</a> structure that specifies the work area rectangle of the display monitor, expressed in virtual-screen coordinates. Note that if the monitor is not the primary display monitor, some of the rectangle's coordinates may be negative values.</summary>
        </member>
        <member name="F:Windows.Win32.Graphics.Gdi.MONITORINFO.dwFlags">
            <summary>
            <para>A set of flags that represent attributes of the display monitor. The following flag is defined. </para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/ns-winuser-monitorinfo#members">Read more on docs.microsoft.com</see>.</para>
            </summary>
        </member>
    </members>
</doc>
